{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/adapter.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/adapter.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport type { SecondaryStorage } from \"@better-auth/core/db\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport type { PredefinedApiKeyOptions } from \"./routes\";\nimport type { ApiKey } from \"./types\";\n\n/**\n * Parses double-stringified metadata synchronously without updating the database.\n * Use this for reading metadata, then call migrateLegacyMetadataInBackground for DB updates.\n *\n * @returns The properly parsed metadata object, or the original if already an object\n */\nexport function parseDoubleStringifiedMetadata(\n\tmetadata: ApiKey[\"metadata\"],\n): Record<string, any> | null {\n\t// If metadata is null/undefined, return null\n\tif (metadata == null) {\n\t\treturn null;\n\t}\n\n\t// If metadata is already an object, no migration needed\n\tif (typeof metadata === \"object\") {\n\t\treturn metadata;\n\t}\n\n\t// Metadata is a string - this is legacy double-stringified data\n\t// Parse it to get the actual object\n\treturn safeJSONParse<Record<string, any>>(metadata);\n}\n\n/**\n * Checks if metadata needs migration (is a string instead of object)\n */\nfunction needsMetadataMigration(metadata: ApiKey[\"metadata\"]): boolean {\n\treturn metadata != null && typeof metadata === \"string\";\n}\n\n/**\n * Batch migrates double-stringified metadata for multiple API keys.\n * Runs all updates in parallel to avoid N sequential database calls.\n */\nexport async function batchMigrateLegacyMetadata(\n\tctx: GenericEndpointContext,\n\tapiKeys: ApiKey[],\n\topts: PredefinedApiKeyOptions,\n): Promise<void> {\n\t// Only migrate for database storage\n\tif (opts.storage !== \"database\" && !opts.fallbackToDatabase) {\n\t\treturn;\n\t}\n\n\t// Filter keys that need migration\n\tconst keysToMigrate = apiKeys.filter((key) =>\n\t\tneedsMetadataMigration(key.metadata),\n\t);\n\n\tif (keysToMigrate.length === 0) {\n\t\treturn;\n\t}\n\n\t// Run migrations in parallel (not sequentially)\n\tconst migrationPromises = keysToMigrate.map(async (apiKey) => {\n\t\tconst parsed = parseDoubleStringifiedMetadata(apiKey.metadata);\n\t\ttry {\n\t\t\tawait ctx.context.adapter.update({\n\t\t\t\tmodel: \"apikey\",\n\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\tupdate: { metadata: parsed },\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tctx.context.logger.warn(\n\t\t\t\t`Failed to migrate double-stringified metadata for API key ${apiKey.id}:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t}\n\t});\n\n\tawait Promise.all(migrationPromises);\n}\n\n/**\n * Migrates double-stringified metadata to properly parsed object.\n *\n * This handles legacy data where metadata was incorrectly double-stringified.\n * If metadata is a string (should be object after adapter's transform.output),\n * it parses it and optionally updates the database.\n *\n * @returns The properly parsed metadata object\n */\nexport async function migrateDoubleStringifiedMetadata(\n\tctx: GenericEndpointContext,\n\tapiKey: ApiKey,\n\topts: PredefinedApiKeyOptions,\n): Promise<Record<string, any> | null> {\n\tconst parsed = parseDoubleStringifiedMetadata(apiKey.metadata);\n\n\t// Update the database to fix the legacy data (only for database storage)\n\tif (\n\t\tneedsMetadataMigration(apiKey.metadata) &&\n\t\t(opts.storage === \"database\" || opts.fallbackToDatabase)\n\t) {\n\t\ttry {\n\t\t\tawait ctx.context.adapter.update({\n\t\t\t\tmodel: \"apikey\",\n\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\tupdate: { metadata: parsed },\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// Log but don't fail the request if migration update fails\n\t\t\tctx.context.logger.warn(\n\t\t\t\t`Failed to migrate double-stringified metadata for API key ${apiKey.id}:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn parsed;\n}\n\n/**\n * Generate storage key for API key by hashed key\n */\nfunction getStorageKeyByHashedKey(hashedKey: string): string {\n\treturn `api-key:${hashedKey}`;\n}\n\n/**\n * Generate storage key for API key by ID\n */\nfunction getStorageKeyById(id: string): string {\n\treturn `api-key:by-id:${id}`;\n}\n\n/**\n * Generate storage key for user's API key list\n */\nfunction getStorageKeyByUserId(userId: string): string {\n\treturn `api-key:by-user:${userId}`;\n}\n\n/**\n * Serialize API key for storage\n */\nfunction serializeApiKey(apiKey: ApiKey): string {\n\treturn JSON.stringify({\n\t\t...apiKey,\n\t\tcreatedAt: apiKey.createdAt.toISOString(),\n\t\tupdatedAt: apiKey.updatedAt.toISOString(),\n\t\texpiresAt: apiKey.expiresAt?.toISOString() ?? null,\n\t\tlastRefillAt: apiKey.lastRefillAt?.toISOString() ?? null,\n\t\tlastRequest: apiKey.lastRequest?.toISOString() ?? null,\n\t});\n}\n\n/**\n * Deserialize API key from storage\n */\nfunction deserializeApiKey(data: unknown): ApiKey | null {\n\tif (!data || typeof data !== \"string\") {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst parsed = JSON.parse(data);\n\t\treturn {\n\t\t\t...parsed,\n\t\t\tcreatedAt: new Date(parsed.createdAt),\n\t\t\tupdatedAt: new Date(parsed.updatedAt),\n\t\t\texpiresAt: parsed.expiresAt ? new Date(parsed.expiresAt) : null,\n\t\t\tlastRefillAt: parsed.lastRefillAt ? new Date(parsed.lastRefillAt) : null,\n\t\t\tlastRequest: parsed.lastRequest ? new Date(parsed.lastRequest) : null,\n\t\t} as ApiKey;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\n/**\n * Get the storage instance to use (custom methods take precedence)\n */\nfunction getStorageInstance(\n\tctx: GenericEndpointContext,\n\topts: PredefinedApiKeyOptions,\n): SecondaryStorage | null {\n\tif (opts.customStorage) {\n\t\treturn opts.customStorage as SecondaryStorage;\n\t}\n\treturn ctx.context.secondaryStorage || null;\n}\n\n/**\n * Calculate TTL in seconds for an API key\n */\nfunction calculateTTL(apiKey: ApiKey): number | undefined {\n\tif (apiKey.expiresAt) {\n\t\tconst now = Date.now();\n\t\tconst expiresAt = new Date(apiKey.expiresAt).getTime();\n\t\tconst ttlSeconds = Math.floor((expiresAt - now) / 1000);\n\t\t// Only set TTL if expiration is in the future\n\t\tif (ttlSeconds > 0) {\n\t\t\treturn ttlSeconds;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Get API key from secondary storage by hashed key\n */\nasync function getApiKeyFromStorage(\n\tctx: GenericEndpointContext,\n\thashedKey: string,\n\tstorage: SecondaryStorage,\n): Promise<ApiKey | null> {\n\tconst key = getStorageKeyByHashedKey(hashedKey);\n\tconst data = await storage.get(key);\n\treturn deserializeApiKey(data);\n}\n\n/**\n * Get API key from secondary storage by ID\n */\nasync function getApiKeyByIdFromStorage(\n\tctx: GenericEndpointContext,\n\tid: string,\n\tstorage: SecondaryStorage,\n): Promise<ApiKey | null> {\n\tconst key = getStorageKeyById(id);\n\tconst data = await storage.get(key);\n\treturn deserializeApiKey(data);\n}\n\n/**\n * Store API key in secondary storage\n */\nasync function setApiKeyInStorage(\n\tctx: GenericEndpointContext,\n\tapiKey: ApiKey,\n\tstorage: SecondaryStorage,\n\tttl?: number | undefined,\n): Promise<void> {\n\tconst serialized = serializeApiKey(apiKey);\n\tconst hashedKey = apiKey.key;\n\tconst id = apiKey.id;\n\n\t// Store by hashed key (primary lookup)\n\tawait storage.set(getStorageKeyByHashedKey(hashedKey), serialized, ttl);\n\n\t// Store by ID (for ID-based lookups)\n\tawait storage.set(getStorageKeyById(id), serialized, ttl);\n\n\t// Update user's API key list\n\tconst userKey = getStorageKeyByUserId(apiKey.userId);\n\tconst userListData = await storage.get(userKey);\n\tlet userIds: string[] = [];\n\n\tif (userListData && typeof userListData === \"string\") {\n\t\ttry {\n\t\t\tuserIds = JSON.parse(userListData);\n\t\t} catch {\n\t\t\tuserIds = [];\n\t\t}\n\t} else if (Array.isArray(userListData)) {\n\t\tuserIds = userListData;\n\t}\n\n\tif (!userIds.includes(id)) {\n\t\tuserIds.push(id);\n\t\tawait storage.set(userKey, JSON.stringify(userIds));\n\t}\n}\n\n/**\n * Delete API key from secondary storage\n */\nasync function deleteApiKeyFromStorage(\n\tctx: GenericEndpointContext,\n\tapiKey: ApiKey,\n\tstorage: SecondaryStorage,\n): Promise<void> {\n\tconst hashedKey = apiKey.key;\n\tconst id = apiKey.id;\n\tconst userId = apiKey.userId;\n\n\t// Delete by hashed key\n\tawait storage.delete(getStorageKeyByHashedKey(hashedKey));\n\n\t// Delete by ID\n\tawait storage.delete(getStorageKeyById(id));\n\n\t// Update user's API key list\n\tconst userKey = getStorageKeyByUserId(userId);\n\tconst userListData = await storage.get(userKey);\n\tlet userIds: string[] = [];\n\n\tif (userListData && typeof userListData === \"string\") {\n\t\ttry {\n\t\t\tuserIds = JSON.parse(userListData);\n\t\t} catch {\n\t\t\tuserIds = [];\n\t\t}\n\t} else if (Array.isArray(userListData)) {\n\t\tuserIds = userListData;\n\t}\n\n\tconst filteredIds = userIds.filter((keyId) => keyId !== id);\n\tif (filteredIds.length === 0) {\n\t\tawait storage.delete(userKey);\n\t} else {\n\t\tawait storage.set(userKey, JSON.stringify(filteredIds));\n\t}\n}\n\n/**\n * Unified getter for API keys with support for all storage modes\n */\nexport async function getApiKey(\n\tctx: GenericEndpointContext,\n\thashedKey: string,\n\topts: PredefinedApiKeyOptions,\n): Promise<ApiKey | null> {\n\tconst storage = getStorageInstance(ctx, opts);\n\n\t// Database mode only\n\tif (opts.storage === \"database\") {\n\t\treturn await ctx.context.adapter.findOne<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"key\",\n\t\t\t\t\tvalue: hashedKey,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// Secondary storage mode with fallback\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tif (storage) {\n\t\t\tconst cached = await getApiKeyFromStorage(ctx, hashedKey, storage);\n\t\t\tif (cached) {\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\t\tconst dbKey = await ctx.context.adapter.findOne<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"key\",\n\t\t\t\t\tvalue: hashedKey,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\tif (dbKey && storage) {\n\t\t\t// Populate secondary storage for future reads\n\t\t\tconst ttl = calculateTTL(dbKey);\n\t\t\tawait setApiKeyInStorage(ctx, dbKey, storage, ttl);\n\t\t}\n\n\t\treturn dbKey;\n\t}\n\n\t// Secondary storage mode only\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) {\n\t\t\treturn null;\n\t\t}\n\t\treturn await getApiKeyFromStorage(ctx, hashedKey, storage);\n\t}\n\n\t// Default fallback\n\treturn await ctx.context.adapter.findOne<ApiKey>({\n\t\tmodel: \"apikey\",\n\t\twhere: [\n\t\t\t{\n\t\t\t\tfield: \"key\",\n\t\t\t\tvalue: hashedKey,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Unified getter for API keys by ID\n */\nexport async function getApiKeyById(\n\tctx: GenericEndpointContext,\n\tid: string,\n\topts: PredefinedApiKeyOptions,\n): Promise<ApiKey | null> {\n\tconst storage = getStorageInstance(ctx, opts);\n\n\t// Database mode only\n\tif (opts.storage === \"database\") {\n\t\treturn await ctx.context.adapter.findOne<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: id,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// Secondary storage mode with fallback\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tif (storage) {\n\t\t\tconst cached = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\tif (cached) {\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\t\tconst dbKey = await ctx.context.adapter.findOne<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"id\",\n\t\t\t\t\tvalue: id,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\tif (dbKey && storage) {\n\t\t\t// Populate secondary storage for future reads\n\t\t\tconst ttl = calculateTTL(dbKey);\n\t\t\tawait setApiKeyInStorage(ctx, dbKey, storage, ttl);\n\t\t}\n\n\t\treturn dbKey;\n\t}\n\n\t// Secondary storage mode only\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) {\n\t\t\treturn null;\n\t\t}\n\t\treturn await getApiKeyByIdFromStorage(ctx, id, storage);\n\t}\n\n\t// Default fallback\n\treturn await ctx.context.adapter.findOne<ApiKey>({\n\t\tmodel: \"apikey\",\n\t\twhere: [\n\t\t\t{\n\t\t\t\tfield: \"id\",\n\t\t\t\tvalue: id,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Unified setter for API keys with support for all storage modes\n */\nexport async function setApiKey(\n\tctx: GenericEndpointContext,\n\tapiKey: ApiKey,\n\topts: PredefinedApiKeyOptions,\n): Promise<void> {\n\tconst storage = getStorageInstance(ctx, opts);\n\tconst ttl = calculateTTL(apiKey);\n\n\t// Database mode only - handled by adapter in route handlers\n\tif (opts.storage === \"database\") {\n\t\treturn;\n\t}\n\n\t// Secondary storage mode (with or without fallback)\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Secondary storage is required when storage mode is 'secondary-storage'\",\n\t\t\t);\n\t\t}\n\t\tawait setApiKeyInStorage(ctx, apiKey, storage, ttl);\n\t\treturn;\n\t}\n}\n\n/**\n * Unified deleter for API keys with support for all storage modes\n */\nexport async function deleteApiKey(\n\tctx: GenericEndpointContext,\n\tapiKey: ApiKey,\n\topts: PredefinedApiKeyOptions,\n): Promise<void> {\n\tconst storage = getStorageInstance(ctx, opts);\n\n\t// Database mode only - handled by adapter in route handlers\n\tif (opts.storage === \"database\") {\n\t\treturn;\n\t}\n\n\t// Secondary storage mode (with or without fallback)\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Secondary storage is required when storage mode is 'secondary-storage'\",\n\t\t\t);\n\t\t}\n\t\tawait deleteApiKeyFromStorage(ctx, apiKey, storage);\n\t\treturn;\n\t}\n}\n\n/**\n * List API keys for a user with support for all storage modes\n */\nexport async function listApiKeys(\n\tctx: GenericEndpointContext,\n\tuserId: string,\n\topts: PredefinedApiKeyOptions,\n): Promise<ApiKey[]> {\n\tconst storage = getStorageInstance(ctx, opts);\n\n\t// Database mode only\n\tif (opts.storage === \"database\") {\n\t\treturn await ctx.context.adapter.findMany<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// Secondary storage mode with fallback\n\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\tconst userKey = getStorageKeyByUserId(userId);\n\n\t\tif (storage) {\n\t\t\tconst userListData = await storage.get(userKey);\n\t\t\tlet userIds: string[] = [];\n\n\t\t\tif (userListData && typeof userListData === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tuserIds = JSON.parse(userListData);\n\t\t\t\t} catch {\n\t\t\t\t\tuserIds = [];\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(userListData)) {\n\t\t\t\tuserIds = userListData;\n\t\t\t}\n\n\t\t\tif (userIds.length > 0) {\n\t\t\t\tconst apiKeys: ApiKey[] = [];\n\t\t\t\tfor (const id of userIds) {\n\t\t\t\t\tconst apiKey = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\t\t\tif (apiKey) {\n\t\t\t\t\t\tapiKeys.push(apiKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn apiKeys;\n\t\t\t}\n\t\t}\n\t\t// Fallback to database\n\t\tconst dbKeys = await ctx.context.adapter.findMany<ApiKey>({\n\t\t\tmodel: \"apikey\",\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\tvalue: userId,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\t// Populate secondary storage with fetched keys\n\t\tif (storage && dbKeys.length > 0) {\n\t\t\tconst userIds: string[] = [];\n\t\t\tfor (const apiKey of dbKeys) {\n\t\t\t\t// Store each key in secondary storage\n\t\t\t\tconst ttl = calculateTTL(apiKey);\n\t\t\t\tawait setApiKeyInStorage(ctx, apiKey, storage, ttl);\n\t\t\t\tuserIds.push(apiKey.id);\n\t\t\t}\n\t\t\t// Update user's key list in secondary storage\n\t\t\tawait storage.set(userKey, JSON.stringify(userIds));\n\t\t}\n\n\t\treturn dbKeys;\n\t}\n\n\t// Secondary storage mode only\n\tif (opts.storage === \"secondary-storage\") {\n\t\tif (!storage) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst userKey = getStorageKeyByUserId(userId);\n\t\tconst userListData = await storage.get(userKey);\n\t\tlet userIds: string[] = [];\n\n\t\tif (userListData && typeof userListData === \"string\") {\n\t\t\ttry {\n\t\t\t\tuserIds = JSON.parse(userListData);\n\t\t\t} catch {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t} else if (Array.isArray(userListData)) {\n\t\t\tuserIds = userListData;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst apiKeys: ApiKey[] = [];\n\t\tfor (const id of userIds) {\n\t\t\tconst apiKey = await getApiKeyByIdFromStorage(ctx, id, storage);\n\t\t\tif (apiKey) {\n\t\t\t\tapiKeys.push(apiKey);\n\t\t\t}\n\t\t}\n\n\t\treturn apiKeys;\n\t}\n\n\t// Default fallback\n\treturn await ctx.context.adapter.findMany<ApiKey>({\n\t\tmodel: \"apikey\",\n\t\twhere: [\n\t\t\t{\n\t\t\t\tfield: \"userId\",\n\t\t\t\tvalue: userId,\n\t\t\t},\n\t\t],\n\t});\n}\n"],"names":["userIds: string[]","apiKeys: ApiKey[]"],"mappings":"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"}},
    {"offset": {"line": 411, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/rate-limit.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/rate-limit.ts"],"sourcesContent":["import { ERROR_CODES } from \".\";\nimport type { PredefinedApiKeyOptions } from \"./routes\";\nimport type { ApiKey } from \"./types\";\n\ninterface RateLimitResult {\n\tsuccess: boolean;\n\tmessage: string | null;\n\ttryAgainIn: number | null;\n\tupdate: Partial<ApiKey> | null;\n}\n\n/**\n * Determines if a request is allowed based on rate limiting parameters.\n *\n * @returns An object indicating whether the request is allowed and, if not,\n *          a message and updated ApiKey data.\n */\nexport function isRateLimited(\n\t/**\n\t * The ApiKey object containing rate limiting information\n\t */\n\tapiKey: ApiKey,\n\topts: PredefinedApiKeyOptions,\n): RateLimitResult {\n\tconst now = new Date();\n\tconst lastRequest = apiKey.lastRequest;\n\tconst rateLimitTimeWindow = apiKey.rateLimitTimeWindow;\n\tconst rateLimitMax = apiKey.rateLimitMax;\n\tlet requestCount = apiKey.requestCount;\n\n\tif (opts.rateLimit.enabled === false)\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: null,\n\t\t\tupdate: { lastRequest: now },\n\t\t\ttryAgainIn: null,\n\t\t};\n\n\tif (apiKey.rateLimitEnabled === false)\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: null,\n\t\t\tupdate: { lastRequest: now },\n\t\t\ttryAgainIn: null,\n\t\t};\n\n\tif (rateLimitTimeWindow === null || rateLimitMax === null) {\n\t\t// Rate limiting is disabled.\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: null,\n\t\t\tupdate: null,\n\t\t\ttryAgainIn: null,\n\t\t};\n\t}\n\n\tif (lastRequest === null) {\n\t\t// No previous requests, so allow the first one.\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: null,\n\t\t\tupdate: { lastRequest: now, requestCount: 1 },\n\t\t\ttryAgainIn: null,\n\t\t};\n\t}\n\n\tconst timeSinceLastRequest = now.getTime() - new Date(lastRequest).getTime();\n\n\tif (timeSinceLastRequest > rateLimitTimeWindow) {\n\t\t// Time window has passed, reset the request count.\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: null,\n\t\t\tupdate: { lastRequest: now, requestCount: 1 },\n\t\t\ttryAgainIn: null,\n\t\t};\n\t}\n\n\tif (requestCount >= rateLimitMax) {\n\t\t// Rate limit exceeded.\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: ERROR_CODES.RATE_LIMIT_EXCEEDED,\n\t\t\tupdate: null,\n\t\t\ttryAgainIn: Math.ceil(rateLimitTimeWindow - timeSinceLastRequest),\n\t\t};\n\t}\n\n\t// Request is allowed.\n\trequestCount++;\n\treturn {\n\t\tsuccess: true,\n\t\tmessage: null,\n\t\ttryAgainIn: null,\n\t\tupdate: { lastRequest: now, requestCount: requestCount },\n\t};\n}\n"],"names":[],"mappings":";;;;;;;;;;;;GAiBA,SAAgB,cAIf,MAAA,EACA,IAAA,EACkB;IAClB,MAAM,MAAA,aAAA,GAAM,IAAI,MAAM;IACtB,MAAM,cAAc,OAAO,WAAA;IAC3B,MAAM,sBAAsB,OAAO,mBAAA;IACnC,MAAM,eAAe,OAAO,YAAA;IAC5B,IAAI,eAAe,OAAO,YAAA;IAE1B,IAAI,KAAK,SAAA,CAAU,OAAA,KAAY,MAC9B,CAAA,OAAO;QACN,SAAS;QACT,SAAS;QACT,QAAQ;YAAE,aAAa;QAAA,CAAK;QAC5B,YAAY;KACZ;IAEF,IAAI,OAAO,gBAAA,KAAqB,MAC/B,CAAA,OAAO;QACN,SAAS;QACT,SAAS;QACT,QAAQ;YAAE,aAAa;QAAA,CAAK;QAC5B,YAAY;KACZ;IAEF,IAAI,wBAAwB,QAAQ,iBAAiB,KAEpD,CAAA,OAAO;QACN,SAAS;QACT,SAAS;QACT,QAAQ;QACR,YAAY;KACZ;IAGF,IAAI,gBAAgB,KAEnB,CAAA,OAAO;QACN,SAAS;QACT,SAAS;QACT,QAAQ;YAAE,aAAa;YAAK,cAAc;SAAG;QAC7C,YAAY;KACZ;IAGF,MAAM,uBAAuB,IAAI,OAAA,EAAS,GAAG,IAAI,KAAK,YAAY,CAAC,OAAA,EAAS;IAE5E,IAAI,uBAAuB,oBAE1B,CAAA,OAAO;QACN,SAAS;QACT,SAAS;QACT,QAAQ;YAAE,aAAa;YAAK,cAAc;SAAG;QAC7C,YAAY;KACZ;IAGF,IAAI,gBAAgB,aAEnB,CAAA,OAAO;QACN,SAAS;QACT,SAAS,0LAAA,CAAY,mBAAA;QACrB,QAAQ;QACR,YAAY,KAAK,IAAA,CAAK,sBAAsB,qBAAqB;KACjE;IAIF;IACA,OAAO;QACN,SAAS;QACT,SAAS;QACT,YAAY;QACZ,QAAQ;YAAE,aAAa;YAAmB;SAAc;KACxD"}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/verify-api-key.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/verify-api-key.ts"],"sourcesContent":["import type { AuthContext, GenericEndpointContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { APIError } from \"../../../api\";\nimport { role } from \"../../access\";\nimport { API_KEY_TABLE_NAME, ERROR_CODES } from \"..\";\nimport { defaultKeyHasher } from \"../\";\nimport {\n\tdeleteApiKey,\n\tgetApiKey,\n\tmigrateDoubleStringifiedMetadata,\n\tsetApiKey,\n} from \"../adapter\";\nimport { isRateLimited } from \"../rate-limit\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey } from \"../types\";\nimport type { PredefinedApiKeyOptions } from \".\";\n\nexport async function validateApiKey({\n\thashedKey,\n\tctx,\n\topts,\n\tschema,\n\tpermissions,\n}: {\n\thashedKey: string;\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tpermissions?: Record<string, string[]> | undefined;\n\tctx: GenericEndpointContext;\n}) {\n\tconst apiKey = await getApiKey(ctx, hashedKey, opts);\n\n\tif (!apiKey) {\n\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t});\n\t}\n\n\tif (apiKey.enabled === false) {\n\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\tmessage: ERROR_CODES.KEY_DISABLED,\n\t\t\tcode: \"KEY_DISABLED\" as const,\n\t\t});\n\t}\n\n\tif (apiKey.expiresAt) {\n\t\tconst now = Date.now();\n\t\tconst expiresAt = new Date(apiKey.expiresAt).getTime();\n\t\tif (now > expiresAt) {\n\t\t\tconst deleteExpiredKey = async () => {\n\t\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\t\tawait deleteApiKey(ctx, apiKey, opts);\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\t\t});\n\t\t\t\t} else if (opts.storage === \"secondary-storage\") {\n\t\t\t\t\tawait deleteApiKey(ctx, apiKey, opts);\n\t\t\t\t} else {\n\t\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (opts.deferUpdates) {\n\t\t\t\tctx.context.runInBackground(\n\t\t\t\t\tdeleteExpiredKey().catch((error) => {\n\t\t\t\t\t\tctx.context.logger.error(\"Deferred update failed:\", error);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tawait deleteExpiredKey();\n\t\t\t}\n\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: ERROR_CODES.KEY_EXPIRED,\n\t\t\t\tcode: \"KEY_EXPIRED\" as const,\n\t\t\t});\n\t\t}\n\t}\n\n\tif (permissions) {\n\t\tconst apiKeyPermissions = apiKey.permissions\n\t\t\t? safeJSONParse<{\n\t\t\t\t\t[key: string]: string[];\n\t\t\t\t}>(apiKey.permissions)\n\t\t\t: null;\n\n\t\tif (!apiKeyPermissions) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\t\tcode: \"KEY_NOT_FOUND\" as const,\n\t\t\t});\n\t\t}\n\t\tconst r = role(apiKeyPermissions as any);\n\t\tconst result = r.authorize(permissions);\n\t\tif (!result.success) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\t\tcode: \"KEY_NOT_FOUND\" as const,\n\t\t\t});\n\t\t}\n\t}\n\n\tlet remaining = apiKey.remaining;\n\tlet lastRefillAt = apiKey.lastRefillAt;\n\n\tif (apiKey.remaining === 0 && apiKey.refillAmount === null) {\n\t\tconst deleteExhaustedKey = async () => {\n\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\tawait deleteApiKey(ctx, apiKey, opts);\n\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\t});\n\t\t\t} else if (opts.storage === \"secondary-storage\") {\n\t\t\t\tawait deleteApiKey(ctx, apiKey, opts);\n\t\t\t} else {\n\t\t\t\tawait ctx.context.adapter.delete({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tif (opts.deferUpdates) {\n\t\t\tctx.context.runInBackground(\n\t\t\t\tdeleteExhaustedKey().catch((error) => {\n\t\t\t\t\tctx.context.logger.error(\"Deferred update failed:\", error);\n\t\t\t\t}),\n\t\t\t);\n\t\t} else {\n\t\t\tawait deleteExhaustedKey();\n\t\t}\n\n\t\tthrow new APIError(\"TOO_MANY_REQUESTS\", {\n\t\t\tmessage: ERROR_CODES.USAGE_EXCEEDED,\n\t\t\tcode: \"USAGE_EXCEEDED\" as const,\n\t\t});\n\t} else if (remaining !== null) {\n\t\tconst now = Date.now();\n\t\tconst refillInterval = apiKey.refillInterval;\n\t\tconst refillAmount = apiKey.refillAmount;\n\t\tconst lastTime = new Date(lastRefillAt ?? apiKey.createdAt).getTime();\n\n\t\tif (refillInterval && refillAmount) {\n\t\t\t// if they provide refill info, then we should refill once the interval is reached.\n\n\t\t\tconst timeSinceLastRequest = now - lastTime;\n\t\t\tif (timeSinceLastRequest > refillInterval) {\n\t\t\t\tremaining = refillAmount;\n\t\t\t\tlastRefillAt = new Date();\n\t\t\t}\n\t\t}\n\n\t\tif (remaining === 0) {\n\t\t\t// if there are no more remaining requests, than the key is invalid\n\t\t\tthrow new APIError(\"TOO_MANY_REQUESTS\", {\n\t\t\t\tmessage: ERROR_CODES.USAGE_EXCEEDED,\n\t\t\t\tcode: \"USAGE_EXCEEDED\" as const,\n\t\t\t});\n\t\t} else {\n\t\t\tremaining--;\n\t\t}\n\t}\n\n\tconst { message, success, update, tryAgainIn } = isRateLimited(apiKey, opts);\n\n\tif (success === false) {\n\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\tmessage: message ?? undefined,\n\t\t\tcode: \"RATE_LIMITED\" as const,\n\t\t\tdetails: {\n\t\t\t\ttryAgainIn,\n\t\t\t},\n\t\t});\n\t}\n\n\tconst updated: ApiKey = {\n\t\t...apiKey,\n\t\t...update,\n\t\tremaining,\n\t\tlastRefillAt,\n\t\tupdatedAt: new Date(),\n\t};\n\n\tconst performUpdate = async (): Promise<ApiKey | null> => {\n\t\tif (opts.storage === \"database\") {\n\t\t\treturn ctx.context.adapter.update<ApiKey>({\n\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\tupdate: { ...updated, id: undefined },\n\t\t\t});\n\t\t} else if (\n\t\t\topts.storage === \"secondary-storage\" &&\n\t\t\topts.fallbackToDatabase\n\t\t) {\n\t\t\tconst dbUpdated = await ctx.context.adapter.update<ApiKey>({\n\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\twhere: [{ field: \"id\", value: apiKey.id }],\n\t\t\t\tupdate: { ...updated, id: undefined },\n\t\t\t});\n\t\t\tif (dbUpdated) {\n\t\t\t\tawait setApiKey(ctx, dbUpdated, opts);\n\t\t\t}\n\t\t\treturn dbUpdated;\n\t\t} else {\n\t\t\tawait setApiKey(ctx, updated, opts);\n\t\t\treturn updated;\n\t\t}\n\t};\n\n\tlet newApiKey: ApiKey | null = null;\n\n\tif (opts.deferUpdates) {\n\t\tctx.context.runInBackground(\n\t\t\tperformUpdate().catch((error) => {\n\t\t\t\tctx.context.logger.error(\"Failed to update API key:\", error);\n\t\t\t}),\n\t\t);\n\t\tnewApiKey = updated;\n\t} else {\n\t\tnewApiKey = await performUpdate();\n\t\tif (!newApiKey) {\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: ERROR_CODES.FAILED_TO_UPDATE_API_KEY,\n\t\t\t\tcode: \"INTERNAL_SERVER_ERROR\" as const,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn newApiKey;\n}\n\nconst verifyApiKeyBodySchema = z.object({\n\tkey: z.string().meta({\n\t\tdescription: \"The key to verify\",\n\t}),\n\tpermissions: z\n\t\t.record(z.string(), z.array(z.string()))\n\t\t.meta({\n\t\t\tdescription: \"The permissions to verify.\",\n\t\t})\n\t\t.optional(),\n});\n\nexport function verifyApiKey({\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): Promise<void>;\n}) {\n\treturn createAuthEndpoint(\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\tbody: verifyApiKeyBodySchema,\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst { key } = ctx.body;\n\n\t\t\tif (opts.customAPIKeyValidator) {\n\t\t\t\tconst isValid = await opts.customAPIKeyValidator({ ctx, key });\n\t\t\t\tif (!isValid) {\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\t\t\tcode: \"KEY_NOT_FOUND\" as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkey: null,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);\n\n\t\t\tlet apiKey: ApiKey | null = null;\n\n\t\t\ttry {\n\t\t\t\tapiKey = await validateApiKey({\n\t\t\t\t\thashedKey: hashed,\n\t\t\t\t\tpermissions: ctx.body.permissions,\n\t\t\t\t\tctx,\n\t\t\t\t\topts,\n\t\t\t\t\tschema,\n\t\t\t\t});\n\n\t\t\t\tif (opts.deferUpdates) {\n\t\t\t\t\tctx.context.runInBackground(\n\t\t\t\t\t\tdeleteAllExpiredApiKeys(ctx.context).catch((err) => {\n\t\t\t\t\t\t\tctx.context.logger.error(\n\t\t\t\t\t\t\t\t\"Failed to delete expired API keys:\",\n\t\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\"Failed to validate API key:\", error);\n\t\t\t\tif (error instanceof APIError) {\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tvalid: false,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: error.body?.message,\n\t\t\t\t\t\t\tcode: error.body?.code as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkey: null,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tvalid: false,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\t\tcode: \"INVALID_API_KEY\" as const,\n\t\t\t\t\t},\n\t\t\t\t\tkey: null,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { key: _, ...returningApiKey } = apiKey ?? {\n\t\t\t\tkey: 1,\n\t\t\t\tpermissions: undefined,\n\t\t\t};\n\n\t\t\t// Migrate legacy double-stringified metadata if needed\n\t\t\tlet migratedMetadata: Record<string, any> | null = null;\n\t\t\tif (apiKey) {\n\t\t\t\tmigratedMetadata = await migrateDoubleStringifiedMetadata(\n\t\t\t\t\tctx,\n\t\t\t\t\tapiKey,\n\t\t\t\t\topts,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturningApiKey.permissions = returningApiKey.permissions\n\t\t\t\t? safeJSONParse<{\n\t\t\t\t\t\t[key: string]: string[];\n\t\t\t\t\t}>(returningApiKey.permissions)\n\t\t\t\t: null;\n\n\t\t\treturn ctx.json({\n\t\t\t\tvalid: true,\n\t\t\t\terror: null,\n\t\t\t\tkey:\n\t\t\t\t\tapiKey === null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: ({\n\t\t\t\t\t\t\t\t...returningApiKey,\n\t\t\t\t\t\t\t\tmetadata: migratedMetadata,\n\t\t\t\t\t\t\t} as Omit<ApiKey, \"key\">),\n\t\t\t});\n\t\t},\n\t);\n}\n"],"names":["updated: ApiKey","newApiKey: ApiKey | null","apiKey: ApiKey | null","migratedMetadata: Record<string, any> | null"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA,eAAsB,eAAe,EACpC,SAAA,EACA,GAAA,EACA,IAAA,EACA,MAAA,EACA,WAAA,EAAA,EAOE;IACF,MAAM,SAAS,UAAM,0LAAA,EAAU,KAAK,WAAW,KAAK;IAEpD,IAAI,CAAC,OACJ,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;QAClC,SAAS,0LAAA,CAAY,eAAA;IAAA,CACrB,CAAC;IAGH,IAAI,OAAO,OAAA,KAAY,MACtB,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;QAClC,SAAS,0LAAA,CAAY,YAAA;QACrB,MAAM;KACN,CAAC;IAGH,IAAI,OAAO,SAAA,EAGV;YAFY,KAAK,GAAA,EAAK,GACJ,IAAI,KAAK,OAAO,SAAA,CAAU,CAAC,OAAA,EAAS,EACjC;YACpB,MAAM,mBAAmB,YAAY;gBACpC,IAAI,KAAK,OAAA,KAAY,uBAAuB,KAAK,kBAAA,EAAoB;oBACpE,UAAM,6LAAA,EAAa,KAAK,QAAQ,KAAK;oBACrC,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO;wBAChC,OAAO,iMAAA;wBACP,OAAO;4BAAC;gCAAE,OAAO;gCAAM,OAAO,OAAO,EAAA;6BAAI;yBAAC;qBAC1C,CAAC;2BACQ,KAAK,OAAA,KAAY,oBAC3B,CAAA,UAAM,6LAAA,EAAa,KAAK,QAAQ,KAAK;qBAErC,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO;oBAChC,OAAO,iMAAA;oBACP,OAAO;wBAAC;4BAAE,OAAO;4BAAM,OAAO,OAAO,EAAA;yBAAI;qBAAC;iBAC1C,CAAC;;YAIJ,IAAI,KAAK,YAAA,CACR,CAAA,IAAI,OAAA,CAAQ,eAAA,CACX,kBAAkB,CAAC,KAAA,CAAA,CAAO,UAAU;gBACnC,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,2BAA2B,MAAM;cACzD,CACF;iBAED,MAAM,kBAAkB;YAGzB,MAAM,IAAI,8JAAA,CAAS,gBAAgB;gBAClC,SAAS,0LAAA,CAAY,WAAA;gBACrB,MAAM;aACN,CAAC;;;IAIJ,IAAI,aAAa;QAChB,MAAM,oBAAoB,OAAO,WAAA,OAC9B,qLAAA,EAEE,OAAO,WAAA,CAAY,GACrB;QAEH,IAAI,CAAC,kBACJ,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;YAClC,SAAS,0LAAA,CAAY,aAAA;YACrB,MAAM;SACN,CAAC;QAIH,IAAI,KAFM,gLAAA,EAAK,kBAAyB,CACvB,SAAA,CAAU,YAAY,CAC3B,OAAA,CACX,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;YAClC,SAAS,0LAAA,CAAY,aAAA;YACrB,MAAM;SACN,CAAC;;IAIJ,IAAI,YAAY,OAAO,SAAA;IACvB,IAAI,eAAe,OAAO,YAAA;IAE1B,IAAI,OAAO,SAAA,KAAc,KAAK,OAAO,YAAA,KAAiB,MAAM;QAC3D,MAAM,qBAAqB,YAAY;YACtC,IAAI,KAAK,OAAA,KAAY,uBAAuB,KAAK,kBAAA,EAAoB;gBACpE,UAAM,6LAAA,EAAa,KAAK,QAAQ,KAAK;gBACrC,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO;oBAChC,OAAO,iMAAA;oBACP,OAAO;wBAAC;4BAAE,OAAO;4BAAM,OAAO,OAAO,EAAA;yBAAI;qBAAC;iBAC1C,CAAC;uBACQ,KAAK,OAAA,KAAY,oBAC3B,CAAA,UAAM,6LAAA,EAAa,KAAK,QAAQ,KAAK;iBAErC,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO;gBAChC,OAAO,iMAAA;gBACP,OAAO;oBAAC;wBAAE,OAAO;wBAAM,OAAO,OAAO,EAAA;qBAAI;iBAAC;aAC1C,CAAC;;QAIJ,IAAI,KAAK,YAAA,CACR,CAAA,IAAI,OAAA,CAAQ,eAAA,CACX,oBAAoB,CAAC,KAAA,CAAA,CAAO,UAAU;YACrC,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,2BAA2B,MAAM;UACzD,CACF;aAED,MAAM,oBAAoB;QAG3B,MAAM,IAAI,8JAAA,CAAS,qBAAqB;YACvC,SAAS,0LAAA,CAAY,cAAA;YACrB,MAAM;SACN,CAAC;eACQ,cAAc,MAAM;QAC9B,MAAM,MAAM,KAAK,GAAA,EAAK;QACtB,MAAM,iBAAiB,OAAO,cAAA;QAC9B,MAAM,eAAe,OAAO,YAAA;QAC5B,MAAM,WAAW,IAAI,KAAK,gBAAgB,OAAO,SAAA,CAAU,CAAC,OAAA,EAAS;QAErE,IAAI,kBAAkB,cAIrB;gBAD6B,MAAM,WACR,gBAAgB;gBAC1C,YAAY;gBACZ,eAAA,aAAA,GAAe,IAAI,MAAM;;;QAI3B,IAAI,cAAc,EAEjB,CAAA,MAAM,IAAI,8JAAA,CAAS,qBAAqB;YACvC,SAAS,0LAAA,CAAY,cAAA;YACrB,MAAM;SACN,CAAC;aAEF;;IAIF,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,MAAA,EAAQ,UAAA,EAAA,OAAe,oMAAA,EAAc,QAAQ,KAAK;IAE5E,IAAI,YAAY,MACf,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;QAClC,SAAS,WAAW,KAAA;QACpB,MAAM;QACN,SAAS;YACR;QAAA,CACA;KACD,CAAC;IAGH,MAAMA,UAAkB;QACvB,GAAG,MAAA;QACH,GAAG,MAAA;QACH;QACA;QACA,WAAA,aAAA,GAAW,IAAI,MAAM;KACrB;IAED,MAAM,gBAAgB,YAAoC;QACzD,IAAI,KAAK,OAAA,KAAY,WACpB,CAAA,OAAO,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAe;YACzC,OAAO,iMAAA;YACP,OAAO;gBAAC;oBAAE,OAAO;oBAAM,OAAO,OAAO,EAAA;iBAAI;aAAC;YAC1C,QAAQ;gBAAE,GAAG,OAAA;gBAAS,IAAI,KAAA;aAAW;SACrC,CAAC;iBAEF,KAAK,OAAA,KAAY,uBACjB,KAAK,kBAAA,EACJ;YACD,MAAM,YAAY,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAe;gBAC1D,OAAO,iMAAA;gBACP,OAAO;oBAAC;wBAAE,OAAO;wBAAM,OAAO,OAAO,EAAA;qBAAI;iBAAC;gBAC1C,QAAQ;oBAAE,GAAG,OAAA;oBAAS,IAAI,KAAA;iBAAW;aACrC,CAAC;YACF,IAAI,UACH,CAAA,UAAM,0LAAA,EAAU,KAAK,WAAW,KAAK;YAEtC,OAAO;eACD;YACN,UAAM,0LAAA,EAAU,KAAK,SAAS,KAAK;YACnC,OAAO;;;IAIT,IAAIC,YAA2B;IAE/B,IAAI,KAAK,YAAA,EAAc;QACtB,IAAI,OAAA,CAAQ,eAAA,CACX,eAAe,CAAC,KAAA,CAAA,CAAO,UAAU;YAChC,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,6BAA6B,MAAM;UAC3D,CACF;QACD,YAAY;WACN;QACN,YAAY,MAAM,eAAe;QACjC,IAAI,CAAC,UACJ,CAAA,MAAM,IAAI,8JAAA,CAAS,yBAAyB;YAC3C,SAAS,0LAAA,CAAY,wBAAA;YACrB,MAAM;SACN,CAAC;;IAIJ,OAAO;;AAGR,MAAM,yBAAyB,EAAE,yJAAA,CAAO;IACvC,KAAK,EAAE,yJAAA,EAAQ,CAAC,IAAA,CAAK;QACpB,aAAa;IAAA,CACb,CAAC;IACF,aAAa,EACX,yJAAA,CAAO,EAAE,yJAAA,EAAQ,EAAE,EAAE,wJAAA,CAAM,EAAE,yJAAA,EAAQ,CAAC,CAAC,CACvC,IAAA,CAAK;QACL,aAAa;IAAA,CACb,CAAC,CACD,QAAA,EAAU;CACZ,CAAC;AAEF,SAAgB,aAAa,EAC5B,IAAA,EACA,MAAA,EACA,uBAAA,EAAA,EAQE;IACF,WAAO,yLAAA,EACN;QACC,QAAQ;QACR,MAAM;KACN,EACD,OAAO,QAAQ;QACd,MAAM,EAAE,GAAA,EAAA,GAAQ,IAAI,IAAA;QAEpB,IAAI,KAAK,qBAAA,EAER;gBAAI,CADY,MAAM,KAAK,qBAAA,CAAsB;gBAAE;gBAAK;aAAK,CAAC,CAE7D,CAAA,OAAO,IAAI,IAAA,CAAK;gBACf,OAAO;gBACP,OAAO;oBACN,SAAS,0LAAA,CAAY,eAAA;oBACrB,MAAM;iBACN;gBACD,KAAK;aACL,CAAC;;QAIJ,MAAM,SAAS,KAAK,iBAAA,GAAoB,MAAM,UAAM,+LAAA,EAAiB,IAAI;QAEzE,IAAIC,SAAwB;QAE5B,IAAI;YACH,SAAS,MAAM,eAAe;gBAC7B,WAAW;gBACX,aAAa,IAAI,IAAA,CAAK,WAAA;gBACtB;gBACA;gBACA;aACA,CAAC;YAEF,IAAI,KAAK,YAAA,CACR,CAAA,IAAI,OAAA,CAAQ,eAAA,CACX,wBAAwB,IAAI,OAAA,CAAQ,CAAC,KAAA,CAAA,CAAO,QAAQ;gBACnD,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAClB,sCACA,IACA;cACA,CACF;iBAEM,OAAO;YACf,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,+BAA+B,MAAM;YAC9D,IAAI,iBAAiB,8JAAA,CACpB,CAAA,OAAO,IAAI,IAAA,CAAK;gBACf,OAAO;gBACP,OAAO;oBACN,SAAS,MAAM,IAAA,EAAM;oBACrB,MAAM,MAAM,IAAA,EAAM;iBAClB;gBACD,KAAK;aACL,CAAC;YAGH,OAAO,IAAI,IAAA,CAAK;gBACf,OAAO;gBACP,OAAO;oBACN,SAAS,0LAAA,CAAY,eAAA;oBACrB,MAAM;iBACN;gBACD,KAAK;aACL,CAAC;;QAGH,MAAM,EAAE,KAAK,CAAA,EAAG,GAAG,iBAAA,GAAoB,UAAU;YAChD,KAAK;YACL,aAAa,KAAA;SACb;QAGD,IAAIC,mBAA+C;QACnD,IAAI,OACH,CAAA,mBAAmB,UAAM,iNAAA,EACxB,KACA,QACA,KACA;QAGF,gBAAgB,WAAA,GAAc,gBAAgB,WAAA,OAC3C,qLAAA,EAEE,gBAAgB,WAAA,CAAY,GAC9B;QAEH,OAAO,IAAI,IAAA,CAAK;YACf,OAAO;YACP,OAAO;YACP,KACC,WAAW,OACR,OACC;gBACD,GAAG,eAAA;gBACH,UAAU;aACV;SACJ,CAAC;MAEH"}},
    {"offset": {"line": 773, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/create-api-key.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/create-api-key.ts"],"sourcesContent":["import type { AuthContext, Awaitable } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { APIError, getSessionFromCtx } from \"../../../api\";\nimport { generateId } from \"../../../utils\";\nimport { getDate } from \"../../../utils/date\";\nimport { API_KEY_TABLE_NAME, ERROR_CODES } from \"..\";\nimport { defaultKeyHasher } from \"../\";\nimport { setApiKey } from \"../adapter\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey } from \"../types\";\nimport type { PredefinedApiKeyOptions } from \".\";\n\nconst createApiKeyBodySchema = z.object({\n\tname: z.string().meta({ description: \"Name of the Api Key\" }).optional(),\n\texpiresIn: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"Expiration time of the Api Key in seconds\",\n\t\t})\n\t\t.min(1)\n\t\t.optional()\n\t\t.nullable()\n\t\t.default(null),\n\n\tuserId: z.coerce\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t'User Id of the user that the Api Key belongs to. server-only. Eg: \"user-id\"',\n\t\t})\n\t\t.optional(),\n\tprefix: z\n\t\t.string()\n\t\t.meta({ description: \"Prefix of the Api Key\" })\n\t\t.regex(/^[a-zA-Z0-9_-]+$/, {\n\t\t\tmessage:\n\t\t\t\t\"Invalid prefix format, must be alphanumeric and contain only underscores and hyphens.\",\n\t\t})\n\t\t.optional(),\n\tremaining: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"Remaining number of requests. Server side only\",\n\t\t})\n\t\t.min(0)\n\t\t.optional()\n\t\t.nullable()\n\t\t.default(null),\n\tmetadata: z.any().optional(),\n\trefillAmount: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Amount to refill the remaining count of the Api Key. server-only. Eg: 100\",\n\t\t})\n\t\t.min(1)\n\t\t.optional(),\n\trefillInterval: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Interval to refill the Api Key in milliseconds. server-only. Eg: 1000\",\n\t\t})\n\t\t.optional(),\n\trateLimitTimeWindow: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000\",\n\t\t})\n\t\t.optional(),\n\trateLimitMax: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100\",\n\t\t})\n\t\t.optional(),\n\trateLimitEnabled: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Whether the key has rate limiting enabled. server-only. Eg: true\",\n\t\t})\n\t\t.optional(),\n\tpermissions: z\n\t\t.record(z.string(), z.array(z.string()))\n\t\t.meta({\n\t\t\tdescription: \"Permissions of the Api Key.\",\n\t\t})\n\t\t.optional(),\n});\n\nexport function createApiKey({\n\tkeyGenerator,\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\tkeyGenerator: (options: {\n\t\tlength: number;\n\t\tprefix: string | undefined;\n\t}) => Awaitable<string>;\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): void;\n}) {\n\treturn createAuthEndpoint(\n\t\t\"/api-key/create\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\tbody: createApiKeyBodySchema,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Create a new API key for a user\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"API key created successfully\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Unique identifier of the API key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Creation timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Last update timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Name of the API key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Prefix of the API key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Starting characters of the key (if configured)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tkey: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The full API key (only returned on creation)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the key is enabled\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Expiration timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"ID of the user owning the key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Last refill timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Last request timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Metadata associated with the key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Maximum requests in time window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Rate limit time window in milliseconds\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Remaining requests\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Amount to refill\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Refill interval in milliseconds\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether rate limiting is enabled\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Current request count in window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\t\t\t\titems: { type: \"string\" },\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Permissions associated with the key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"key\",\n\t\t\t\t\t\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst {\n\t\t\t\tname,\n\t\t\t\texpiresIn,\n\t\t\t\tprefix,\n\t\t\t\tremaining,\n\t\t\t\tmetadata,\n\t\t\t\trefillAmount,\n\t\t\t\trefillInterval,\n\t\t\t\tpermissions,\n\t\t\t\trateLimitMax,\n\t\t\t\trateLimitTimeWindow,\n\t\t\t\trateLimitEnabled,\n\t\t\t} = ctx.body;\n\n\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\tconst authRequired = ctx.request || ctx.headers;\n\t\t\tconst user =\n\t\t\t\tauthRequired && !session\n\t\t\t\t\t? null\n\t\t\t\t\t: session?.user || { id: ctx.body.userId };\n\n\t\t\tif (!user?.id) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: ERROR_CODES.UNAUTHORIZED_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (session && ctx.body.userId && session?.user.id !== ctx.body.userId) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: ERROR_CODES.UNAUTHORIZED_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (authRequired) {\n\t\t\t\t// if this endpoint was being called from the client,\n\t\t\t\t// we must make sure they can't use server-only properties.\n\t\t\t\tif (\n\t\t\t\t\trefillAmount !== undefined ||\n\t\t\t\t\trefillInterval !== undefined ||\n\t\t\t\t\trateLimitMax !== undefined ||\n\t\t\t\t\trateLimitTimeWindow !== undefined ||\n\t\t\t\t\trateLimitEnabled !== undefined ||\n\t\t\t\t\tpermissions !== undefined ||\n\t\t\t\t\tremaining !== null\n\t\t\t\t) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.SERVER_ONLY_PROPERTY,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if metadata is defined, than check that it's an object.\n\t\t\tif (metadata) {\n\t\t\t\tif (opts.enableMetadata === false) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.METADATA_DISABLED,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (typeof metadata !== \"object\") {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_METADATA_TYPE,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// make sure that if they pass a refill amount, they also pass a refill interval\n\t\t\tif (refillAmount && !refillInterval) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED,\n\t\t\t\t});\n\t\t\t}\n\t\t\t// make sure that if they pass a refill interval, they also pass a refill amount\n\t\t\tif (refillInterval && !refillAmount) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (expiresIn) {\n\t\t\t\tif (opts.keyExpiration.disableCustomExpiresTime === true) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.KEY_DISABLED_EXPIRATION,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst expiresIn_in_days = expiresIn / (60 * 60 * 24);\n\n\t\t\t\tif (opts.keyExpiration.minExpiresIn > expiresIn_in_days) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL,\n\t\t\t\t\t});\n\t\t\t\t} else if (opts.keyExpiration.maxExpiresIn < expiresIn_in_days) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prefix) {\n\t\t\t\tif (prefix.length < opts.minimumPrefixLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_PREFIX_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (prefix.length > opts.maximumPrefixLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_PREFIX_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (name) {\n\t\t\t\tif (name.length < opts.minimumNameLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_NAME_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (name.length > opts.maximumNameLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_NAME_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (opts.requireName) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: ERROR_CODES.NAME_REQUIRED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdeleteAllExpiredApiKeys(ctx.context);\n\n\t\t\tconst key = await keyGenerator({\n\t\t\t\tlength: opts.defaultKeyLength,\n\t\t\t\tprefix: prefix || opts.defaultPrefix,\n\t\t\t});\n\n\t\t\tconst hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);\n\n\t\t\tlet start: string | null = null;\n\n\t\t\tif (opts.startingCharactersConfig.shouldStore) {\n\t\t\t\tstart = key.substring(\n\t\t\t\t\t0,\n\t\t\t\t\topts.startingCharactersConfig.charactersLength,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst defaultPermissions = opts.permissions?.defaultPermissions\n\t\t\t\t? typeof opts.permissions.defaultPermissions === \"function\"\n\t\t\t\t\t? await opts.permissions.defaultPermissions(user.id, ctx)\n\t\t\t\t\t: opts.permissions.defaultPermissions\n\t\t\t\t: undefined;\n\t\t\tconst permissionsToApply = permissions\n\t\t\t\t? JSON.stringify(permissions)\n\t\t\t\t: defaultPermissions\n\t\t\t\t\t? JSON.stringify(defaultPermissions)\n\t\t\t\t\t: undefined;\n\n\t\t\tconst data: Omit<ApiKey, \"id\"> = {\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tname: name ?? null,\n\t\t\t\tprefix: prefix ?? opts.defaultPrefix ?? null,\n\t\t\t\tstart: start,\n\t\t\t\tkey: hashed,\n\t\t\t\tenabled: true,\n\t\t\t\texpiresAt: expiresIn\n\t\t\t\t\t? getDate(expiresIn, \"sec\")\n\t\t\t\t\t: opts.keyExpiration.defaultExpiresIn\n\t\t\t\t\t\t? getDate(opts.keyExpiration.defaultExpiresIn, \"sec\")\n\t\t\t\t\t\t: null,\n\t\t\t\tuserId: user.id,\n\t\t\t\tlastRefillAt: null,\n\t\t\t\tlastRequest: null,\n\t\t\t\tmetadata: null,\n\t\t\t\trateLimitMax: rateLimitMax ?? opts.rateLimit.maxRequests ?? null,\n\t\t\t\trateLimitTimeWindow:\n\t\t\t\t\trateLimitTimeWindow ?? opts.rateLimit.timeWindow ?? null,\n\t\t\t\tremaining:\n\t\t\t\t\tremaining === null ? remaining : (remaining ?? refillAmount ?? null),\n\t\t\t\trefillAmount: refillAmount ?? null,\n\t\t\t\trefillInterval: refillInterval ?? null,\n\t\t\t\trateLimitEnabled:\n\t\t\t\t\trateLimitEnabled === undefined\n\t\t\t\t\t\t? (opts.rateLimit.enabled ?? true)\n\t\t\t\t\t\t: rateLimitEnabled,\n\t\t\t\trequestCount: 0,\n\t\t\t\t//@ts-expect-error - we intentionally save the permissions as string on DB.\n\t\t\t\tpermissions: permissionsToApply,\n\t\t\t};\n\n\t\t\tif (metadata) {\n\t\t\t\t// The adapter will automatically apply the schema transform to stringify\n\t\t\t\tdata.metadata = metadata;\n\t\t\t}\n\n\t\t\tlet apiKey: ApiKey;\n\n\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\tapiKey = await ctx.context.adapter.create<Omit<ApiKey, \"id\">, ApiKey>({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\tdata: data,\n\t\t\t\t});\n\t\t\t\tawait setApiKey(ctx, apiKey, opts);\n\t\t\t} else if (opts.storage === \"secondary-storage\") {\n\t\t\t\tconst generatedId = ctx.context.generateId({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t});\n\t\t\t\tconst id = generatedId || generateId();\n\t\t\t\tapiKey = {\n\t\t\t\t\t...data,\n\t\t\t\t\tid,\n\t\t\t\t} as ApiKey;\n\t\t\t\tawait setApiKey(ctx, apiKey, opts);\n\t\t\t} else {\n\t\t\t\tapiKey = await ctx.context.adapter.create<Omit<ApiKey, \"id\">, ApiKey>({\n\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\tdata: data,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn ctx.json({\n\t\t\t\t...(apiKey as ApiKey),\n\t\t\t\tkey: key,\n\t\t\t\tmetadata: metadata ?? null,\n\t\t\t\tpermissions: apiKey.permissions\n\t\t\t\t\t? safeJSONParse(apiKey.permissions)\n\t\t\t\t\t: null,\n\t\t\t});\n\t\t},\n\t);\n}\n"],"names":["start: string | null","data: Omit<ApiKey, \"id\">","apiKey: ApiKey","generateId"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA,MAAM,yBAAyB,EAAE,yJAAA,CAAO;IACvC,MAAM,EAAE,yJAAA,EAAQ,CAAC,IAAA,CAAK;QAAE,aAAa;IAAA,CAAuB,CAAC,CAAC,QAAA,EAAU;IACxE,WAAW,EACT,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aAAa;IAAA,CACb,CAAC,CACD,GAAA,CAAI,EAAE,CACN,QAAA,EAAU,CACV,QAAA,EAAU,CACV,OAAA,CAAQ,KAAK;IAEf,QAAQ,EAAE,0JAAA,CACR,MAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,QAAQ,EACN,yJAAA,EAAQ,CACR,IAAA,CAAK;QAAE,aAAa;IAAA,CAAyB,CAAC,CAC9C,KAAA,CAAM,oBAAoB;QAC1B,SACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,WAAW,EACT,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aAAa;IAAA,CACb,CAAC,CACD,GAAA,CAAI,EAAE,CACN,QAAA,EAAU,CACV,QAAA,EAAU,CACV,OAAA,CAAQ,KAAK;IACf,UAAU,EAAE,sJAAA,EAAK,CAAC,QAAA,EAAU;IAC5B,cAAc,EACZ,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,GAAA,CAAI,EAAE,CACN,QAAA,EAAU;IACZ,gBAAgB,EACd,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,qBAAqB,EACnB,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,cAAc,EACZ,yJAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,kBAAkB,EAChB,0JAAA,EAAS,CACT,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;IACZ,aAAa,EACX,yJAAA,CAAO,EAAE,yJAAA,EAAQ,EAAE,EAAE,wJAAA,CAAM,EAAE,yJAAA,EAAQ,CAAC,CAAC,CACvC,IAAA,CAAK;QACL,aAAa;IAAA,CACb,CAAC,CACD,QAAA,EAAU;CACZ,CAAC;AAEF,SAAgB,aAAa,EAC5B,YAAA,EACA,IAAA,EACA,MAAA,EACA,uBAAA,EAAA,EAYE;IACF,WAAO,yLAAA,EACN,mBACA;QACC,QAAQ;QACR,MAAM;QACN,UAAU;YACT,SAAS;gBACR,aAAa;gBACb,WAAW;oBACV,OAAO;wBACN,aAAa;wBACb,SAAS;4BACR,oBAAoB;gCACnB,QAAQ;oCACP,MAAM;oCACN,YAAY;wCACX,IAAI;4CACH,MAAM;4CACN,aAAa;yCACb;wCACD,WAAW;4CACV,MAAM;4CACN,QAAQ;4CACR,aAAa;yCACb;wCACD,WAAW;4CACV,MAAM;4CACN,QAAQ;4CACR,aAAa;yCACb;wCACD,MAAM;4CACL,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,QAAQ;4CACP,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,OAAO;4CACN,MAAM;4CACN,UAAU;4CACV,aACC;yCACD;wCACD,KAAK;4CACJ,MAAM;4CACN,aACC;yCACD;wCACD,SAAS;4CACR,MAAM;4CACN,aAAa;yCACb;wCACD,WAAW;4CACV,MAAM;4CACN,QAAQ;4CACR,UAAU;4CACV,aAAa;yCACb;wCACD,QAAQ;4CACP,MAAM;4CACN,aAAa;yCACb;wCACD,cAAc;4CACb,MAAM;4CACN,QAAQ;4CACR,UAAU;4CACV,aAAa;yCACb;wCACD,aAAa;4CACZ,MAAM;4CACN,QAAQ;4CACR,UAAU;4CACV,aAAa;yCACb;wCACD,UAAU;4CACT,MAAM;4CACN,UAAU;4CACV,sBAAsB;4CACtB,aAAa;yCACb;wCACD,cAAc;4CACb,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,qBAAqB;4CACpB,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,WAAW;4CACV,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,cAAc;4CACb,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,gBAAgB;4CACf,MAAM;4CACN,UAAU;4CACV,aAAa;yCACb;wCACD,kBAAkB;4CACjB,MAAM;4CACN,aAAa;yCACb;wCACD,cAAc;4CACb,MAAM;4CACN,aAAa;yCACb;wCACD,aAAa;4CACZ,MAAM;4CACN,UAAU;4CACV,sBAAsB;gDACrB,MAAM;gDACN,OAAO;oDAAE,MAAM;gDAAA,CAAU;6CACzB;4CACD,aAAa;yCACb;qCACD;oCACD,UAAU;wCACT;wCACA;wCACA;wCACA;wCACA;wCACA;wCACA;wCACA;qCACA;iCACD;4BAAA,CACD;wBAAA,CACD;qBACD;gBAAA,CACD;aACD;QAAA,CACD;KACD,EACD,OAAO,QAAQ;QACd,MAAM,EACL,IAAA,EACA,SAAA,EACA,MAAA,EACA,SAAA,EACA,QAAA,EACA,YAAA,EACA,cAAA,EACA,WAAA,EACA,YAAA,EACA,mBAAA,EACA,gBAAA,EAAA,GACG,IAAI,IAAA;QAER,MAAM,UAAU,UAAM,0LAAA,EAAkB,IAAI;QAC5C,MAAM,eAAe,IAAI,OAAA,IAAW,IAAI,OAAA;QACxC,MAAM,OACL,gBAAgB,CAAC,UACd,OACA,SAAS,QAAQ;YAAE,IAAI,IAAI,IAAA,CAAK,MAAA;QAAA,CAAQ;QAE5C,IAAI,CAAC,MAAM,GACV,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;YAClC,SAAS,0LAAA,CAAY,oBAAA;QAAA,CACrB,CAAC;QAGH,IAAI,WAAW,IAAI,IAAA,CAAK,MAAA,IAAU,SAAS,KAAK,OAAO,IAAI,IAAA,CAAK,MAAA,CAC/D,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;YAClC,SAAS,0LAAA,CAAY,oBAAA;QAAA,CACrB,CAAC;QAGH,IAAI,cAGH;gBACC,iBAAiB,KAAA,KACjB,mBAAmB,KAAA,KACnB,iBAAiB,KAAA,KACjB,wBAAwB,KAAA,KACxB,qBAAqB,KAAA,KACrB,gBAAgB,KAAA,KAChB,cAAc,KAEd,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,oBAAA;YAAA,CACrB,CAAC;;QAKJ,IAAI,UAAU;YACb,IAAI,KAAK,cAAA,KAAmB,MAC3B,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,iBAAA;YAAA,CACrB,CAAC;YAEH,IAAI,OAAO,aAAa,SACvB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,qBAAA;YAAA,CACrB,CAAC;;QAKJ,IAAI,gBAAgB,CAAC,eACpB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;YACjC,SAAS,0LAAA,CAAY,mCAAA;QAAA,CACrB,CAAC;QAGH,IAAI,kBAAkB,CAAC,aACtB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;YACjC,SAAS,0LAAA,CAAY,mCAAA;QAAA,CACrB,CAAC;QAGH,IAAI,WAAW;YACd,IAAI,KAAK,aAAA,CAAc,wBAAA,KAA6B,KACnD,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,uBAAA;YAAA,CACrB,CAAC;YAGH,MAAM,oBAAoB,YAAA,CAAa,OAAU,EAAA;YAEjD,IAAI,KAAK,aAAA,CAAc,YAAA,GAAe,kBACrC,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,uBAAA;YAAA,CACrB,CAAC;qBACQ,KAAK,aAAA,CAAc,YAAA,GAAe,kBAC5C,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,uBAAA;YAAA,CACrB,CAAC;;QAGJ,IAAI,QAAQ;YACX,IAAI,OAAO,MAAA,GAAS,KAAK,mBAAA,CACxB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,qBAAA;YAAA,CACrB,CAAC;YAEH,IAAI,OAAO,MAAA,GAAS,KAAK,mBAAA,CACxB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,qBAAA;YAAA,CACrB,CAAC;;QAIJ,IAAI,MAAM;YACT,IAAI,KAAK,MAAA,GAAS,KAAK,iBAAA,CACtB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,mBAAA;YAAA,CACrB,CAAC;YAEH,IAAI,KAAK,MAAA,GAAS,KAAK,iBAAA,CACtB,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;gBACjC,SAAS,0LAAA,CAAY,mBAAA;YAAA,CACrB,CAAC;mBAEO,KAAK,WAAA,CACf,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;YACjC,SAAS,0LAAA,CAAY,aAAA;QAAA,CACrB,CAAC;QAGH,wBAAwB,IAAI,OAAA,CAAQ;QAEpC,MAAM,MAAM,MAAM,aAAa;YAC9B,QAAQ,KAAK,gBAAA;YACb,QAAQ,UAAU,KAAK,aAAA;SACvB,CAAC;QAEF,MAAM,SAAS,KAAK,iBAAA,GAAoB,MAAM,UAAM,+LAAA,EAAiB,IAAI;QAEzE,IAAIA,QAAuB;QAE3B,IAAI,KAAK,wBAAA,CAAyB,WAAA,CACjC,CAAA,QAAQ,IAAI,SAAA,CACX,GACA,KAAK,wBAAA,CAAyB,gBAAA,CAC9B;QAGF,MAAM,qBAAqB,KAAK,WAAA,EAAa,qBAC1C,OAAO,KAAK,WAAA,CAAY,kBAAA,KAAuB,aAC9C,MAAM,KAAK,WAAA,CAAY,kBAAA,CAAmB,KAAK,EAAA,EAAI,IAAI,GACvD,KAAK,WAAA,CAAY,kBAAA,GAClB,KAAA;QACH,MAAM,qBAAqB,cACxB,KAAK,SAAA,CAAU,YAAY,GAC3B,qBACC,KAAK,SAAA,CAAU,mBAAmB,GAClC,KAAA;QAEJ,MAAMC,OAA2B;YAChC,WAAA,aAAA,GAAW,IAAI,MAAM;YACrB,WAAA,aAAA,GAAW,IAAI,MAAM;YACrB,MAAM,QAAQ;YACd,QAAQ,UAAU,KAAK,aAAA,IAAiB;YACjC;YACP,KAAK;YACL,SAAS;YACT,WAAW,gBACR,qKAAA,EAAQ,WAAW,MAAM,GACzB,KAAK,aAAA,CAAc,gBAAA,OAClB,qKAAA,EAAQ,KAAK,aAAA,CAAc,gBAAA,EAAkB,MAAM,GACnD;YACJ,QAAQ,KAAK,EAAA;YACb,cAAc;YACd,aAAa;YACb,UAAU;YACV,cAAc,gBAAgB,KAAK,SAAA,CAAU,WAAA,IAAe;YAC5D,qBACC,uBAAuB,KAAK,SAAA,CAAU,UAAA,IAAc;YACrD,WACC,cAAc,OAAO,YAAa,aAAa,gBAAgB;YAChE,cAAc,gBAAgB;YAC9B,gBAAgB,kBAAkB;YAClC,kBACC,qBAAqB,KAAA,IACjB,KAAK,SAAA,CAAU,OAAA,IAAW,OAC3B;YACJ,cAAc;YAEd,aAAa;SACb;QAED,IAAI,SAEH,CAAA,KAAK,QAAA,GAAW;QAGjB,IAAIC;QAEJ,IAAI,KAAK,OAAA,KAAY,uBAAuB,KAAK,kBAAA,EAAoB;YACpE,SAAS,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAmC;gBACrE,OAAO,iMAAA;gBACD;aACN,CAAC;YACF,UAAM,0LAAA,EAAU,KAAK,QAAQ,KAAK;mBACxB,KAAK,OAAA,KAAY,qBAAqB;YAIhD,MAAM,KAHc,IAAI,OAAA,CAAQ,UAAA,CAAW;gBAC1C,OAAO,iMAAA;YAAA,CACP,CAAC,QACwBC,gLAAAA,EAAY;YACtC,SAAS;gBACR,GAAG,IAAA;gBACH;aACA;YACD,UAAM,0LAAA,EAAU,KAAK,QAAQ,KAAK;cAElC,CAAA,SAAS,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAmC;YACrE,OAAO,iMAAA;YACD;SACN,CAAC;QAGH,OAAO,IAAI,IAAA,CAAK;YACf,GAAI,MAAA;YACC;YACL,UAAU,YAAY;YACtB,aAAa,OAAO,WAAA,OACjB,qLAAA,EAAc,OAAO,WAAA,CAAY,GACjC;SACH,CAAC;MAEH"}},
    {"offset": {"line": 1109, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/delete-all-expired-api-keys.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/delete-all-expired-api-keys.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\n\nexport function deleteAllExpiredApiKeysEndpoint({\n\tdeleteAllExpiredApiKeys,\n}: {\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): Promise<void>;\n}) {\n\treturn createAuthEndpoint(\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t},\n\t\tasync (ctx) => {\n\t\t\ttry {\n\t\t\t\tawait deleteAllExpiredApiKeys(ctx.context, true);\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\n\t\t\t\t\t\"[API KEY PLUGIN] Failed to delete expired API keys:\",\n\t\t\t\t\terror,\n\t\t\t\t);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn ctx.json({ success: true, error: null });\n\t\t},\n\t);\n}\n"],"names":[],"mappings":";;;;;;;AAGA,SAAgB,gCAAgC,EAC/C,uBAAA,EAAA,EAME;IACF,WAAO,yLAAA,EACN;QACC,QAAQ;IAAA,CACR,EACD,OAAO,QAAQ;QACd,IAAI;YACH,MAAM,wBAAwB,IAAI,OAAA,EAAS,KAAK;iBACxC,OAAO;YACf,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAClB,uDACA,MACA;YACD,OAAO,IAAI,IAAA,CAAK;gBACf,SAAS;gBACF;aACP,CAAC;;QAGH,OAAO,IAAI,IAAA,CAAK;YAAE,SAAS;YAAM,OAAO;SAAM,CAAC;MAEhD"}},
    {"offset": {"line": 1141, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/delete-api-key.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/delete-api-key.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport * as z from \"zod\";\nimport { APIError, sessionMiddleware } from \"../../../api\";\nimport { API_KEY_TABLE_NAME, ERROR_CODES } from \"..\";\nimport {\n\tdeleteApiKey as deleteApiKeyFromStorage,\n\tgetApiKeyById,\n} from \"../adapter\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey } from \"../types\";\nimport type { PredefinedApiKeyOptions } from \".\";\n\nconst deleteApiKeyBodySchema = z.object({\n\tkeyId: z.string().meta({\n\t\tdescription: \"The id of the Api Key\",\n\t}),\n});\n\nexport function deleteApiKey({\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): void;\n}) {\n\treturn createAuthEndpoint(\n\t\t\"/api-key/delete\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\tbody: deleteApiKeyBodySchema,\n\t\t\tuse: [sessionMiddleware],\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Delete an existing API key\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tkeyId: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The id of the API key to delete\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"keyId\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"API key deleted successfully\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the API key was successfully deleted\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"success\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst { keyId } = ctx.body;\n\t\t\tconst session = ctx.context.session;\n\t\t\tif (session.user.banned === true) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: ERROR_CODES.USER_BANNED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet apiKey: ApiKey | null = null;\n\n\t\t\tapiKey = await getApiKeyById(ctx, keyId, opts);\n\n\t\t\tif (!apiKey || apiKey.userId !== session.user.id) {\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\t\tawait deleteApiKeyFromStorage(ctx, apiKey, opts);\n\t\t\t\t\tawait ctx.context.adapter.delete<ApiKey>({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\tvalue: apiKey.id,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t} else if (opts.storage === \"database\") {\n\t\t\t\t\tawait ctx.context.adapter.delete<ApiKey>({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\tvalue: apiKey.id,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait deleteApiKeyFromStorage(ctx, apiKey, opts);\n\t\t\t\t}\n\t\t\t} catch (error: any) {\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t});\n\t\t\t}\n\t\t\tdeleteAllExpiredApiKeys(ctx.context);\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: true,\n\t\t\t});\n\t\t},\n\t);\n}\n"],"names":["deleteApiKey","apiKey: ApiKey | null","deleteApiKeyFromStorage","error: any"],"mappings":";;;;;;;;;;;;;;;;;;AAaA,MAAM,yBAAyB,EAAE,yJAAA,CAAO;IACvC,OAAO,EAAE,yJAAA,EAAQ,CAAC,IAAA,CAAK;QACtB,aAAa;IAAA,CACb,CAAC;AAAA,CACF,CAAC;AAEF,SAAgBA,eAAa,EAC5B,IAAA,EACA,MAAA,EACA,uBAAA,EAAA,EAQE;IACF,WAAO,yLAAA,EACN,mBACA;QACC,QAAQ;QACR,MAAM;QACN,KAAK;YAAC,0LAAA;SAAkB;QACxB,UAAU;YACT,SAAS;gBACR,aAAa;gBACb,aAAa;oBACZ,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,OAAO;wCACN,MAAM;wCACN,aAAa;qCACb;gCAAA,CACD;gCACD,UAAU;oCAAC;iCAAQ;6BACnB;wBAAA,CACD;oBAAA,CACD;gBAAA,CACD;gBACD,WAAW;oBACV,OAAO;wBACN,aAAa;wBACb,SAAS;4BACR,oBAAoB;gCACnB,QAAQ;oCACP,MAAM;oCACN,YAAY;wCACX,SAAS;4CACR,MAAM;4CACN,aACC;yCACD;oCAAA,CACD;oCACD,UAAU;wCAAC;qCAAU;iCACrB;4BAAA,CACD;wBAAA,CACD;qBACD;gBAAA,CACD;aACD;QAAA,CACD;KACD,EACD,OAAO,QAAQ;QACd,MAAM,EAAE,KAAA,EAAA,GAAU,IAAI,IAAA;QACtB,MAAM,UAAU,IAAI,OAAA,CAAQ,OAAA;QAC5B,IAAI,QAAQ,IAAA,CAAK,MAAA,KAAW,KAC3B,CAAA,MAAM,IAAI,8JAAA,CAAS,gBAAgB;YAClC,SAAS,0LAAA,CAAY,WAAA;QAAA,CACrB,CAAC;QAGH,IAAIC,SAAwB;QAE5B,SAAS,UAAM,8LAAA,EAAc,KAAK,OAAO,KAAK;QAE9C,IAAI,CAAC,UAAU,OAAO,MAAA,KAAW,QAAQ,IAAA,CAAK,EAAA,CAC7C,CAAA,MAAM,IAAI,8JAAA,CAAS,aAAa;YAC/B,SAAS,0LAAA,CAAY,aAAA;QAAA,CACrB,CAAC;QAGH,IAAI;YACH,IAAI,KAAK,OAAA,KAAY,uBAAuB,KAAK,kBAAA,EAAoB;gBACpE,UAAMC,6LAAAA,EAAwB,KAAK,QAAQ,KAAK;gBAChD,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAe;oBACxC,OAAO,iMAAA;oBACP,OAAO;wBACN;4BACC,OAAO;4BACP,OAAO,OAAO,EAAA;yBACd;qBACD;iBACD,CAAC;uBACQ,KAAK,OAAA,KAAY,WAC3B,CAAA,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAe;gBACxC,OAAO,iMAAA;gBACP,OAAO;oBACN;wBACC,OAAO;wBACP,OAAO,OAAO,EAAA;qBACd;iBACD;aACD,CAAC;iBAEF,UAAMA,6LAAAA,EAAwB,KAAK,QAAQ,KAAK;iBAEzCC,OAAY;YACpB,MAAM,IAAI,8JAAA,CAAS,yBAAyB;gBAC3C,SAAS,OAAO;YAAA,CAChB,CAAC;;QAEH,wBAAwB,IAAI,OAAA,CAAQ;QACpC,OAAO,IAAI,IAAA,CAAK;YACf,SAAS;QAAA,CACT,CAAC;MAEH"}},
    {"offset": {"line": 1265, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/get-api-key.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/get-api-key.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { sessionMiddleware } from \"../../../api\";\nimport { ERROR_CODES } from \"..\";\nimport { getApiKeyById, migrateDoubleStringifiedMetadata } from \"../adapter\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey } from \"../types\";\nimport type { PredefinedApiKeyOptions } from \".\";\n\nconst getApiKeyQuerySchema = z.object({\n\tid: z.string().meta({\n\t\tdescription: \"The id of the Api Key\",\n\t}),\n});\n\nexport function getApiKey({\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): void;\n}) {\n\treturn createAuthEndpoint(\n\t\t\"/api-key/get\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\tquery: getApiKeyQuerySchema,\n\t\t\tuse: [sessionMiddleware],\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Retrieve an existing API key by ID\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"API key retrieved successfully\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"ID\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The API Key prefix. Stored as plain text.\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The owner of the user id\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The amount to refill\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The last refill date\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Whether the key has rate limiting enabled\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Maximum amount of requests allowed within a window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The number of requests made within the rate limit time window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When last request occurred\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Expiry date of a key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"created at\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"updated at\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Permissions for the api key (stored as JSON string)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst { id } = ctx.query;\n\n\t\t\tconst session = ctx.context.session;\n\n\t\t\tlet apiKey: ApiKey | null = null;\n\n\t\t\tapiKey = await getApiKeyById(ctx, id, opts);\n\n\t\t\t// Verify ownership\n\t\t\tif (apiKey && apiKey.userId !== session.user.id) {\n\t\t\t\tapiKey = null;\n\t\t\t}\n\n\t\t\tif (!apiKey) {\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: ERROR_CODES.KEY_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdeleteAllExpiredApiKeys(ctx.context);\n\n\t\t\t// Migrate legacy double-stringified metadata if needed\n\t\t\tconst metadata = await migrateDoubleStringifiedMetadata(\n\t\t\t\tctx,\n\t\t\t\tapiKey,\n\t\t\t\topts,\n\t\t\t);\n\n\t\t\tconst { key: _key, ...returningApiKey } = apiKey;\n\n\t\t\treturn ctx.json({\n\t\t\t\t...returningApiKey,\n\t\t\t\tmetadata,\n\t\t\t\tpermissions: returningApiKey.permissions\n\t\t\t\t\t? safeJSONParse<{\n\t\t\t\t\t\t\t[key: string]: string[];\n\t\t\t\t\t\t}>(returningApiKey.permissions)\n\t\t\t\t\t: null,\n\t\t\t});\n\t\t},\n\t);\n}\n"],"names":["apiKey: ApiKey | null"],"mappings":"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"}},
    {"offset": {"line": 1453, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/list-api-keys.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/list-api-keys.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport { sessionMiddleware } from \"../../../api\";\nimport {\n\tbatchMigrateLegacyMetadata,\n\tlistApiKeys as listApiKeysFromStorage,\n\tparseDoubleStringifiedMetadata,\n} from \"../adapter\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { PredefinedApiKeyOptions } from \".\";\nexport function listApiKeys({\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): void;\n}) {\n\treturn createAuthEndpoint(\n\t\t\"/api-key/list\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\tuse: [sessionMiddleware],\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"List all API keys for the authenticated user\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"API keys retrieved successfully\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"ID\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the key\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"The API Key prefix. Stored as plain text.\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The owner of the user id\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The amount to refill\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The last refill date\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Whether the key has rate limiting enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Maximum amount of requests allowed within a window\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"The number of requests made within the rate limit time window\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When last request occurred\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Expiry date of a key\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"created at\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"updated at\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Permissions for the api key (stored as JSON string)\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst session = ctx.context.session;\n\t\t\tconst apiKeys = await listApiKeysFromStorage(ctx, session.user.id, opts);\n\n\t\t\tdeleteAllExpiredApiKeys(ctx.context);\n\n\t\t\t// Build response with parsed metadata (synchronous, no DB calls)\n\t\t\tconst returningApiKeys = apiKeys.map((apiKey) => {\n\t\t\t\tconst { key: _key, ...rest } = apiKey;\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\tmetadata: parseDoubleStringifiedMetadata(apiKey.metadata),\n\t\t\t\t\tpermissions: rest.permissions\n\t\t\t\t\t\t? safeJSONParse<{\n\t\t\t\t\t\t\t\t[key: string]: string[];\n\t\t\t\t\t\t\t}>(rest.permissions)\n\t\t\t\t\t\t: null,\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Batch migrate legacy metadata (parallel DB updates)\n\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\tbatchMigrateLegacyMetadata(ctx, apiKeys, opts),\n\t\t\t);\n\n\t\t\treturn ctx.json(returningApiKeys);\n\t\t},\n\t);\n}\n"],"names":["listApiKeys","listApiKeysFromStorage"],"mappings":";;;;;;;;;;;;;;;;AAWA,SAAgBA,cAAY,EAC3B,IAAA,EACA,MAAA,EACA,uBAAA,EAAA,EAQE;IACF,WAAO,yLAAA,EACN,iBACA;QACC,QAAQ;QACR,KAAK;YAAC,0LAAA;SAAkB;QACxB,UAAU;YACT,SAAS;gBACR,aAAa;gBACb,WAAW;oBACV,OAAO;wBACN,aAAa;wBACb,SAAS;4BACR,oBAAoB;gCACnB,QAAQ;oCACP,MAAM;oCACN,OAAO;wCACN,MAAM;wCACN,YAAY;4CACX,IAAI;gDACH,MAAM;gDACN,aAAa;6CACb;4CACD,MAAM;gDACL,MAAM;gDACN,UAAU;gDACV,aAAa;6CACb;4CACD,OAAO;gDACN,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;4CACD,QAAQ;gDACP,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;4CACD,QAAQ;gDACP,MAAM;gDACN,aAAa;6CACb;4CACD,gBAAgB;gDACf,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;4CACD,cAAc;gDACb,MAAM;gDACN,UAAU;gDACV,aAAa;6CACb;4CACD,cAAc;gDACb,MAAM;gDACN,QAAQ;gDACR,UAAU;gDACV,aAAa;6CACb;4CACD,SAAS;gDACR,MAAM;gDACN,aAAa;gDACb,SAAS;6CACT;4CACD,kBAAkB;gDACjB,MAAM;gDACN,aACC;6CACD;4CACD,qBAAqB;gDACpB,MAAM;gDACN,UAAU;gDACV,aAAa;6CACb;4CACD,cAAc;gDACb,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;4CACD,cAAc;gDACb,MAAM;gDACN,aACC;6CACD;4CACD,WAAW;gDACV,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;4CACD,aAAa;gDACZ,MAAM;gDACN,QAAQ;gDACR,UAAU;gDACV,aAAa;6CACb;4CACD,WAAW;gDACV,MAAM;gDACN,QAAQ;gDACR,UAAU;gDACV,aAAa;6CACb;4CACD,WAAW;gDACV,MAAM;gDACN,QAAQ;gDACR,aAAa;6CACb;4CACD,WAAW;gDACV,MAAM;gDACN,QAAQ;gDACR,aAAa;6CACb;4CACD,UAAU;gDACT,MAAM;gDACN,UAAU;gDACV,sBAAsB;gDACtB,aAAa;6CACb;4CACD,aAAa;gDACZ,MAAM;gDACN,UAAU;gDACV,aACC;6CACD;yCACD;wCACD,UAAU;4CACT;4CACA;4CACA;4CACA;4CACA;4CACA;4CACA;yCACA;qCACD;iCACD;4BAAA,CACD;wBAAA,CACD;qBACD;gBAAA,CACD;aACD;QAAA,CACD;KACD,EACD,OAAO,QAAQ;QACd,MAAM,UAAU,IAAI,OAAA,CAAQ,OAAA;QAC5B,MAAM,UAAU,UAAMC,4LAAAA,EAAuB,KAAK,QAAQ,IAAA,CAAK,EAAA,EAAI,KAAK;QAExE,wBAAwB,IAAI,OAAA,CAAQ;QAGpC,MAAM,mBAAmB,QAAQ,GAAA,CAAA,CAAK,WAAW;YAChD,MAAM,EAAE,KAAK,IAAA,EAAM,GAAG,MAAA,GAAS;YAC/B,OAAO;gBACN,GAAG,IAAA;gBACH,cAAU,+MAAA,EAA+B,OAAO,QAAA,CAAS;gBACzD,aAAa,KAAK,WAAA,OACf,qLAAA,EAEE,KAAK,WAAA,CAAY,GACnB;aACH;UACA;QAGF,MAAM,IAAI,OAAA,CAAQ,sBAAA,KACjB,2MAAA,EAA2B,KAAK,SAAS,KAAK,CAC9C;QAED,OAAO,IAAI,IAAA,CAAK,iBAAiB;MAElC"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/update-api-key.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/update-api-key.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { getSessionFromCtx } from \"../../../api\";\nimport { getDate } from \"../../../utils/date\";\nimport { API_KEY_TABLE_NAME, ERROR_CODES } from \"..\";\nimport {\n\tgetApiKeyById,\n\tmigrateDoubleStringifiedMetadata,\n\tsetApiKey,\n} from \"../adapter\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey } from \"../types\";\nimport type { PredefinedApiKeyOptions } from \".\";\n\nconst updateApiKeyBodySchema = z.object({\n\tkeyId: z.string().meta({\n\t\tdescription: \"The id of the Api Key\",\n\t}),\n\tuserId: z.coerce\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t'The id of the user which the api key belongs to. server-only. Eg: \"some-user-id\"',\n\t\t})\n\t\t.optional(),\n\tname: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"The name of the key\",\n\t\t})\n\t\t.optional(),\n\tenabled: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription: \"Whether the Api Key is enabled or not\",\n\t\t})\n\t\t.optional(),\n\tremaining: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"The number of remaining requests\",\n\t\t})\n\t\t.min(1)\n\t\t.optional(),\n\trefillAmount: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"The refill amount\",\n\t\t})\n\t\t.optional(),\n\trefillInterval: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"The refill interval\",\n\t\t})\n\t\t.optional(),\n\tmetadata: z.any().optional(),\n\texpiresIn: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription: \"Expiration time of the Api Key in seconds\",\n\t\t})\n\t\t.min(1)\n\t\t.optional()\n\t\t.nullable(),\n\trateLimitEnabled: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription: \"Whether the key has rate limiting enabled.\",\n\t\t})\n\t\t.optional(),\n\trateLimitTimeWindow: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"The duration in milliseconds where each request is counted. server-only. Eg: 1000\",\n\t\t})\n\t\t.optional(),\n\trateLimitMax: z\n\t\t.number()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100\",\n\t\t})\n\t\t.optional(),\n\tpermissions: z\n\t\t.record(z.string(), z.array(z.string()))\n\t\t.meta({\n\t\t\tdescription: \"Update the permissions on the API Key. server-only.\",\n\t\t})\n\t\t.optional()\n\t\t.nullable(),\n});\n\nexport function updateApiKey({\n\topts,\n\tschema,\n\tdeleteAllExpiredApiKeys,\n}: {\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n\tdeleteAllExpiredApiKeys(\n\t\tctx: AuthContext,\n\t\tbyPassLastCheckTime?: boolean | undefined,\n\t): void;\n}) {\n\treturn createAuthEndpoint(\n\t\t\"/api-key/update\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\tbody: updateApiKeyBodySchema,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Update an existing API key by ID\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"API key updated successfully\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"ID\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key.\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tprefix: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The API Key prefix. Stored as plain text.\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The owner of the user id\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillInterval: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trefillAmount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The amount to refill\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRefillAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The last refill date\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tenabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Sets if key is enabled or disabled\",\n\t\t\t\t\t\t\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitEnabled: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Whether the key has rate limiting enabled\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The duration in milliseconds\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trateLimitMax: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Maximum amount of requests allowed within a window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequestCount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"The number of requests made within the rate limit time window\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremaining: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"number\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remaining requests (every time api key is used this should updated and should be updated on refill as well)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tlastRequest: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When last request occurred\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\texpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Expiry date of a key\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"created at\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"updated at\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Extra metadata about the apiKey\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tpermissions: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Permissions for the api key (stored as JSON string)\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\"enabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"rateLimitEnabled\",\n\t\t\t\t\t\t\t\t\t\t\t\"requestCount\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst {\n\t\t\t\tkeyId,\n\t\t\t\texpiresIn,\n\t\t\t\tenabled,\n\t\t\t\tmetadata,\n\t\t\t\trefillAmount,\n\t\t\t\trefillInterval,\n\t\t\t\tremaining,\n\t\t\t\tname,\n\t\t\t\tpermissions,\n\t\t\t\trateLimitEnabled,\n\t\t\t\trateLimitTimeWindow,\n\t\t\t\trateLimitMax,\n\t\t\t} = ctx.body;\n\n\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\tconst authRequired = ctx.request || ctx.headers;\n\t\t\tconst user =\n\t\t\t\tauthRequired && !session\n\t\t\t\t\t? null\n\t\t\t\t\t: session?.user || { id: ctx.body.userId };\n\n\t\t\tif (!user?.id) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: ERROR_CODES.UNAUTHORIZED_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (session && ctx.body.userId && session?.user.id !== ctx.body.userId) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: ERROR_CODES.UNAUTHORIZED_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (authRequired) {\n\t\t\t\t// if this endpoint was being called from the client,\n\t\t\t\t// we must make sure they can't use server-only properties.\n\t\t\t\tif (\n\t\t\t\t\trefillAmount !== undefined ||\n\t\t\t\t\trefillInterval !== undefined ||\n\t\t\t\t\trateLimitMax !== undefined ||\n\t\t\t\t\trateLimitTimeWindow !== undefined ||\n\t\t\t\t\trateLimitEnabled !== undefined ||\n\t\t\t\t\tremaining !== undefined ||\n\t\t\t\t\tpermissions !== undefined\n\t\t\t\t) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.SERVER_ONLY_PROPERTY,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet apiKey: ApiKey | null = null;\n\n\t\t\tapiKey = await getApiKeyById(ctx, keyId, opts);\n\n\t\t\t// Verify ownership\n\t\t\tif (apiKey && apiKey.userId !== user.id) {\n\t\t\t\tapiKey = null;\n\t\t\t}\n\n\t\t\tif (!apiKey) {\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", { message: ERROR_CODES.KEY_NOT_FOUND });\n\t\t\t}\n\n\t\t\tconst newValues: Partial<ApiKey> = {};\n\n\t\t\tif (name !== undefined) {\n\t\t\t\tif (name.length < opts.minimumNameLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_NAME_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t} else if (name.length > opts.maximumNameLength) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_NAME_LENGTH,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tnewValues.name = name;\n\t\t\t}\n\n\t\t\tif (enabled !== undefined) {\n\t\t\t\tnewValues.enabled = enabled;\n\t\t\t}\n\t\t\tif (expiresIn !== undefined) {\n\t\t\t\tif (opts.keyExpiration.disableCustomExpiresTime === true) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.KEY_DISABLED_EXPIRATION,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (expiresIn !== null) {\n\t\t\t\t\t// if expires is not null, check if it's under the valid range\n\t\t\t\t\t// if it IS null, this means the user wants to disable expiration time on the key\n\t\t\t\t\tconst expiresIn_in_days = expiresIn / (60 * 60 * 24);\n\n\t\t\t\t\tif (expiresIn_in_days < opts.keyExpiration.minExpiresIn) {\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\t\tmessage: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (expiresIn_in_days > opts.keyExpiration.maxExpiresIn) {\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\t\tmessage: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewValues.expiresAt = expiresIn ? getDate(expiresIn, \"sec\") : null;\n\t\t\t}\n\n\t\t\tif (metadata !== undefined && opts.enableMetadata === true) {\n\t\t\t\tif (typeof metadata !== \"object\") {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_METADATA_TYPE,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// The adapter will automatically apply the schema transform to stringify\n\t\t\t\tnewValues.metadata = metadata;\n\t\t\t}\n\t\t\tif (remaining !== undefined) {\n\t\t\t\tnewValues.remaining = remaining;\n\t\t\t}\n\t\t\tif (refillAmount !== undefined || refillInterval !== undefined) {\n\t\t\t\tif (refillAmount !== undefined && refillInterval === undefined) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED,\n\t\t\t\t\t});\n\t\t\t\t} else if (refillInterval !== undefined && refillAmount === undefined) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tnewValues.refillAmount = refillAmount;\n\t\t\t\tnewValues.refillInterval = refillInterval;\n\t\t\t}\n\n\t\t\tif (rateLimitEnabled !== undefined) {\n\t\t\t\tnewValues.rateLimitEnabled = rateLimitEnabled;\n\t\t\t}\n\t\t\tif (rateLimitTimeWindow !== undefined) {\n\t\t\t\tnewValues.rateLimitTimeWindow = rateLimitTimeWindow;\n\t\t\t}\n\t\t\tif (rateLimitMax !== undefined) {\n\t\t\t\tnewValues.rateLimitMax = rateLimitMax;\n\t\t\t}\n\n\t\t\tif (permissions !== undefined) {\n\t\t\t\t//@ts-expect-error - we need this to be a string to save into DB.\n\t\t\t\tnewValues.permissions = JSON.stringify(permissions);\n\t\t\t}\n\n\t\t\tif (Object.keys(newValues).length === 0) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: ERROR_CODES.NO_VALUES_TO_UPDATE,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet newApiKey: ApiKey = apiKey;\n\t\t\ttry {\n\t\t\t\tif (opts.storage === \"secondary-storage\" && opts.fallbackToDatabase) {\n\t\t\t\t\tconst dbUpdated = await ctx.context.adapter.update<ApiKey>({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\tvalue: apiKey.id,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tupdate: newValues,\n\t\t\t\t\t});\n\t\t\t\t\tif (dbUpdated) {\n\t\t\t\t\t\tawait setApiKey(ctx, dbUpdated, opts);\n\t\t\t\t\t\tnewApiKey = dbUpdated;\n\t\t\t\t\t}\n\t\t\t\t} else if (opts.storage === \"database\") {\n\t\t\t\t\tconst result = await ctx.context.adapter.update<ApiKey>({\n\t\t\t\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\tvalue: apiKey.id,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tupdate: newValues,\n\t\t\t\t\t});\n\t\t\t\t\tif (result) newApiKey = result;\n\t\t\t\t} else {\n\t\t\t\t\tconst updated: ApiKey = {\n\t\t\t\t\t\t...apiKey,\n\t\t\t\t\t\t...newValues,\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t};\n\t\t\t\t\tawait setApiKey(ctx, updated, opts);\n\t\t\t\t\tnewApiKey = updated;\n\t\t\t\t}\n\t\t\t} catch (error: any) {\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdeleteAllExpiredApiKeys(ctx.context);\n\n\t\t\t// Migrate legacy double-stringified metadata if needed\n\t\t\tconst migratedMetadata = await migrateDoubleStringifiedMetadata(\n\t\t\t\tctx,\n\t\t\t\tnewApiKey,\n\t\t\t\topts,\n\t\t\t);\n\n\t\t\tconst { key: _key, ...returningApiKey } = newApiKey;\n\n\t\t\treturn ctx.json({\n\t\t\t\t...returningApiKey,\n\t\t\t\tmetadata: migratedMetadata,\n\t\t\t\tpermissions: returningApiKey.permissions\n\t\t\t\t\t? safeJSONParse<{\n\t\t\t\t\t\t\t[key: string]: string[];\n\t\t\t\t\t\t}>(returningApiKey.permissions)\n\t\t\t\t\t: null,\n\t\t\t});\n\t\t},\n\t);\n}\n"],"names":["apiKey: ApiKey | null","newValues: Partial<ApiKey>","newApiKey: ApiKey","updated: ApiKey","error: any"],"mappings":"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"}},
    {"offset": {"line": 1958, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/routes/index.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/routes/index.ts"],"sourcesContent":["import type { AuthContext, Awaitable } from \"@better-auth/core\";\nimport { API_KEY_TABLE_NAME } from \"..\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey, ApiKeyOptions } from \"../types\";\nimport { createApiKey } from \"./create-api-key\";\nimport { deleteAllExpiredApiKeysEndpoint } from \"./delete-all-expired-api-keys\";\nimport { deleteApiKey } from \"./delete-api-key\";\nimport { getApiKey } from \"./get-api-key\";\nimport { listApiKeys } from \"./list-api-keys\";\nimport { updateApiKey } from \"./update-api-key\";\nimport { verifyApiKey } from \"./verify-api-key\";\n\nexport type PredefinedApiKeyOptions = ApiKeyOptions &\n\tRequired<\n\t\tPick<\n\t\t\tApiKeyOptions,\n\t\t\t| \"apiKeyHeaders\"\n\t\t\t| \"defaultKeyLength\"\n\t\t\t| \"keyExpiration\"\n\t\t\t| \"rateLimit\"\n\t\t\t| \"maximumPrefixLength\"\n\t\t\t| \"minimumPrefixLength\"\n\t\t\t| \"maximumNameLength\"\n\t\t\t| \"disableKeyHashing\"\n\t\t\t| \"minimumNameLength\"\n\t\t\t| \"requireName\"\n\t\t\t| \"enableMetadata\"\n\t\t\t| \"enableSessionForAPIKeys\"\n\t\t\t| \"startingCharactersConfig\"\n\t\t\t| \"storage\"\n\t\t\t| \"fallbackToDatabase\"\n\t\t\t| \"deferUpdates\"\n\t\t>\n\t> & {\n\t\tkeyExpiration: Required<ApiKeyOptions[\"keyExpiration\"]>;\n\t\tstartingCharactersConfig: Required<\n\t\t\tApiKeyOptions[\"startingCharactersConfig\"]\n\t\t>;\n\t};\n\nlet lastChecked: Date | null = null;\n\nexport async function deleteAllExpiredApiKeys(\n\tctx: AuthContext,\n\tbyPassLastCheckTime = false,\n): Promise<void> {\n\tif (lastChecked && !byPassLastCheckTime) {\n\t\tconst now = new Date();\n\t\tconst diff = now.getTime() - lastChecked.getTime();\n\t\tif (diff < 10000) {\n\t\t\treturn;\n\t\t}\n\t}\n\tlastChecked = new Date();\n\tawait ctx.adapter\n\t\t.deleteMany({\n\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"expiresAt\" satisfies keyof ApiKey,\n\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\tvalue: new Date(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\toperator: \"ne\",\n\t\t\t\t\tvalue: null,\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\t.catch((error) => {\n\t\t\tctx.logger.error(`Failed to delete expired API keys:`, error);\n\t\t});\n}\n\nexport function createApiKeyRoutes({\n\tkeyGenerator,\n\topts,\n\tschema,\n}: {\n\tkeyGenerator: (options: {\n\t\tlength: number;\n\t\tprefix: string | undefined;\n\t}) => Awaitable<string>;\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n}) {\n\treturn {\n\t\tcreateApiKey: createApiKey({\n\t\t\tkeyGenerator,\n\t\t\topts,\n\t\t\tschema,\n\t\t\tdeleteAllExpiredApiKeys,\n\t\t}),\n\t\tverifyApiKey: verifyApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tgetApiKey: getApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tupdateApiKey: updateApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tdeleteApiKey: deleteApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tlistApiKeys: listApiKeys({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tdeleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({\n\t\t\tdeleteAllExpiredApiKeys,\n\t\t}),\n\t};\n}\n"],"names":["lastChecked: Date | null"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAwCA,IAAIA,cAA2B;AAE/B,eAAsB,wBACrB,GAAA,EACA,sBAAsB,KAAA,EACN;IAChB,IAAI,eAAe,CAAC,qBAGnB;4BAFY,IAAI,MAAM,CACL,OAAA,EAAS,GAAG,YAAY,OAAA,EAAS,GACvC,IACV,CAAA;;IAGF,cAAA,aAAA,GAAc,IAAI,MAAM;IACxB,MAAM,IAAI,OAAA,CACR,UAAA,CAAW;QACX,OAAO,iMAAA;QACP,OAAO;YACN;gBACC,OAAO;gBACP,UAAU;gBACV,OAAA,aAAA,GAAO,IAAI,MAAM;aACjB;YACD;gBACC,OAAO;gBACP,UAAU;gBACV,OAAO;aACP;SACD;KACD,CAAC,CACD,KAAA,CAAA,CAAO,UAAU;QACjB,IAAI,MAAA,CAAO,KAAA,CAAM,CAAA,kCAAA,CAAA,EAAsC,MAAM;MAC5D;;AAGJ,SAAgB,mBAAmB,EAClC,YAAA,EACA,IAAA,EACA,MAAA,EAAA,EAQE;IACF,OAAO;QACN,kBAAc,oNAAA,EAAa;YAC1B;YACA;YACA;YACA;SACA,CAAC;QACF,kBAAc,oNAAA,EAAa;YAAE;YAAM;YAAQ;SAAyB,CAAC;QACrE,eAAW,8MAAA,EAAU;YAAE;YAAM;YAAQ;SAAyB,CAAC;QAC/D,kBAAc,oNAAA,EAAa;YAAE;YAAM;YAAQ;SAAyB,CAAC;QACrE,kBAAc,oNAAA,EAAa;YAAE;YAAM;YAAQ;SAAyB,CAAC;QACrE,iBAAa,kNAAA,EAAY;YAAE;YAAM;YAAQ;SAAyB,CAAC;QACnE,6BAAyB,0PAAA,EAAgC;YACxD;QAAA,CACA,CAAC;KACF"}},
    {"offset": {"line": 2049, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/schema.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/schema.ts"],"sourcesContent":["import type { BetterAuthPluginDBSchema } from \"@better-auth/core/db\";\nimport { parseJSON } from \"../../client/parser\";\n\nexport const apiKeySchema = ({\n\ttimeWindow,\n\trateLimitMax,\n}: {\n\ttimeWindow: number;\n\trateLimitMax: number;\n}) =>\n\t({\n\t\tapikey: {\n\t\t\tfields: {\n\t\t\t\t/**\n\t\t\t\t * The name of the key.\n\t\t\t\t */\n\t\t\t\tname: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Shows the first few characters of the API key\n\t\t\t\t * This allows you to show those few characters in the UI to make it easier for users to identify the API key.\n\t\t\t\t */\n\t\t\t\tstart: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The prefix of the key.\n\t\t\t\t */\n\t\t\t\tprefix: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The hashed key value.\n\t\t\t\t */\n\t\t\t\tkey: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tindex: true,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The user id of the user who created the key.\n\t\t\t\t */\n\t\t\t\tuserId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\treferences: { model: \"user\", field: \"id\", onDelete: \"cascade\" },\n\t\t\t\t\trequired: true,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tindex: true,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The interval to refill the key in milliseconds.\n\t\t\t\t */\n\t\t\t\trefillInterval: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The amount to refill the remaining count of the key.\n\t\t\t\t */\n\t\t\t\trefillAmount: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The date and time when the key was last refilled.\n\t\t\t\t */\n\t\t\t\tlastRefillAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Whether the key is enabled.\n\t\t\t\t */\n\t\t\t\tenabled: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tdefaultValue: true,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Whether the key has rate limiting enabled.\n\t\t\t\t */\n\t\t\t\trateLimitEnabled: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tdefaultValue: true,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The time window in milliseconds for the rate limit.\n\t\t\t\t */\n\t\t\t\trateLimitTimeWindow: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tdefaultValue: timeWindow,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The maximum number of requests allowed within the `rateLimitTimeWindow`.\n\t\t\t\t */\n\t\t\t\trateLimitMax: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tdefaultValue: rateLimitMax,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The number of requests made within the rate limit time window\n\t\t\t\t */\n\t\t\t\trequestCount: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t\tdefaultValue: 0,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The remaining number of requests before the key is revoked.\n\t\t\t\t *\n\t\t\t\t * If this is null, then the key is not revoked.\n\t\t\t\t *\n\t\t\t\t * If `refillInterval` & `refillAmount` are provided, than this will refill accordingly.\n\t\t\t\t */\n\t\t\t\tremaining: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The date and time of the last request made to the key.\n\t\t\t\t */\n\t\t\t\tlastRequest: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The date and time when the key will expire.\n\t\t\t\t */\n\t\t\t\texpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The date and time when the key was created.\n\t\t\t\t */\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The date and time when the key was last updated.\n\t\t\t\t */\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * The permissions of the key.\n\t\t\t\t */\n\t\t\t\tpermissions: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Any additional metadata you want to store with the key.\n\t\t\t\t */\n\t\t\t\tmetadata: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tinput: true,\n\t\t\t\t\ttransform: {\n\t\t\t\t\t\tinput(value) {\n\t\t\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t\t\t},\n\t\t\t\t\t\toutput(value) {\n\t\t\t\t\t\t\tif (!value) return null;\n\t\t\t\t\t\t\treturn parseJSON<any>(value as string);\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}) satisfies BetterAuthPluginDBSchema;\n"],"names":[],"mappings":";;;;;;;AAGA,MAAa,eAAA,CAAgB,EAC5B,UAAA,EACA,YAAA,EAAA,GAAA,CAKC;QACA,QAAQ;YACP,QAAQ;gBAIP,MAAM;oBACL,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAKD,OAAO;oBACN,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,QAAQ;oBACP,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,KAAK;oBACJ,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,OAAO;iBACP;gBAID,QAAQ;oBACP,MAAM;oBACN,YAAY;wBAAE,OAAO;wBAAQ,OAAO;wBAAM,UAAU;qBAAW;oBAC/D,UAAU;oBACV,OAAO;oBACP,OAAO;iBACP;gBAID,gBAAgB;oBACf,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,cAAc;oBACb,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,cAAc;oBACb,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,SAAS;oBACR,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,cAAc;iBACd;gBAID,kBAAkB;oBACjB,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,cAAc;iBACd;gBAID,qBAAqB;oBACpB,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,cAAc;iBACd;gBAID,cAAc;oBACb,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,cAAc;iBACd;gBAID,cAAc;oBACb,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,cAAc;iBACd;gBAQD,WAAW;oBACV,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,aAAa;oBACZ,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,WAAW;oBACV,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,WAAW;oBACV,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,WAAW;oBACV,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,aAAa;oBACZ,MAAM;oBACN,UAAU;oBACV,OAAO;iBACP;gBAID,UAAU;oBACT,MAAM;oBACN,UAAU;oBACV,OAAO;oBACP,WAAW;wBACV,OAAM,KAAA,EAAO;4BACZ,OAAO,KAAK,SAAA,CAAU,MAAM;;wBAE7B,QAAO,KAAA,EAAO;4BACb,IAAI,CAAC,MAAO,CAAA,OAAO;4BACnB,WAAO,0KAAA,EAAe,MAAgB;;qBAEvC;iBACD;aACD;QAAA,CACD;IAAA,CACD"}},
    {"offset": {"line": 2189, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/plugins/api-key/index.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/plugins/api-key/index.ts"],"sourcesContent":["import type { BetterAuthPlugin } from \"@better-auth/core\";\nimport { createAuthMiddleware } from \"@better-auth/core/api\";\nimport { defineErrorCodes } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { APIError } from \"../../api\";\nimport { generateRandomString } from \"../../crypto/random\";\nimport { mergeSchema } from \"../../db\";\nimport { getDate } from \"../../utils/date\";\nimport { getIp } from \"../../utils/get-request-ip\";\nimport { createApiKeyRoutes, deleteAllExpiredApiKeys } from \"./routes\";\nimport { validateApiKey } from \"./routes/verify-api-key\";\nimport { apiKeySchema } from \"./schema\";\nimport type { ApiKeyOptions } from \"./types\";\n\nexport const defaultKeyHasher = async (key: string) => {\n\tconst hash = await createHash(\"SHA-256\").digest(\n\t\tnew TextEncoder().encode(key),\n\t);\n\tconst hashed = base64Url.encode(new Uint8Array(hash), {\n\t\tpadding: false,\n\t});\n\treturn hashed;\n};\n\nexport const ERROR_CODES = defineErrorCodes({\n\tINVALID_METADATA_TYPE: \"metadata must be an object or undefined\",\n\tREFILL_AMOUNT_AND_INTERVAL_REQUIRED:\n\t\t\"refillAmount is required when refillInterval is provided\",\n\tREFILL_INTERVAL_AND_AMOUNT_REQUIRED:\n\t\t\"refillInterval is required when refillAmount is provided\",\n\tUSER_BANNED: \"User is banned\",\n\tUNAUTHORIZED_SESSION: \"Unauthorized or invalid session\",\n\tKEY_NOT_FOUND: \"API Key not found\",\n\tKEY_DISABLED: \"API Key is disabled\",\n\tKEY_EXPIRED: \"API Key has expired\",\n\tUSAGE_EXCEEDED: \"API Key has reached its usage limit\",\n\tKEY_NOT_RECOVERABLE: \"API Key is not recoverable\",\n\tEXPIRES_IN_IS_TOO_SMALL:\n\t\t\"The expiresIn is smaller than the predefined minimum value.\",\n\tEXPIRES_IN_IS_TOO_LARGE:\n\t\t\"The expiresIn is larger than the predefined maximum value.\",\n\tINVALID_REMAINING: \"The remaining count is either too large or too small.\",\n\tINVALID_PREFIX_LENGTH: \"The prefix length is either too large or too small.\",\n\tINVALID_NAME_LENGTH: \"The name length is either too large or too small.\",\n\tMETADATA_DISABLED: \"Metadata is disabled.\",\n\tRATE_LIMIT_EXCEEDED: \"Rate limit exceeded.\",\n\tNO_VALUES_TO_UPDATE: \"No values to update.\",\n\tKEY_DISABLED_EXPIRATION: \"Custom key expiration values are disabled.\",\n\tINVALID_API_KEY: \"Invalid API key.\",\n\tINVALID_USER_ID_FROM_API_KEY: \"The user id from the API key is invalid.\",\n\tINVALID_API_KEY_GETTER_RETURN_TYPE:\n\t\t\"API Key getter returned an invalid key type. Expected string.\",\n\tSERVER_ONLY_PROPERTY:\n\t\t\"The property you're trying to set can only be set from the server auth instance only.\",\n\tFAILED_TO_UPDATE_API_KEY: \"Failed to update API key\",\n\tNAME_REQUIRED: \"API Key name is required.\",\n});\n\nexport const API_KEY_TABLE_NAME = \"apikey\";\n\nexport const apiKey = (options?: ApiKeyOptions | undefined) => {\n\tconst opts = {\n\t\t...options,\n\t\tapiKeyHeaders: options?.apiKeyHeaders ?? \"x-api-key\",\n\t\tdefaultKeyLength: options?.defaultKeyLength || 64,\n\t\tmaximumPrefixLength: options?.maximumPrefixLength ?? 32,\n\t\tminimumPrefixLength: options?.minimumPrefixLength ?? 1,\n\t\tmaximumNameLength: options?.maximumNameLength ?? 32,\n\t\tminimumNameLength: options?.minimumNameLength ?? 1,\n\t\tenableMetadata: options?.enableMetadata ?? false,\n\t\tdisableKeyHashing: options?.disableKeyHashing ?? false,\n\t\trequireName: options?.requireName ?? false,\n\t\tstorage: options?.storage ?? \"database\",\n\t\trateLimit: {\n\t\t\tenabled:\n\t\t\t\toptions?.rateLimit?.enabled === undefined\n\t\t\t\t\t? true\n\t\t\t\t\t: options?.rateLimit?.enabled,\n\t\t\ttimeWindow: options?.rateLimit?.timeWindow ?? 1000 * 60 * 60 * 24,\n\t\t\tmaxRequests: options?.rateLimit?.maxRequests ?? 10,\n\t\t},\n\t\tkeyExpiration: {\n\t\t\tdefaultExpiresIn: options?.keyExpiration?.defaultExpiresIn ?? null,\n\t\t\tdisableCustomExpiresTime:\n\t\t\t\toptions?.keyExpiration?.disableCustomExpiresTime ?? false,\n\t\t\tmaxExpiresIn: options?.keyExpiration?.maxExpiresIn ?? 365,\n\t\t\tminExpiresIn: options?.keyExpiration?.minExpiresIn ?? 1,\n\t\t},\n\t\tstartingCharactersConfig: {\n\t\t\tshouldStore: options?.startingCharactersConfig?.shouldStore ?? true,\n\t\t\tcharactersLength:\n\t\t\t\toptions?.startingCharactersConfig?.charactersLength ?? 6,\n\t\t},\n\t\tenableSessionForAPIKeys: options?.enableSessionForAPIKeys ?? false,\n\t\tfallbackToDatabase: options?.fallbackToDatabase ?? false,\n\t\tcustomStorage: options?.customStorage,\n\t\tdeferUpdates: options?.deferUpdates ?? false,\n\t} satisfies ApiKeyOptions;\n\n\tconst schema = mergeSchema(\n\t\tapiKeySchema({\n\t\t\trateLimitMax: opts.rateLimit.maxRequests,\n\t\t\ttimeWindow: opts.rateLimit.timeWindow,\n\t\t}),\n\t\topts.schema,\n\t);\n\n\tconst getter =\n\t\topts.customAPIKeyGetter ||\n\t\t((ctx) => {\n\t\t\tif (Array.isArray(opts.apiKeyHeaders)) {\n\t\t\t\tfor (const header of opts.apiKeyHeaders) {\n\t\t\t\t\tconst value = ctx.headers?.get(header);\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn ctx.headers?.get(opts.apiKeyHeaders);\n\t\t\t}\n\t\t});\n\n\tconst keyGenerator =\n\t\topts.customKeyGenerator ||\n\t\t(async (options: { length: number; prefix: string | undefined }) => {\n\t\t\tconst key = generateRandomString(options.length, \"a-z\", \"A-Z\");\n\t\t\treturn `${options.prefix || \"\"}${key}`;\n\t\t});\n\n\tconst routes = createApiKeyRoutes({ keyGenerator, opts, schema });\n\n\treturn {\n\t\tid: \"api-key\",\n\t\t$ERROR_CODES: ERROR_CODES,\n\t\thooks: {\n\t\t\tbefore: [\n\t\t\t\t{\n\t\t\t\t\tmatcher: (ctx) => !!getter(ctx) && opts.enableSessionForAPIKeys,\n\t\t\t\t\thandler: createAuthMiddleware(async (ctx) => {\n\t\t\t\t\t\tconst key = getter(ctx)!;\n\n\t\t\t\t\t\tif (typeof key !== \"string\") {\n\t\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY_GETTER_RETURN_TYPE,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (key.length < opts.defaultKeyLength) {\n\t\t\t\t\t\t\t// if the key is shorter than the default key length, than we know the key is invalid.\n\t\t\t\t\t\t\t// we can't check if the key is exactly equal to the default key length, because\n\t\t\t\t\t\t\t// a prefix may be added to the key.\n\t\t\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opts.customAPIKeyValidator) {\n\t\t\t\t\t\t\tconst isValid = await opts.customAPIKeyValidator({ ctx, key });\n\t\t\t\t\t\t\tif (!isValid) {\n\t\t\t\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_API_KEY,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst hashed = opts.disableKeyHashing\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: await defaultKeyHasher(key);\n\n\t\t\t\t\t\tconst apiKey = await validateApiKey({\n\t\t\t\t\t\t\thashedKey: hashed,\n\t\t\t\t\t\t\tctx,\n\t\t\t\t\t\t\topts,\n\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst cleanupTask = deleteAllExpiredApiKeys(ctx.context).catch(\n\t\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\t\tctx.context.logger.error(\n\t\t\t\t\t\t\t\t\t\"Failed to delete expired API keys:\",\n\t\t\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (opts.deferUpdates) {\n\t\t\t\t\t\t\tctx.context.runInBackground(cleanupTask);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst user = await ctx.context.internalAdapter.findUserById(\n\t\t\t\t\t\t\tapiKey.userId,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!user) {\n\t\t\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\t\t\tmessage: ERROR_CODES.INVALID_USER_ID_FROM_API_KEY,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\tid: apiKey.id,\n\t\t\t\t\t\t\t\ttoken: key,\n\t\t\t\t\t\t\t\tuserId: apiKey.userId,\n\t\t\t\t\t\t\t\tuserAgent: ctx.request?.headers.get(\"user-agent\") ?? null,\n\t\t\t\t\t\t\t\tipAddress: ctx.request\n\t\t\t\t\t\t\t\t\t? getIp(ctx.request, ctx.context.options)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t\t\texpiresAt:\n\t\t\t\t\t\t\t\t\tapiKey.expiresAt ||\n\t\t\t\t\t\t\t\t\tgetDate(\n\t\t\t\t\t\t\t\t\t\tctx.context.options.session?.expiresIn || 60 * 60 * 24 * 7, // 7 days\n\t\t\t\t\t\t\t\t\t\t\"ms\",\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Always set the session context for API key authentication\n\t\t\t\t\t\tctx.context.session = session;\n\n\t\t\t\t\t\tif (ctx.path === \"/get-session\") {\n\t\t\t\t\t\t\treturn session;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcontext: ctx,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\tendpoints: {\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * POST `/api-key/create`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.createApiKey`\n\t\t\t *\n\t\t\t * **client:**\n\t\t\t * `authClient.apiKey.create`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-create)\n\t\t\t */\n\t\t\tcreateApiKey: routes.createApiKey,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * POST `/api-key/verify`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.verifyApiKey`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-verify)\n\t\t\t */\n\t\t\tverifyApiKey: routes.verifyApiKey,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * GET `/api-key/get`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.getApiKey`\n\t\t\t *\n\t\t\t * **client:**\n\t\t\t * `authClient.apiKey.get`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-get)\n\t\t\t */\n\t\t\tgetApiKey: routes.getApiKey,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * POST `/api-key/update`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.updateApiKey`\n\t\t\t *\n\t\t\t * **client:**\n\t\t\t * `authClient.apiKey.update`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-update)\n\t\t\t */\n\t\t\tupdateApiKey: routes.updateApiKey,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * POST `/api-key/delete`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.deleteApiKey`\n\t\t\t *\n\t\t\t * **client:**\n\t\t\t * `authClient.apiKey.delete`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-delete)\n\t\t\t */\n\t\t\tdeleteApiKey: routes.deleteApiKey,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * GET `/api-key/list`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.listApiKeys`\n\t\t\t *\n\t\t\t * **client:**\n\t\t\t * `authClient.apiKey.list`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-list)\n\t\t\t */\n\t\t\tlistApiKeys: routes.listApiKeys,\n\t\t\t/**\n\t\t\t * ### Endpoint\n\t\t\t *\n\t\t\t * POST `/api-key/delete-all-expired-api-keys`\n\t\t\t *\n\t\t\t * ### API Methods\n\t\t\t *\n\t\t\t * **server:**\n\t\t\t * `auth.api.deleteAllExpiredApiKeys`\n\t\t\t *\n\t\t\t * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/api-key#api-method-api-key-delete-all-expired-api-keys)\n\t\t\t */\n\t\t\tdeleteAllExpiredApiKeys: routes.deleteAllExpiredApiKeys,\n\t\t},\n\t\tschema,\n\t\toptions,\n\t} satisfies BetterAuthPlugin;\n};\n\nexport type * from \"./types\";\n"],"names":["options","apiKey"],"mappings":"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"}}]
}