{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/crypto/random.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/crypto/random.ts"],"sourcesContent":["import { createRandomStringGenerator } from \"@better-auth/utils/random\";\nexport const generateRandomString = createRandomStringGenerator(\n\t\"a-z\",\n\t\"0-9\",\n\t\"A-Z\",\n\t\"-_\",\n);\n"],"names":[],"mappings":";;;;;;;AACA,MAAa,2BAAuB,6LAAA,EACnC,OACA,OACA,OACA,KACA"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/crypto/buffer.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/crypto/buffer.ts"],"sourcesContent":["/**\n * Compare two buffers in constant time.\n */\nexport function constantTimeEqual(\n\ta: ArrayBuffer | Uint8Array | string,\n\tb: ArrayBuffer | Uint8Array | string,\n): boolean {\n\tif (typeof a === \"string\") {\n\t\ta = new TextEncoder().encode(a);\n\t}\n\tif (typeof b === \"string\") {\n\t\tb = new TextEncoder().encode(b);\n\t}\n\tconst aBuffer = new Uint8Array(a);\n\tconst bBuffer = new Uint8Array(b);\n\tlet c = aBuffer.length ^ bBuffer.length;\n\tconst length = Math.max(aBuffer.length, bBuffer.length);\n\tfor (let i = 0; i < length; i++) {\n\t\tc |=\n\t\t\t(i < aBuffer.length ? aBuffer[i]! : 0) ^\n\t\t\t(i < bBuffer.length ? bBuffer[i]! : 0);\n\t}\n\treturn c === 0;\n}\n"],"names":[],"mappings":";;;;;;;GAGA,SAAgB,kBACf,CAAA,EACA,CAAA,EACU;IACV,IAAI,OAAO,MAAM,SAChB,CAAA,IAAI,IAAI,aAAa,CAAC,MAAA,CAAO,EAAE;IAEhC,IAAI,OAAO,MAAM,SAChB,CAAA,IAAI,IAAI,aAAa,CAAC,MAAA,CAAO,EAAE;IAEhC,MAAM,UAAU,IAAI,WAAW,EAAE;IACjC,MAAM,UAAU,IAAI,WAAW,EAAE;IACjC,IAAI,IAAI,QAAQ,MAAA,GAAS,QAAQ,MAAA;IACjC,MAAM,SAAS,KAAK,GAAA,CAAI,QAAQ,MAAA,EAAQ,QAAQ,MAAA,CAAO;IACvD,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC3B,KAAA,CACE,IAAI,QAAQ,MAAA,GAAS,OAAA,CAAQ,EAAA,GAAM,CAAA,IAAA,CACnC,IAAI,QAAQ,MAAA,GAAS,OAAA,CAAQ,EAAA,GAAM,CAAA;IAEtC,OAAO,MAAM"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/crypto/jwt.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/crypto/jwt.ts"],"sourcesContent":["import { hkdf } from \"@noble/hashes/hkdf.js\";\nimport { sha256 } from \"@noble/hashes/sha2.js\";\nimport {\n\tbase64url,\n\tcalculateJwkThumbprint,\n\tEncryptJWT,\n\tjwtDecrypt,\n\tjwtVerify,\n\tSignJWT,\n} from \"jose\";\n\nexport async function signJWT(\n\tpayload: any,\n\tsecret: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst jwt = await new SignJWT(payload)\n\t\t.setProtectedHeader({ alg: \"HS256\" })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)\n\t\t.sign(new TextEncoder().encode(secret));\n\n\treturn jwt;\n}\n\nexport async function verifyJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n): Promise<T | null> {\n\ttry {\n\t\tconst verified = await jwtVerify(token, new TextEncoder().encode(secret));\n\t\treturn verified.payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\n// \"BetterAuth.js Generated Encryption Key\"\nconst info: Uint8Array = new Uint8Array([\n\t66, 101, 116, 116, 101, 114, 65, 117, 116, 104, 46, 106, 115, 32, 71, 101,\n\t110, 101, 114, 97, 116, 101, 100, 32, 69, 110, 99, 114, 121, 112, 116, 105,\n\t111, 110, 32, 75, 101, 121,\n]);\n\nconst now = () => (Date.now() / 1000) | 0;\n\nconst alg = \"dir\";\nconst enc = \"A256CBC-HS512\"; // 64 bytes key\n\nexport async function symmetricEncodeJWT<T extends Record<string, any>>(\n\tpayload: T,\n\tsecret: string,\n\tsalt: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst encryptionSecret = hkdf(\n\t\tsha256,\n\t\tnew TextEncoder().encode(secret),\n\t\tnew TextEncoder().encode(salt),\n\t\tinfo,\n\t\t64,\n\t);\n\n\tconst thumbprint = await calculateJwkThumbprint(\n\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\"sha256\",\n\t);\n\n\treturn await new EncryptJWT(payload)\n\t\t.setProtectedHeader({ alg, enc, kid: thumbprint })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(now() + expiresIn)\n\t\t.setJti(crypto.randomUUID())\n\t\t.encrypt(encryptionSecret);\n}\n\nexport async function symmetricDecodeJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n\tsalt: string,\n): Promise<T | null> {\n\tif (!token) return null;\n\ttry {\n\t\tconst { payload } = await jwtDecrypt(\n\t\t\ttoken,\n\t\t\tasync ({ kid }) => {\n\t\t\t\tconst encryptionSecret = hkdf(\n\t\t\t\t\tsha256,\n\t\t\t\t\tnew TextEncoder().encode(secret),\n\t\t\t\t\tnew TextEncoder().encode(salt),\n\t\t\t\t\tinfo,\n\t\t\t\t\t64,\n\t\t\t\t);\n\t\t\t\tif (kid === undefined) return encryptionSecret;\n\n\t\t\t\tconst thumbprint = await calculateJwkThumbprint(\n\t\t\t\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\t\t\t\"sha256\",\n\t\t\t\t);\n\t\t\t\tif (kid === thumbprint) return encryptionSecret;\n\n\t\t\t\tthrow new Error(\"no matching decryption secret\");\n\t\t\t},\n\t\t\t{\n\t\t\t\tclockTolerance: 15,\n\t\t\t\tkeyManagementAlgorithms: [alg],\n\t\t\t\tcontentEncryptionAlgorithms: [enc, \"A256GCM\"],\n\t\t\t},\n\t\t);\n\t\treturn payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n"],"names":["info: Uint8Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAWA,eAAsB,QACrB,OAAA,EACA,MAAA,EACA,YAAoB,IAAA,EACF;IAOlB,OANY,MAAM,IAAI,kKAAA,CAAQ,QAAQ,CACpC,kBAAA,CAAmB;QAAE,KAAK;IAAA,CAAS,CAAC,CACpC,WAAA,EAAa,CACb,iBAAA,CAAkB,KAAK,KAAA,CAAM,KAAK,GAAA,EAAK,GAAG,IAAK,GAAG,UAAU,CAC5D,IAAA,CAAK,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,CAAC;;AAKzC,eAAsB,UACrB,KAAA,EACA,MAAA,EACoB;IACpB,IAAI;QAEH,OAAA,CADiB,UAAM,sKAAA,EAAU,OAAO,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,CAAC,EACzD,OAAA;aACT;QACP,OAAO;;;AAKT,MAAMA,OAAmB,IAAI,WAAW;IACvC;IAAI;IAAK;IAAK;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAI;IAAI;IACtE;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAK;IAAI;IAAI;IAAK;IAAI;IAAK;IAAK;IAAK;IAAK;IACvE;IAAK;IAAK;IAAI;IAAI;IAAK;CACvB,CAAC;AAEF,MAAM,MAAA,IAAa,KAAK,GAAA,EAAK,GAAG,MAAQ;AAExC,MAAM,MAAM;AACZ,MAAM,MAAM;AAEZ,eAAsB,mBACrB,OAAA,EACA,MAAA,EACA,IAAA,EACA,YAAoB,IAAA,EACF;IAClB,MAAM,uBAAmB,mJAAA,EACxB,qJAAA,EACA,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,EAChC,IAAI,aAAa,CAAC,MAAA,CAAO,KAAK,EAC9B,MACA,GACA;IAED,MAAM,aAAa,UAAM,uLAAA,EACxB;QAAE,KAAK;QAAO,GAAG,+MAAA,CAAU,MAAA,CAAO,iBAAiB;KAAE,EACrD,SACA;IAED,OAAO,MAAM,IAAI,wKAAA,CAAW,QAAQ,CAClC,kBAAA,CAAmB;QAAE;QAAK;QAAK,KAAK;KAAY,CAAC,CACjD,WAAA,EAAa,CACb,iBAAA,CAAkB,KAAK,GAAG,UAAU,CACpC,MAAA,CAAO,OAAO,UAAA,EAAY,CAAC,CAC3B,OAAA,CAAQ,iBAAiB;;AAG5B,eAAsB,mBACrB,KAAA,EACA,MAAA,EACA,IAAA,EACoB;IACpB,IAAI,CAAC,MAAO,CAAA,OAAO;IACnB,IAAI;QACH,MAAM,EAAE,OAAA,EAAA,GAAY,UAAM,wKAAA,EACzB,OACA,OAAO,EAAE,GAAA,EAAA,KAAU;YAClB,MAAM,uBAAmB,mJAAA,EACxB,qJAAA,EACA,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,EAChC,IAAI,aAAa,CAAC,MAAA,CAAO,KAAK,EAC9B,MACA,GACA;YACD,IAAI,QAAQ,KAAA,EAAW,CAAA,OAAO;YAM9B,IAAI,QAJe,UAAM,uLAAA,EACxB;gBAAE,KAAK;gBAAO,GAAG,+MAAA,CAAU,MAAA,CAAO,iBAAiB;aAAE,EACrD,SACA,CACuB,CAAA,OAAO;YAE/B,MAAM,IAAI,MAAM,gCAAgC;WAEjD;YACC,gBAAgB;YAChB,yBAAyB;gBAAC;aAAI;YAC9B,6BAA6B;gBAAC;gBAAK;aAAU;SAC7C,CACD;QACD,OAAO;aACA;QACP,OAAO"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/crypto/password.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/crypto/password.ts"],"sourcesContent":["import { BetterAuthError } from \"@better-auth/core/error\";\nimport { hex } from \"@better-auth/utils/hex\";\nimport { scryptAsync } from \"@noble/hashes/scrypt.js\";\nimport { hexToBytes } from \"@noble/hashes/utils.js\";\nimport { constantTimeEqual } from \"./buffer\";\n\nconst config = {\n\tN: 16384,\n\tr: 16,\n\tp: 1,\n\tdkLen: 64,\n};\n\nasync function generateKey(password: string, salt: string) {\n\treturn await scryptAsync(password.normalize(\"NFKC\"), salt, {\n\t\tN: config.N,\n\t\tp: config.p,\n\t\tr: config.r,\n\t\tdkLen: config.dkLen,\n\t\tmaxmem: 128 * config.N * config.r * 2,\n\t});\n}\n\nexport const hashPassword = async (password: string) => {\n\tconst salt = hex.encode(crypto.getRandomValues(new Uint8Array(16)));\n\tconst key = await generateKey(password, salt);\n\treturn `${salt}:${hex.encode(key)}`;\n};\n\nexport const verifyPassword = async ({\n\thash,\n\tpassword,\n}: {\n\thash: string;\n\tpassword: string;\n}) => {\n\tconst [salt, key] = hash.split(\":\");\n\tif (!salt || !key) {\n\t\tthrow new BetterAuthError(\"Invalid password hash\");\n\t}\n\tconst targetKey = await generateKey(password, salt!);\n\treturn constantTimeEqual(targetKey, hexToBytes(key));\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,MAAM,SAAS;IACd,GAAG;IACH,GAAG;IACH,GAAG;IACH,OAAO;CACP;AAED,eAAe,YAAY,QAAA,EAAkB,IAAA,EAAc;IAC1D,OAAO,UAAM,4JAAA,EAAY,SAAS,SAAA,CAAU,OAAO,EAAE,MAAM;QAC1D,GAAG,OAAO,CAAA;QACV,GAAG,OAAO,CAAA;QACV,GAAG,OAAO,CAAA;QACV,OAAO,OAAO,KAAA;QACd,QAAQ,MAAM,OAAO,CAAA,GAAI,OAAO,CAAA,GAAI;KACpC,CAAC;;AAGH,MAAa,eAAe,OAAO,aAAqB;IACvD,MAAM,OAAO,kKAAA,CAAI,MAAA,CAAO,OAAO,eAAA,CAAgB,IAAI,WAAW,GAAG,CAAC,CAAC;IACnE,MAAM,MAAM,MAAM,YAAY,UAAU,KAAK;IAC7C,OAAO,GAAG,KAAK,CAAA,EAAG,kKAAA,CAAI,MAAA,CAAO,IAAI,EAAA;;AAGlC,MAAa,iBAAiB,OAAO,EACpC,IAAA,EACA,QAAA,EAAA,KAIK;IACL,MAAM,CAAC,MAAM,IAAA,GAAO,KAAK,KAAA,CAAM,IAAI;IACnC,IAAI,CAAC,QAAQ,CAAC,IACb,CAAA,MAAM,IAAI,wMAAA,CAAgB,wBAAwB;IAGnD,WAAO,kLAAA,EADW,MAAM,YAAY,UAAU,KAAM,MAChB,0JAAA,EAAW,IAAI,CAAC"}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/crypto/index.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/crypto/index.ts"],"sourcesContent":["import { getWebcryptoSubtle } from \"@better-auth/utils\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { xchacha20poly1305 } from \"@noble/ciphers/chacha.js\";\nimport {\n\tbytesToHex,\n\thexToBytes,\n\tmanagedNonce,\n\tutf8ToBytes,\n} from \"@noble/ciphers/utils.js\";\n\nconst algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n\nexport type SymmetricEncryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricEncrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricEncryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = utf8ToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn bytesToHex(chacha.encrypt(dataAsBytes));\n};\n\nexport type SymmetricDecryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricDecrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricDecryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = hexToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn new TextDecoder().decode(chacha.decrypt(dataAsBytes));\n};\n\nexport const getCryptoKey = async (secret: string | BufferSource) => {\n\tconst secretBuf =\n\t\ttypeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await getWebcryptoSubtle().importKey(\n\t\t\"raw\",\n\t\tsecretBuf,\n\t\talgorithm,\n\t\tfalse,\n\t\t[\"sign\", \"verify\"],\n\t);\n};\n\nexport const makeSignature = async (\n\tvalue: string,\n\tsecret: string | BufferSource,\n): Promise<string> => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await getWebcryptoSubtle().sign(\n\t\talgorithm.name,\n\t\tkey,\n\t\tnew TextEncoder().encode(value),\n\t);\n\t// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\n\nexport * from \"./buffer\";\nexport * from \"./jwt\";\nexport * from \"./password\";\nexport * from \"./random\";\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,MAAM,YAAY;IAAE,MAAM;IAAQ,MAAM;CAAW;AAOnD,MAAa,mBAAmB,OAAO,EACtC,GAAA,EACA,IAAA,EAAA,KAC8B;IAC9B,MAAM,aAAa,UAAM,0KAAA,EAAW,UAAU,CAAC,MAAA,CAAO,IAAI;IAC1D,MAAM,kBAAc,4JAAA,EAAY,KAAK;IAErC,WAAO,2JAAA,MADQ,6JAAA,EAAa,mKAAA,CAAkB,CAAC,IAAI,WAAW,WAAW,CAAC,CACjD,OAAA,CAAQ,YAAY,CAAC;;AAQ/C,MAAa,mBAAmB,OAAO,EACtC,GAAA,EACA,IAAA,EAAA,KAC8B;IAC9B,MAAM,aAAa,UAAM,0KAAA,EAAW,UAAU,CAAC,MAAA,CAAO,IAAI;IAC1D,MAAM,kBAAc,2JAAA,EAAW,KAAK;IACpC,MAAM,aAAS,6JAAA,EAAa,mKAAA,CAAkB,CAAC,IAAI,WAAW,WAAW,CAAC;IAC1E,OAAO,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,OAAA,CAAQ,YAAY,CAAC;;AAG7D,MAAa,eAAe,OAAO,WAAkC;IACpE,MAAM,YACL,OAAO,WAAW,WAAW,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,GAAG;IACjE,OAAO,UAAM,mLAAA,EAAoB,EAAC,SAAA,CACjC,OACA,WACA,WACA,OACA;QAAC;QAAQ;KAAS,CAClB;;AAGF,MAAa,gBAAgB,OAC5B,OACA,WACqB;IACrB,MAAM,MAAM,MAAM,aAAa,OAAO;IACtC,MAAM,YAAY,UAAM,mLAAA,EAAoB,EAAC,IAAA,CAC5C,UAAU,IAAA,EACV,KACA,IAAI,aAAa,CAAC,MAAA,CAAO,MAAM,CAC/B;IAED,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,IAAI,WAAW,UAAU,CAAC,CAAC"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/date.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/date.ts"],"sourcesContent":["export const getDate = (span: number, unit: \"sec\" | \"ms\" = \"ms\") => {\n\treturn new Date(Date.now() + (unit === \"sec\" ? span * 1000 : span));\n};\n"],"names":[],"mappings":";;;;;AAAA,MAAa,UAAA,CAAW,MAAc,OAAqB,IAAA,KAAS;IACnE,OAAO,IAAI,KAAK,KAAK,GAAA,EAAK,GAAA,CAAI,SAAS,QAAQ,OAAO,MAAO,IAAA,EAAM"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/is-promise.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/is-promise.ts"],"sourcesContent":["export function isPromise(obj?: unknown): obj is Promise<unknown> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === \"object\" || typeof obj === \"function\") &&\n\t\ttypeof (obj as Promise<unknown>).then === \"function\"\n\t);\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,UAAU,GAAA,EAAwC;IACjE,OACC,CAAC,CAAC,OAAA,CACD,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAA,KAC3C,OAAQ,IAAyB,IAAA,KAAS"}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/time.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/time.ts"],"sourcesContent":["// Time constants (in milliseconds)\nconst SEC = 1000;\nconst MIN = SEC * 60;\nconst HOUR = MIN * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * 30;\nconst YEAR = DAY * 365.25;\n\n// Unit type definitions\ntype Years = \"years\" | \"year\" | \"yrs\" | \"yr\" | \"y\";\ntype Months = \"months\" | \"month\" | \"mo\";\ntype Weeks = \"weeks\" | \"week\" | \"w\";\ntype Days = \"days\" | \"day\" | \"d\";\ntype Hours = \"hours\" | \"hour\" | \"hrs\" | \"hr\" | \"h\";\ntype Minutes = \"minutes\" | \"minute\" | \"mins\" | \"min\" | \"m\";\ntype Seconds = \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\";\ntype Unit = Years | Months | Weeks | Days | Hours | Minutes | Seconds;\ntype UnitAnyCase = Capitalize<Unit> | Uppercase<Unit> | Unit;\ntype Suffix = \" ago\" | \" from now\";\ntype Prefix = \"+\" | \"-\" | \"+ \" | \"- \";\n\n// Base time string formats\ntype BaseTimeString = `${number}${UnitAnyCase}` | `${number} ${UnitAnyCase}`;\n\n/**\n * A typed string representing a time duration.\n * Supports formats like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\", \"-5m\", etc.\n */\nexport type TimeString =\n\t| BaseTimeString\n\t| `${BaseTimeString}${Suffix}`\n\t| `${Prefix}${BaseTimeString}`;\n\nconst REGEX =\n\t/^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)(?: (ago|from now))?$/i;\n\nfunction parse(value: string): number {\n\tconst match = REGEX.exec(value);\n\n\tif (!match || (match[4] && match[1])) {\n\t\tthrow new TypeError(\n\t\t\t`Invalid time string format: \"${value}\". Use formats like \"7d\", \"30m\", \"1 hour\", etc.`,\n\t\t);\n\t}\n\n\tconst n = parseFloat(match[2]!);\n\tconst unit = match[3]!.toLowerCase();\n\n\tlet result: number;\n\tswitch (unit) {\n\t\tcase \"years\":\n\t\tcase \"year\":\n\t\tcase \"yrs\":\n\t\tcase \"yr\":\n\t\tcase \"y\":\n\t\t\tresult = n * YEAR;\n\t\t\tbreak;\n\t\tcase \"months\":\n\t\tcase \"month\":\n\t\tcase \"mo\":\n\t\t\tresult = n * MONTH;\n\t\t\tbreak;\n\t\tcase \"weeks\":\n\t\tcase \"week\":\n\t\tcase \"w\":\n\t\t\tresult = n * WEEK;\n\t\t\tbreak;\n\t\tcase \"days\":\n\t\tcase \"day\":\n\t\tcase \"d\":\n\t\t\tresult = n * DAY;\n\t\t\tbreak;\n\t\tcase \"hours\":\n\t\tcase \"hour\":\n\t\tcase \"hrs\":\n\t\tcase \"hr\":\n\t\tcase \"h\":\n\t\t\tresult = n * HOUR;\n\t\t\tbreak;\n\t\tcase \"minutes\":\n\t\tcase \"minute\":\n\t\tcase \"mins\":\n\t\tcase \"min\":\n\t\tcase \"m\":\n\t\t\tresult = n * MIN;\n\t\t\tbreak;\n\t\tcase \"seconds\":\n\t\tcase \"second\":\n\t\tcase \"secs\":\n\t\tcase \"sec\":\n\t\tcase \"s\":\n\t\t\tresult = n * SEC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new TypeError(`Unknown time unit: \"${unit}\"`);\n\t}\n\n\tif (match[1] === \"-\" || match[4] === \"ago\") {\n\t\treturn -result;\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse a time string and return the value in milliseconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in milliseconds\n * @throws TypeError if the string format is invalid\n *\n * @example\n * ms(\"1d\")          // 86400000\n * ms(\"2 hours\")     // 7200000\n * ms(\"30s\")         // 30000\n * ms(\"2 hours ago\") // -7200000\n */\nexport function ms(value: TimeString): number {\n\treturn parse(value);\n}\n\n/**\n * Parse a time string and return the value in seconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in seconds (rounded)\n * @throws TypeError if the string format is invalid\n *\n * @example\n * sec(\"1d\")          // 86400\n * sec(\"2 hours\")     // 7200\n * sec(\"-30s\")        // -30\n * sec(\"2 hours ago\") // -7200\n */\nexport function sec(value: TimeString): number {\n\treturn Math.round(parse(value) / 1000);\n}\n"],"names":["result: number"],"mappings":";;;;;;;AACA,MAAM,MAAM;AACZ,MAAM,MAAM,MAAM;AAClB,MAAM,OAAO,MAAM;AACnB,MAAM,MAAM,OAAO;AACnB,MAAM,OAAO,MAAM;AACnB,MAAM,QAAQ,MAAM;AACpB,MAAM,OAAO,MAAM;AA2BnB,MAAM,QACL;AAED,SAAS,MAAM,KAAA,EAAuB;IACrC,MAAM,QAAQ,MAAM,IAAA,CAAK,MAAM;IAE/B,IAAI,CAAC,SAAU,KAAA,CAAM,EAAA,IAAM,KAAA,CAAM,EAAA,CAChC,CAAA,MAAM,IAAI,UACT,CAAA,6BAAA,EAAgC,MAAM,+CAAA,CAAA,CACtC;IAGF,MAAM,IAAI,WAAW,KAAA,CAAM,EAAA,CAAI;IAC/B,MAAM,OAAO,KAAA,CAAM,EAAA,CAAI,WAAA,EAAa;IAEpC,IAAIA;IACJ,OAAQ,MAAR;QACC,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,QACC;YAAA,MAAM,IAAI,UAAU,CAAA,oBAAA,EAAuB,KAAK,CAAA,CAAA,CAAG;;IAGrD,IAAI,KAAA,CAAM,EAAA,KAAO,OAAO,KAAA,CAAM,EAAA,KAAO,MACpC,CAAA,OAAO,CAAC;IAGT,OAAO;;;;;;;;;;;;;;GAgBR,SAAgB,GAAG,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAM;;;;;;;;;;;;;;GAgBpB,SAAgB,IAAI,KAAA,EAA2B;IAC9C,OAAO,KAAK,KAAA,CAAM,MAAM,MAAM,GAAG,IAAK"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/hide-metadata.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/hide-metadata.ts"],"sourcesContent":["export const HIDE_METADATA = {\n\tscope: \"server\",\n} as const;\n"],"names":[],"mappings":";;;;;AAAA,MAAa,gBAAgB;IAC5B,OAAO;AAAA,CACP"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/dist/utils/index.mjs"],"sourcesContent":["import { generateGenericState, parseGenericState } from \"../state.mjs\";\nimport { generateState, parseState } from \"../oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./hide-metadata.mjs\";\nimport { generateId as generateId$1 } from \"@better-auth/core/utils\";\n\nexport { generateId$1 as generateId };"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAAA","ignoreList":[0]}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/get-request-ip.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/get-request-ip.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { isDevelopment, isTest } from \"@better-auth/core/env\";\nimport { isValidIP, normalizeIP } from \"@better-auth/core/utils\";\n\n// Localhost IP used for test and development environments\nconst LOCALHOST_IP = \"127.0.0.1\";\n\nexport function getIp(\n\treq: Request | Headers,\n\toptions: BetterAuthOptions,\n): string | null {\n\tif (options.advanced?.ipAddress?.disableIpTracking) {\n\t\treturn null;\n\t}\n\n\tconst headers = \"headers\" in req ? req.headers : req;\n\n\tconst defaultHeaders = [\"x-forwarded-for\"];\n\n\tconst ipHeaders =\n\t\toptions.advanced?.ipAddress?.ipAddressHeaders || defaultHeaders;\n\n\tfor (const key of ipHeaders) {\n\t\tconst value = \"get\" in headers ? headers.get(key) : headers[key];\n\t\tif (typeof value === \"string\") {\n\t\t\tconst ip = value.split(\",\")[0]!.trim();\n\t\t\tif (isValidIP(ip)) {\n\t\t\t\treturn normalizeIP(ip, {\n\t\t\t\t\tipv6Subnet: options.advanced?.ipAddress?.ipv6Subnet,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to localhost IP in development/test environments when no IP found in headers\n\tif (isTest() || isDevelopment()) {\n\t\treturn LOCALHOST_IP;\n\t}\n\n\treturn null;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAKA,MAAM,eAAe;AAErB,SAAgB,MACf,GAAA,EACA,OAAA,EACgB;IAChB,IAAI,QAAQ,QAAA,EAAU,WAAW,kBAChC,CAAA,OAAO;IAGR,MAAM,UAAU,aAAa,MAAM,IAAI,OAAA,GAAU;IAIjD,MAAM,YACL,QAAQ,QAAA,EAAU,WAAW,oBAHP;QAAC;KAAkB;IAK1C,KAAK,MAAM,OAAO,UAAW;QAC5B,MAAM,QAAQ,SAAS,UAAU,QAAQ,GAAA,CAAI,IAAI,GAAG,OAAA,CAAQ,IAAA;QAC5D,IAAI,OAAO,UAAU,UAAU;YAC9B,MAAM,KAAK,MAAM,KAAA,CAAM,IAAI,CAAC,EAAA,CAAI,IAAA,EAAM;YACtC,QAAI,+KAAA,EAAU,GAAG,CAChB,CAAA,WAAO,iLAAA,EAAY,IAAI;gBACtB,YAAY,QAAQ,QAAA,EAAU,WAAW;YAAA,CACzC,CAAC;;;IAML,QAAI,mLAAA,EAAQ,SAAI,0LAAA,EAAe,CAC9B,EAAA,OAAO;IAGR,OAAO"}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/url.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/url.ts"],"sourcesContent":["import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nfunction checkHasPath(url: string): boolean {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tconst pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n\t\treturn pathname !== \"/\";\n\t} catch {\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t);\n\t}\n}\n\nfunction assertHasProtocol(url: string): void {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`,\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t\t{\n\t\t\t\tcause: error,\n\t\t\t},\n\t\t);\n\t}\n}\n\nfunction withPath(url: string, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\n\tconst hasPath = checkHasPath(url);\n\tif (hasPath) {\n\t\treturn url;\n\t}\n\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\n\tif (!path || path === \"/\") {\n\t\treturn trimmedUrl;\n\t}\n\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\n\nfunction validateProxyHeader(header: string, type: \"host\" | \"proto\"): boolean {\n\tif (!header || header.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif (type === \"proto\") {\n\t\t// Only allow http and https protocols\n\t\treturn header === \"http\" || header === \"https\";\n\t}\n\n\tif (type === \"host\") {\n\t\tconst suspiciousPatterns = [\n\t\t\t/\\.\\./, // Path traversal\n\t\t\t/\\0/, // Null bytes\n\t\t\t/[\\s]/, // Whitespace (except legitimate spaces that should be trimmed)\n\t\t\t/^[.]/, // Starting with dot\n\t\t\t/[<>'\"]/, // HTML/script injection characters\n\t\t\t/javascript:/i, // Protocol injection\n\t\t\t/file:/i, // File protocol\n\t\t\t/data:/i, // Data protocol\n\t\t];\n\n\t\tif (suspiciousPatterns.some((pattern) => pattern.test(header))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Basic hostname validation (allows localhost, IPs, and domains with ports)\n\t\t// This is a simple check, not exhaustive RFC validation\n\t\tconst hostnameRegex =\n\t\t\t/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv4 addresses\n\t\tconst ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv6 addresses in brackets\n\t\tconst ipv6Regex = /^\\[[0-9a-fA-F:]+\\](:[0-9]{1,5})?$/;\n\n\t\t// Allow localhost variations\n\t\tconst localhostRegex = /^localhost(:[0-9]{1,5})?$/i;\n\n\t\treturn (\n\t\t\thostnameRegex.test(header) ||\n\t\t\tipv4Regex.test(header) ||\n\t\t\tipv6Regex.test(header) ||\n\t\t\tlocalhostRegex.test(header)\n\t\t);\n\t}\n\n\treturn false;\n}\n\nexport function getBaseURL(\n\turl?: string,\n\tpath?: string,\n\trequest?: Request,\n\tloadEnv?: boolean,\n\ttrustedProxyHeaders?: boolean | undefined,\n) {\n\tif (url) {\n\t\treturn withPath(url, path);\n\t}\n\n\tif (loadEnv !== false) {\n\t\tconst fromEnv =\n\t\t\tenv.BETTER_AUTH_URL ||\n\t\t\tenv.NEXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_AUTH_URL ||\n\t\t\t(env.BASE_URL !== \"/\" ? env.BASE_URL : undefined);\n\n\t\tif (fromEnv) {\n\t\t\treturn withPath(fromEnv, path);\n\t\t}\n\t}\n\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) {\n\t\tif (\n\t\t\tvalidateProxyHeader(fromRequestProto, \"proto\") &&\n\t\t\tvalidateProxyHeader(fromRequest, \"host\")\n\t\t) {\n\t\t\ttry {\n\t\t\t\treturn withPath(`${fromRequestProto}://${fromRequest}`, path);\n\t\t\t} catch (_error) {}\n\t\t}\n\t}\n\n\tif (request) {\n\t\tconst url = getOrigin(request.url);\n\t\tif (!url) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Could not get origin from request. Please provide a valid base URL.\",\n\t\t\t);\n\t\t}\n\t\treturn withPath(url, path);\n\t}\n\n\tif (typeof window !== \"undefined\" && window.location) {\n\t\treturn withPath(window.location.origin, path);\n\t}\n\treturn undefined;\n}\n\nexport function getOrigin(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\t// For custom URL schemes (like exp://), the origin property returns the string \"null\"\n\t\t// instead of null. We need to handle this case and return null so the fallback logic works.\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getProtocol(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.protocol;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getHost(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.host;\n\t} catch {\n\t\treturn null;\n\t}\n}\n"],"names":["url"],"mappings":"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"}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/wildcard.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/wildcard.ts"],"sourcesContent":["//https://github.com/axtgr/wildcard-match\n\n/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char: string) {\n\tif (\n\t\tchar === \"-\" ||\n\t\tchar === \"^\" ||\n\t\tchar === \"$\" ||\n\t\tchar === \"+\" ||\n\t\tchar === \".\" ||\n\t\tchar === \"(\" ||\n\t\tchar === \")\" ||\n\t\tchar === \"|\" ||\n\t\tchar === \"[\" ||\n\t\tchar === \"]\" ||\n\t\tchar === \"{\" ||\n\t\tchar === \"}\" ||\n\t\tchar === \"*\" ||\n\t\tchar === \"?\" ||\n\t\tchar === \"\\\\\"\n\t) {\n\t\treturn `\\\\${char}`;\n\t} else {\n\t\treturn char;\n\t}\n}\n\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str: string) {\n\tlet result = \"\";\n\tfor (let i = 0; i < str.length; i++) {\n\t\tresult += escapeRegExpChar(str[i]!);\n\t}\n\treturn result;\n}\n\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(\n\tpattern: string | string[],\n\tseparator: string | boolean = true,\n): string {\n\tif (Array.isArray(pattern)) {\n\t\tconst regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`);\n\t\treturn `(?:${regExpPatterns.join(\"|\")})`;\n\t}\n\n\tlet separatorSplitter = \"\";\n\tlet separatorMatcher = \"\";\n\tlet wildcard = \".\";\n\n\tif (separator === true) {\n\t\t// In this case forward slashes in patterns match both forward and backslashes in samples:\n\t\t//\n\t\t// `foo/bar` will match `foo/bar`\n\t\t//           will match `foo\\bar`\n\t\t//\n\t\tseparatorSplitter = \"/\";\n\t\tseparatorMatcher = \"[/\\\\\\\\]\";\n\t\twildcard = \"[^/\\\\\\\\]\";\n\t} else if (separator) {\n\t\tseparatorSplitter = separator;\n\t\tseparatorMatcher = escapeRegExpString(separatorSplitter);\n\n\t\tif (separatorMatcher.length > 1) {\n\t\t\tseparatorMatcher = `(?:${separatorMatcher})`;\n\t\t\twildcard = `((?!${separatorMatcher}).)`;\n\t\t} else {\n\t\t\twildcard = `[^${separatorMatcher}]`;\n\t\t}\n\t}\n\n\t// When a separator is explicitly specified in a pattern,\n\t// it MUST match ONE OR MORE separators in a sample:\n\t//\n\t// `foo/bar/` will match  `foo//bar///`\n\t//            won't match `foo/bar`\n\t//\n\t// When a pattern doesn't have a trailing separator,\n\t// a sample can still optionally have them:\n\t//\n\t// `foo/bar` will match `foo/bar//`\n\t//\n\t// So we use different quantifiers depending on the index of a segment.\n\tconst requiredSeparator = separator ? `${separatorMatcher}+?` : \"\";\n\tconst optionalSeparator = separator ? `${separatorMatcher}*?` : \"\";\n\n\tconst segments = separator ? pattern.split(separatorSplitter) : [pattern];\n\tlet result = \"\";\n\n\tfor (let s = 0; s < segments.length; s++) {\n\t\tconst segment = segments[s]!;\n\t\tconst nextSegment = segments[s + 1]!;\n\t\tlet currentSeparator = \"\";\n\n\t\tif (!segment && s > 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (separator) {\n\t\t\tif (s === segments.length - 1) {\n\t\t\t\tcurrentSeparator = optionalSeparator;\n\t\t\t} else if (nextSegment !== \"**\") {\n\t\t\t\tcurrentSeparator = requiredSeparator;\n\t\t\t} else {\n\t\t\t\tcurrentSeparator = \"\";\n\t\t\t}\n\t\t}\n\n\t\tif (separator && segment === \"**\") {\n\t\t\tif (currentSeparator) {\n\t\t\t\tresult += s === 0 ? \"\" : currentSeparator;\n\t\t\t\tresult += `(?:${wildcard}*?${currentSeparator})*?`;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (let c = 0; c < segment.length; c++) {\n\t\t\tconst char = segment[c]!;\n\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tif (c < segment.length - 1) {\n\t\t\t\t\tresult += escapeRegExpChar(segment[c + 1]!);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t} else if (char === \"?\") {\n\t\t\t\tresult += wildcard;\n\t\t\t} else if (char === \"*\") {\n\t\t\t\tresult += `${wildcard}*?`;\n\t\t\t} else {\n\t\t\t\tresult += escapeRegExpChar(char);\n\t\t\t}\n\t\t}\n\n\t\tresult += currentSeparator;\n\t}\n\n\treturn result;\n}\n\ninterface WildcardMatchOptions {\n\t/** Separator to be used to split patterns and samples into segments */\n\tseparator?: string | boolean;\n\n\t/** Flags to pass to the RegExp */\n\tflags?: string;\n}\n\n// This overrides the function's signature because for the end user\n// the function is always bound to a RegExp\ninterface isMatch {\n\t/**\n\t * Tests if a sample string matches the pattern(s)\n\t *\n\t * ```js\n\t * isMatch('foo') //=> true\n\t * ```\n\t */\n\t(sample: string): boolean;\n\n\t/** Compiled regular expression */\n\tregexp: RegExp;\n\n\t/** Original pattern or array of patterns that was used to compile the RegExp */\n\tpattern: string | string[];\n\n\t/** Options that were used to compile the RegExp */\n\toptions: WildcardMatchOptions;\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n\tif (typeof sample !== \"string\") {\n\t\tthrow new TypeError(`Sample must be a string, but ${typeof sample} given`);\n\t}\n\n\treturn regexp.test(sample);\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n\tpattern: string | string[],\n\toptions?: string | boolean | WildcardMatchOptions,\n) {\n\tif (typeof pattern !== \"string\" && !Array.isArray(pattern)) {\n\t\tthrow new TypeError(\n\t\t\t`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`,\n\t\t);\n\t}\n\n\tif (typeof options === \"string\" || typeof options === \"boolean\") {\n\t\toptions = { separator: options };\n\t}\n\n\tif (\n\t\targuments.length === 2 &&\n\t\t!(\n\t\t\ttypeof options === \"undefined\" ||\n\t\t\t(typeof options === \"object\" &&\n\t\t\t\toptions !== null &&\n\t\t\t\t!Array.isArray(options))\n\t\t)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`,\n\t\t);\n\t}\n\n\toptions = options || {};\n\n\tif (options.separator === \"\\\\\") {\n\t\tthrow new Error(\n\t\t\t\"\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead\",\n\t\t);\n\t}\n\n\tconst regexpPattern = transform(pattern, options.separator);\n\tconst regexp = new RegExp(`^${regexpPattern}$`, options.flags);\n\n\tconst fn = isMatch.bind(null, regexp) as isMatch;\n\tfn.options = options;\n\tfn.pattern = pattern;\n\tfn.regexp = regexp;\n\treturn fn;\n}\n\nexport { wildcardMatch };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/password.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/password.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\n\nexport async function validatePassword(\n\tctx: GenericEndpointContext,\n\tdata: {\n\t\tpassword: string;\n\t\tuserId: string;\n\t},\n) {\n\tconst accounts = await ctx.context.internalAdapter.findAccounts(data.userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword) {\n\t\treturn false;\n\t}\n\tconst compare = await ctx.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: data.password,\n\t});\n\treturn compare;\n}\n\nexport async function checkPassword(userId: string, c: GenericEndpointContext) {\n\tconst accounts = await c.context.internalAdapter.findAccounts(userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword || !c.body.password) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"No password credential found\",\n\t\t});\n\t}\n\tconst compare = await c.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: c.body.password,\n\t});\n\tif (!compare) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Invalid password\",\n\t\t});\n\t}\n\treturn true;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAGA,eAAsB,iBACrB,GAAA,EACA,IAAA,EAIC;IAED,MAAM,oBAAA,CADW,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,KAAK,MAAA,CAAO,GACxC,KAAA,CAClC,UAAY,QAAQ,UAAA,KAAe,aACpC;IACD,MAAM,kBAAkB,mBAAmB;IAC3C,IAAI,CAAC,qBAAqB,CAAC,gBAC1B,CAAA,OAAO;IAMR,OAJgB,MAAM,IAAI,OAAA,CAAQ,QAAA,CAAS,MAAA,CAAO;QACjD,MAAM;QACN,UAAU,KAAK,QAAA;KACf,CAAC;;AAIH,eAAsB,cAAc,MAAA,EAAgB,CAAA,EAA2B;IAE9E,MAAM,oBAAA,CADW,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,OAAO,GACjC,KAAA,CAClC,UAAY,QAAQ,UAAA,KAAe,aACpC;IACD,MAAM,kBAAkB,mBAAmB;IAC3C,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,EAAE,IAAA,CAAK,QAAA,CACrD,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAMH,IAAI,CAJY,MAAM,EAAE,OAAA,CAAQ,QAAA,CAAS,MAAA,CAAO;QAC/C,MAAM;QACN,UAAU,EAAE,IAAA,CAAK,QAAA;KACjB,CAAC,CAED,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAEH,OAAO"}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/constants.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/constants.ts"],"sourcesContent":["export const DEFAULT_SECRET = \"better-auth-secret-12345678901234567890\";\n"],"names":[],"mappings":";;;;;AAAA,MAAa,iBAAiB"}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/plugin-helper.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/plugin-helper.ts"],"sourcesContent":["import { APIError } from \"better-call\";\n\nexport const getEndpointResponse = async <T>(ctx: {\n\tcontext: {\n\t\treturned?: unknown;\n\t};\n}) => {\n\tconst returned = ctx.context.returned;\n\tif (!returned) {\n\t\treturn null;\n\t}\n\tif (returned instanceof Response) {\n\t\tif (returned.status !== 200) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (await returned.clone().json()) as T;\n\t}\n\tif (returned instanceof APIError) {\n\t\treturn null;\n\t}\n\treturn returned as T;\n};\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAa,sBAAsB,OAAU,QAIvC;IACL,MAAM,WAAW,IAAI,OAAA,CAAQ,QAAA;IAC7B,IAAI,CAAC,SACJ,CAAA,OAAO;IAER,IAAI,oBAAoB,UAAU;QACjC,IAAI,SAAS,MAAA,KAAW,IACvB,CAAA,OAAO;QAER,OAAQ,MAAM,SAAS,KAAA,EAAO,CAAC,IAAA,EAAM;;IAEtC,IAAI,oBAAoB,8JAAA,CACvB,CAAA,OAAO;IAER,OAAO"}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/middleware-response.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/middleware-response.ts"],"sourcesContent":["type Params = {\n\tmessage: string;\n\tstatus: number;\n};\n\nexport const middlewareResponse = ({ message, status }: Params) => ({\n\tresponse: new Response(\n\t\tJSON.stringify({\n\t\t\tmessage,\n\t\t}),\n\t\t{\n\t\t\tstatus,\n\t\t},\n\t),\n});\n"],"names":[],"mappings":";;;;;AAKA,MAAa,qBAAA,CAAsB,EAAE,OAAA,EAAS,MAAA,EAAA,GAAA,CAAsB;QACnE,UAAU,IAAI,SACb,KAAK,SAAA,CAAU;YACd;QAAA,CACA,CAAC,EACF;YACC;QAAA,CACA,CACD;IAAA,CACD"}},
    {"offset": {"line": 786, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/boolean.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/boolean.ts"],"sourcesContent":["export function toBoolean(value: any): boolean {\n\treturn value === \"true\" || value === true;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,UAAU,KAAA,EAAqB;IAC9C,OAAO,UAAU,UAAU,UAAU"}},
    {"offset": {"line": 800, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/shim.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/shim.ts"],"sourcesContent":["export const shimContext = <T extends Record<string, any>>(\n\toriginalObject: T,\n\tnewContext: Record<string, any>,\n) => {\n\tconst shimmedObj: Record<string, any> = {};\n\tfor (const [key, value] of Object.entries(originalObject)) {\n\t\tshimmedObj[key] = (ctx: Record<string, any>) => {\n\t\t\treturn value({\n\t\t\t\t...ctx,\n\t\t\t\tcontext: {\n\t\t\t\t\t...newContext,\n\t\t\t\t\t...ctx.context,\n\t\t\t\t},\n\t\t\t});\n\t\t};\n\t\tshimmedObj[key].path = value.path;\n\t\tshimmedObj[key].method = value.method;\n\t\tshimmedObj[key].options = value.options;\n\t\tshimmedObj[key].headers = value.headers;\n\t}\n\treturn shimmedObj as T;\n};\n"],"names":["shimmedObj: Record<string, any>"],"mappings":";;;;;AAAA,MAAa,cAAA,CACZ,gBACA,eACI;IACJ,MAAMA,aAAkC,CAAA,CAAE;IAC1C,KAAK,MAAM,CAAC,KAAK,MAAA,IAAU,OAAO,OAAA,CAAQ,eAAe,CAAE;QAC1D,UAAA,CAAW,IAAA,GAAA,CAAQ,QAA6B;YAC/C,OAAO,MAAM;gBACZ,GAAG,GAAA;gBACH,SAAS;oBACR,GAAG,UAAA;oBACH,GAAG,IAAI,OAAA;iBACP;aACD,CAAC;;QAEH,UAAA,CAAW,IAAA,CAAK,IAAA,GAAO,MAAM,IAAA;QAC7B,UAAA,CAAW,IAAA,CAAK,MAAA,GAAS,MAAM,MAAA;QAC/B,UAAA,CAAW,IAAA,CAAK,OAAA,GAAU,MAAM,OAAA;QAChC,UAAA,CAAW,IAAA,CAAK,OAAA,GAAU,MAAM,OAAA;;IAEjC,OAAO"}},
    {"offset": {"line": 830, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/utils/hashing.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/utils/hashing.ts"],"sourcesContent":["import { keccak_256 } from \"@noble/hashes/sha3.js\";\nimport { utf8ToBytes } from \"@noble/hashes/utils.js\";\n\n/**\n * TS implementation of ERC-55 (\"Mixed-case checksum address encoding\") using @noble/hashes\n * @param address - The address to convert to a checksum address\n * @returns The checksummed address\n */\nexport function toChecksumAddress(address: string) {\n\taddress = address.toLowerCase().replace(\"0x\", \"\");\n\t// Hash the address (treat it as UTF-8) and return as a hex string\n\tconst hash = [...keccak_256(utf8ToBytes(address))]\n\t\t.map((v) => v.toString(16).padStart(2, \"0\"))\n\t\t.join(\"\");\n\tlet ret = \"0x\";\n\n\tfor (let i = 0; i < 40; i++) {\n\t\tif (parseInt(hash[i]!, 16) >= 8) {\n\t\t\tret += address[i]!.toUpperCase();\n\t\t} else {\n\t\t\tret += address[i]!;\n\t\t}\n\t}\n\n\treturn ret;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;GAQA,SAAgB,kBAAkB,OAAA,EAAiB;IAClD,UAAU,QAAQ,WAAA,EAAa,CAAC,OAAA,CAAQ,MAAM,GAAG;IAEjD,MAAM,OAAO,CAAC;eAAG,yJAAA,MAAW,2JAAA,EAAY,QAAQ,CAAC;KAAC,CAChD,GAAA,CAAA,CAAK,IAAM,EAAE,QAAA,CAAS,GAAG,CAAC,QAAA,CAAS,GAAG,IAAI,CAAC,CAC3C,IAAA,CAAK,GAAG;IACV,IAAI,MAAM;IAEV,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IACvB,IAAI,SAAS,IAAA,CAAK,EAAA,EAAK,GAAG,IAAI,EAC7B,CAAA,OAAO,OAAA,CAAQ,EAAA,CAAI,WAAA,EAAa;SAEhC,OAAO,OAAA,CAAQ,EAAA;IAIjB,OAAO"}},
    {"offset": {"line": 859, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/schema.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tBetterAuthPluginDBSchema,\n\tDBFieldAttribute,\n} from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport { APIError } from \"better-call\";\nimport type { Account, Session, User } from \"../types\";\n\n// Cache for parsed schemas to avoid reparsing on every request\nconst cache = new WeakMap<\n\tBetterAuthOptions,\n\tMap<string, Record<string, DBFieldAttribute>>\n>();\n\nfunction parseOutputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t},\n) {\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (\n\t\t\tfield.returned === false &&\n\t\t\tkey !== \"id\" // id is always returned\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData as T;\n}\n\nfunction getFields(\n\toptions: BetterAuthOptions,\n\ttable: string,\n\tmode: \"input\" | \"output\",\n) {\n\tconst cacheKey = `${table}:${mode}`;\n\tif (!cache.has(options)) {\n\t\tcache.set(options, new Map());\n\t}\n\tconst tableCache = cache.get(options)!;\n\tif (tableCache.has(cacheKey)) {\n\t\treturn tableCache.get(cacheKey)!;\n\t}\n\tconst coreSchema =\n\t\tmode === \"output\" ? (getAuthTables(options)[table]?.fields ?? {}) : {};\n\tconst additionalFields =\n\t\ttable === \"user\" || table === \"session\" || table === \"account\"\n\t\t\t? options[table]?.additionalFields\n\t\t\t: undefined;\n\tlet schema: Record<string, DBFieldAttribute> = {\n\t\t...coreSchema,\n\t\t...(additionalFields ?? {}),\n\t};\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.schema && plugin.schema[table]) {\n\t\t\tschema = {\n\t\t\t\t...schema,\n\t\t\t\t...plugin.schema[table].fields,\n\t\t\t};\n\t\t}\n\t}\n\ttableCache.set(cacheKey, schema);\n\treturn schema;\n}\n\nexport function parseUserOutput<T extends User>(\n\toptions: BetterAuthOptions,\n\tuser: T,\n) {\n\tconst schema = getFields(options, \"user\", \"output\");\n\treturn parseOutputData(user, { fields: schema });\n}\n\nexport function parseSessionOutput<T extends Session>(\n\toptions: BetterAuthOptions,\n\tsession: T,\n) {\n\tconst schema = getFields(options, \"session\", \"output\");\n\treturn parseOutputData(session, { fields: schema });\n}\n\nexport function parseAccountOutput<T extends Account>(\n\toptions: BetterAuthOptions,\n\taccount: T,\n) {\n\tconst schema = getFields(options, \"account\", \"output\");\n\tconst parsed = parseOutputData(account, { fields: schema });\n\t// destructuring for type inference\n\t// runtime filtering is already done by `parseOutputData`\n\tconst {\n\t\taccessToken: _accessToken,\n\t\trefreshToken: _refreshToken,\n\t\tidToken: _idToken,\n\t\taccessTokenExpiresAt: _accessTokenExpiresAt,\n\t\trefreshTokenExpiresAt: _refreshTokenExpiresAt,\n\t\tpassword: _password,\n\t\t...rest\n\t} = parsed;\n\treturn rest;\n}\n\nexport function parseInputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\taction?: (\"create\" | \"update\") | undefined;\n\t},\n) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = Object.assign(\n\t\tObject.create(null),\n\t\tnull,\n\t);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key]!.input === false) {\n\t\t\t\tif (fields[key]!.defaultValue !== undefined) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: `${key} is not allowed to be set`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.validator?.input && data[key] !== undefined) {\n\t\t\t\tconst result = fields[key]!.validator.input[\"~standard\"].validate(\n\t\t\t\t\tdata[key],\n\t\t\t\t);\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Async validation is not supported for additional fields\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (\"issues\" in result && result.issues) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: result.issues[0]?.message || \"Validation Error\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tparsedData[key] = result.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.transform?.input && data[key] !== undefined) {\n\t\t\t\tparsedData[key] = fields[key]!.transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.defaultValue !== undefined && action === \"create\") {\n\t\t\tif (typeof fields[key]!.defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key]!.defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.required && action === \"create\") {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `${key} is required`,\n\t\t\t});\n\t\t}\n\t}\n\treturn parsedData as Partial<T>;\n}\n\nexport function parseUserInput(\n\toptions: BetterAuthOptions,\n\tuser: Record<string, any> = {},\n\taction: \"create\" | \"update\",\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user, { fields: schema, action });\n}\n\nexport function parseAdditionalUserInput(\n\toptions: BetterAuthOptions,\n\tuser?: Record<string, any> | undefined,\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\n\nexport function parseAccountInput(\n\toptions: BetterAuthOptions,\n\taccount: Partial<Account>,\n) {\n\tconst schema = getFields(options, \"account\", \"input\");\n\treturn parseInputData(account, { fields: schema });\n}\n\nexport function parseSessionInput(\n\toptions: BetterAuthOptions,\n\tsession: Partial<Session>,\n) {\n\tconst schema = getFields(options, \"session\", \"input\");\n\treturn parseInputData(session, { fields: schema });\n}\n\nexport function mergeSchema<S extends BetterAuthPluginDBSchema>(\n\tschema: S,\n\tnewSchema?:\n\t\t| {\n\t\t\t\t[K in keyof S]?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tmodelName?: string | undefined;\n\t\t\t\t\t\t\tfields?:\n\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t[P: string]: string;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tif (!newSchema) {\n\t\treturn schema;\n\t}\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) {\n\t\t\tschema[table]!.modelName = newModelName;\n\t\t}\n\t\tfor (const field in schema[table]!.fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tschema[table]!.fields[field]!.fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n"],"names":["parsedData: Record<string, any>","schema: Record<string, DBFieldAttribute>"],"mappings":"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"}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/adapter-base.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/adapter-base.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport type { MemoryDB } from \"../adapters/memory-adapter\";\n\nexport async function getBaseAdapter(\n\toptions: BetterAuthOptions,\n\thandleDirectDatabase: (\n\t\toptions: BetterAuthOptions,\n\t) => Promise<DBAdapter<BetterAuthOptions>>,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\tlet adapter: DBAdapter<BetterAuthOptions>;\n\n\tif (!options.database) {\n\t\tconst tables = getAuthTables(options);\n\t\tconst memoryDB = Object.keys(tables).reduce<MemoryDB>((acc, key) => {\n\t\t\tacc[key] = [];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst { memoryAdapter } = await import(\"../adapters/memory-adapter\");\n\t\tadapter = memoryAdapter(memoryDB)(options);\n\t} else if (typeof options.database === \"function\") {\n\t\tadapter = options.database(options);\n\t} else {\n\t\tadapter = await handleDirectDatabase(options);\n\t}\n\n\t// patch for 1.3.x to ensure we have a transaction function in the adapter\n\tif (!adapter.transaction) {\n\t\tlogger.warn(\n\t\t\t\"Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.\",\n\t\t);\n\t\tadapter.transaction = async (cb) => {\n\t\t\treturn cb(adapter);\n\t\t};\n\t}\n\n\treturn adapter;\n}\n"],"names":["adapter: DBAdapter<BetterAuthOptions>"],"mappings":";;;;;;;;;;;AAMA,eAAsB,eACrB,OAAA,EACA,oBAAA,EAGwC;IACxC,IAAIA;IAEJ,IAAI,CAAC,QAAQ,QAAA,EAAU;QACtB,MAAM,aAAS,2LAAA,EAAc,QAAQ;QACrC,MAAM,WAAW,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAkB,KAAK,QAAQ;YACnE,GAAA,CAAI,IAAA,GAAO,EAAE;YACb,OAAO;WACL,CAAA,CAAE,CAAC;QACN,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,UAAU,cAAc,SAAS,CAAC,QAAQ;eAChC,OAAO,QAAQ,QAAA,KAAa,WACtC,CAAA,UAAU,QAAQ,QAAA,CAAS,QAAQ;SAEnC,UAAU,MAAM,qBAAqB,QAAQ;IAI9C,IAAI,CAAC,QAAQ,WAAA,EAAa;QACzB,8KAAA,CAAO,IAAA,CACN,mIACA;QACD,QAAQ,WAAA,GAAc,OAAO,OAAO;YACnC,OAAO,GAAG,QAAQ;;;IAIpB,OAAO"}},
    {"offset": {"line": 1063, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/adapter-kysely.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/adapter-kysely.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { getBaseAdapter } from \"./adapter-base\";\n\nexport async function getAdapter(\n\toptions: BetterAuthOptions,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\treturn getBaseAdapter(options, async (opts) => {\n\t\tconst { createKyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\tconst { kysely, databaseType, transaction } =\n\t\t\tawait createKyselyAdapter(opts);\n\t\tif (!kysely) {\n\t\t\tthrow new BetterAuthError(\"Failed to initialize database adapter\");\n\t\t}\n\t\tconst { kyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\treturn kyselyAdapter(kysely, {\n\t\t\ttype: databaseType || \"sqlite\",\n\t\t\tdebugLogs:\n\t\t\t\topts.database && \"debugLogs\" in opts.database\n\t\t\t\t\t? opts.database.debugLogs\n\t\t\t\t\t: false,\n\t\t\ttransaction: transaction,\n\t\t})(opts);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;;;AAKA,eAAsB,WACrB,OAAA,EACwC;IACxC,WAAO,oLAAA,EAAe,SAAS,OAAO,SAAS;QAC9C,MAAM,EAAE,mBAAA,EAAA,GAAwB,MAAM,OAAO;QAC7C,MAAM,EAAE,MAAA,EAAQ,YAAA,EAAc,WAAA,EAAA,GAC7B,MAAM,oBAAoB,KAAK;QAChC,IAAI,CAAC,OACJ,CAAA,MAAM,IAAI,wMAAA,CAAgB,wCAAwC;QAEnE,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,OAAO,cAAc,QAAQ;YAC5B,MAAM,gBAAgB;YACtB,WACC,KAAK,QAAA,IAAY,eAAe,KAAK,QAAA,GAClC,KAAK,QAAA,CAAS,SAAA,GACd;YACS;SACb,CAAC,CAAC,KAAK;MACP"}},
    {"offset": {"line": 1091, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/field.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/field.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tDBFieldAttribute,\n\tDBFieldAttributeConfig,\n\tDBFieldType,\n} from \"@better-auth/core/db\";\n\nexport const createFieldAttribute = <\n\tT extends DBFieldType,\n\tC extends DBFieldAttributeConfig,\n>(\n\ttype: T,\n\tconfig?: C | undefined,\n) => {\n\treturn {\n\t\ttype,\n\t\t...config,\n\t} satisfies DBFieldAttribute<T>;\n};\n\nexport type InferValueType<T extends DBFieldType> = T extends \"string\"\n\t? string\n\t: T extends \"number\"\n\t\t? number\n\t\t: T extends \"boolean\"\n\t\t\t? boolean\n\t\t\t: T extends \"date\"\n\t\t\t\t? Date\n\t\t\t\t: T extends \"json\"\n\t\t\t\t\t? Record<string, any>\n\t\t\t\t\t: T extends `${infer U}[]`\n\t\t\t\t\t\t? U extends \"string\"\n\t\t\t\t\t\t\t? string[]\n\t\t\t\t\t\t\t: number[]\n\t\t\t\t\t\t: T extends Array<any>\n\t\t\t\t\t\t\t? T[number]\n\t\t\t\t\t\t\t: never;\n\nexport type InferFieldsOutput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: key]: InferFieldOutput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key\n\t\t\t\t\t\t: never]?: InferFieldOutput<Field[key]> | null;\n\t\t\t}\n\t\t: {};\n\nexport type InferFieldsInput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false ? never : key]?:\n\t\t\t\t\t| InferFieldInput<Field[key]>\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null;\n\t\t\t}\n\t\t: {};\n\n/**\n * For client will add \"?\" on optional fields\n */\nexport type InferFieldsInputClient<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? key\n\t\t\t\t\t\t: Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never]?: InferFieldInput<Field[key]> | undefined | null;\n\t\t\t}\n\t\t: {};\n\ntype InferFieldOutput<T extends DBFieldAttribute> = T[\"returned\"] extends false\n\t? never\n\t: T[\"required\"] extends false\n\t\t? InferValueType<T[\"type\"]> | undefined | null\n\t\t: InferValueType<T[\"type\"]>;\n\n/**\n * Converts a Record<string, DBFieldAttribute> to an object type\n * with keys and value types inferred from DBFieldAttribute[\"type\"].\n */\nexport type FieldAttributeToObject<\n\tFields extends Record<string, DBFieldAttribute>,\n> = AddOptionalFields<\n\t{\n\t\t[K in keyof Fields]: InferValueType<Fields[K][\"type\"]>;\n\t},\n\tFields\n>;\n\ntype AddOptionalFields<\n\tT extends Record<string, any>,\n\tFields extends Record<keyof T, DBFieldAttribute>,\n> = {\n\t// Required fields: required === true\n\t[K in keyof T as Fields[K] extends { required: true } ? K : never]: T[K];\n} & {\n\t// Optional fields: required !== true\n\t[K in keyof T as Fields[K] extends { required: true } ? never : K]?: T[K];\n};\n\n/**\n * Infer the additional fields from the plugin options.\n * For example, you can infer the additional fields of the org plugin's organization schema like this:\n * ```ts\n * type AdditionalFields = InferAdditionalFieldsFromPluginOptions<\"organization\", OrganizationOptions>\n * ```\n *\n * @param isClientSide - When `true` (default), filters out `input: false` fields (clients can't send these).\n *   When `false`, includes all fields (for internal/server-side use).\n */\nexport type InferAdditionalFieldsFromPluginOptions<\n\tSchemaName extends string,\n\tOptions extends {\n\t\tschema?:\n\t\t\t| {\n\t\t\t\t\t[key in SchemaName]?: {\n\t\t\t\t\t\tadditionalFields?: Record<string, DBFieldAttribute>;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t},\n\tisClientSide extends boolean = true,\n> = Options[\"schema\"] extends {\n\t[key in SchemaName]?: {\n\t\tadditionalFields: infer Field extends Record<string, DBFieldAttribute>;\n\t};\n}\n\t? isClientSide extends true\n\t\t? FieldAttributeToObject<RemoveFieldsWithInputFalse<Field>>\n\t\t: FieldAttributeToObject<Field>\n\t: {};\n\ntype RemoveFieldsWithInputFalse<T extends Record<string, DBFieldAttribute>> = {\n\t[K in keyof T as T[K][\"input\"] extends false ? never : K]: T[K];\n};\n\nexport type RemoveFieldsWithReturnedFalse<\n\tT extends Record<string, DBFieldAttribute>,\n> = {\n\t[K in keyof T as T[K][\"returned\"] extends false ? never : K]: T[K];\n};\n\ntype InferFieldInput<T extends DBFieldAttribute> = InferValueType<T[\"type\"]>;\n\nexport type PluginFieldAttribute = Omit<\n\tDBFieldAttribute,\n\t\"transform\" | \"defaultValue\" | \"hashValue\"\n>;\n\nexport type InferFieldsFromPlugins<\n\tOptions extends BetterAuthOptions,\n\tKey extends string,\n\tFormat extends \"output\" | \"input\",\n> = Options[\"plugins\"] extends []\n\t? {}\n\t: Options[\"plugins\"] extends Array<infer T>\n\t\t? T extends {\n\t\t\t\tschema: {\n\t\t\t\t\t[key in Key]: {\n\t\t\t\t\t\tfields: infer Field;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t\t? Format extends \"output\"\n\t\t\t\t? InferFieldsOutput<Field>\n\t\t\t\t: InferFieldsInput<Field>\n\t\t\t: {}\n\t\t: {};\n\nexport type InferFieldsFromOptions<\n\tOptions extends BetterAuthOptions,\n\tKey extends \"session\" | \"user\",\n\tFormat extends \"output\" | \"input\",\n> = Options[Key] extends {\n\tadditionalFields: infer Field;\n}\n\t? Format extends \"output\"\n\t\t? InferFieldsOutput<Field>\n\t\t: InferFieldsInput<Field>\n\t: {};\n"],"names":[],"mappings":";;;;;AAOA,MAAa,uBAAA,CAIZ,MACA,WACI;IACJ,OAAO;QACN;QACA,GAAG,MAAA;KACH"}},
    {"offset": {"line": 1108, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/field-converter.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/field-converter.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\n\nexport function convertToDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T,\n) {\n\tconst result: Record<string, any> = values.id\n\t\t? {\n\t\t\t\tid: values.id,\n\t\t\t}\n\t\t: {};\n\tfor (const key in fields) {\n\t\tconst field = fields[key]!;\n\t\tconst value = values[key];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult[field.fieldName || key] = value;\n\t}\n\treturn result as T;\n}\n\nexport function convertFromDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T | null,\n) {\n\tif (!values) {\n\t\treturn null;\n\t}\n\tconst result: Record<string, any> = {\n\t\tid: values.id,\n\t};\n\tfor (const [key, value] of Object.entries(fields)) {\n\t\tresult[key] = values[value.fieldName || key];\n\t}\n\treturn result as T;\n}\n"],"names":["result: Record<string, any>"],"mappings":";;;;;;;AAEA,SAAgB,YACf,MAAA,EACA,MAAA,EACC;IACD,MAAMA,SAA8B,OAAO,EAAA,GACxC;QACA,IAAI,OAAO,EAAA;IAAA,CACX,GACA,CAAA,CAAE;IACL,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,UAAU,KAAA,EACb,CAAA;QAED,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA,GAAO;;IAElC,OAAO;;AAGR,SAAgB,cACf,MAAA,EACA,MAAA,EACC;IACD,IAAI,CAAC,OACJ,CAAA,OAAO;IAER,MAAMA,SAA8B;QACnC,IAAI,OAAO,EAAA;IAAA,CACX;IACD,KAAK,MAAM,CAAC,KAAK,MAAA,IAAU,OAAO,OAAA,CAAQ,OAAO,CAChD,MAAA,CAAO,IAAA,GAAO,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA;IAEzC,OAAO"}},
    {"offset": {"line": 1141, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/with-hooks.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/with-hooks.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n} from \"@better-auth/core/context\";\nimport type { BaseModelNames } from \"@better-auth/core/db\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\n\nexport function getWithHooks(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: BetterAuthOptions;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t},\n) {\n\tconst hooks = ctx.hooks;\n\tasync function createWithHooks<T extends Record<string, any>>(\n\t\tdata: T,\n\t\tmodel: BaseModelNames,\n\t\tcustomCreateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(actualData as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customCreated = customCreateFn\n\t\t\t? await customCreateFn.fn(actualData)\n\t\t\t: null;\n\t\tconst created =\n\t\t\t!customCreateFn || customCreateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).create<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: actualData as any,\n\t\t\t\t\t\tforceAllowId: true,\n\t\t\t\t\t})\n\t\t\t\t: customCreated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(created as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tasync function updateWithHooks<T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).update<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\tasync function updateManyWithHooks<_T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\tasync function deleteWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entityToDelete: T | null = null;\n\n\t\ttry {\n\t\t\tconst entities = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tentityToDelete = entities[0] || null;\n\t\t} catch {\n\t\t\t// If we can't find the entity, we'll still proceed with deletion\n\t\t}\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entityToDelete as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).delete({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entityToDelete as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\tasync function deleteManyWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entitiesToDelete: T[] = [];\n\n\t\ttry {\n\t\t\tentitiesToDelete = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t});\n\t\t} catch {\n\t\t\t// If we can't find the entities, we'll still proceed with deletion\n\t\t}\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entity as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entity as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\treturn {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t};\n}\n"],"names":["entityToDelete: T | null","entitiesToDelete: T[]"],"mappings":"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"}},
    {"offset": {"line": 1297, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/internal-adapter.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/internal-adapter.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tInternalAdapter,\n} from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n\trunWithTransaction,\n} from \"@better-auth/core/context\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { generateId, safeJSONParse } from \"@better-auth/core/utils\";\nimport type { Account, Session, User, Verification } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { getIp } from \"../utils/get-request-ip\";\nimport {\n\tparseSessionInput,\n\tparseSessionOutput,\n\tparseUserOutput,\n} from \"./schema\";\nimport { getWithHooks } from \"./with-hooks\";\n\nexport const createInternalAdapter = (\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: Omit<BetterAuthOptions, \"logger\">;\n\t\tlogger: InternalLogger;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t\tgenerateId: AuthContext[\"generateId\"];\n\t},\n): InternalAdapter => {\n\tconst logger = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7; // 7 days\n\tconst {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t} = getWithHooks(adapter, ctx);\n\n\tasync function refreshUserSessions(user: User) {\n\t\tif (!secondaryStorage) return;\n\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\n\t\tconst now = Date.now();\n\t\tconst list =\n\t\t\tsafeJSONParse<{ token: string; expiresAt: number }[]>(listRaw) || [];\n\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\n\t\tawait Promise.all(\n\t\t\tvalidSessions.map(async ({ token }) => {\n\t\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\t\tif (!cached) return;\n\t\t\t\tconst parsed = safeJSONParse<{ session: Session; user: User }>(cached);\n\t\t\t\tif (!parsed) return;\n\n\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\tMath.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1000,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\ttoken,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tsession: parsed.session,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t}),\n\t\t\t\t\tMath.floor(sessionTTL),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\tcreateOAuthUser: async (\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">,\n\t\t\taccount: Omit<Account, \"userId\" | \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t...user,\n\t\t\t\t\t},\n\t\t\t\t\t\"user\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser!.id,\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t},\n\t\t\t\t\t\"account\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: createdAccount,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async <T>(\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\" | \"emailVerified\"> &\n\t\t\t\tPartial<User> &\n\t\t\t\tRecord<string, any>,\n\t\t) => {\n\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...user,\n\t\t\t\t\temail: user.email?.toLowerCase(),\n\t\t\t\t},\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\treturn createdUser as T & User;\n\t\t},\n\t\tcreateAccount: async <T extends Record<string, any>>(\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account> &\n\t\t\t\tT,\n\t\t) => {\n\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn createdAccount as T & Account;\n\t\t},\n\t\tlistSessions: async (userId: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t);\n\t\t\t\tif (!currentList) return [];\n\n\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tconst seenTokens = new Set<string>();\n\t\t\t\tconst sessions: Session[] = [];\n\n\t\t\t\tfor (const { token, expiresAt } of list) {\n\t\t\t\t\tif (expiresAt <= now || seenTokens.has(token)) continue;\n\t\t\t\t\tseenTokens.add(token);\n\n\t\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\t\tif (!data) continue;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst parsed = (\n\t\t\t\t\t\t\ttypeof data === \"string\" ? JSON.parse(data) : data\n\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (!parsed?.session) continue;\n\n\t\t\t\t\t\tsessions.push(\n\t\t\t\t\t\t\tparseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(parsed.session.expiresAt),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Session>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn sessions;\n\t\t},\n\t\tlistUsers: async (\n\t\t\tlimit?: number | undefined,\n\t\t\toffset?: number | undefined,\n\t\t\tsortBy?:\n\t\t\t\t| {\n\t\t\t\t\t\tfield: string;\n\t\t\t\t\t\tdirection: \"asc\" | \"desc\";\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\twhere?: Where[] | undefined,\n\t\t) => {\n\t\t\tconst users = await (await getCurrentAdapter(adapter)).findMany<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere,\n\t\t\t});\n\t\t\treturn users;\n\t\t},\n\t\tcountTotalUsers: async (where?: Where[] | undefined) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere,\n\t\t\t});\n\t\t\tif (typeof total === \"string\") {\n\t\t\t\treturn parseInt(total);\n\t\t\t}\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId: string) => {\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"session\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tcreateSession: async (\n\t\t\tuserId: string,\n\t\t\tdontRememberMe?: boolean | undefined,\n\t\t\toverride?: (Partial<Session> & Record<string, any>) | undefined,\n\t\t\toverrideAll?: boolean | undefined,\n\t\t) => {\n\t\t\tconst ctx = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx?.headers || ctx?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\t//we're parsing default values for session additional fields\n\t\t\tconst defaultAdditionalFields = parseSessionInput(\n\t\t\t\tctx?.context.options ?? options,\n\t\t\t\t{},\n\t\t\t);\n\t\t\tconst data: Omit<Session, \"id\"> = {\n\t\t\t\tipAddress:\n\t\t\t\t\tctx?.request || ctx?.headers\n\t\t\t\t\t\t? getIp(ctx?.request || ctx?.headers!, ctx?.context.options) || \"\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\t/**\n\t\t\t\t * If the user doesn't want to be remembered\n\t\t\t\t * set the session to expire in 1 day.\n\t\t\t\t * The cookie will be set to expire at the end of the session\n\t\t\t\t */\n\t\t\t\texpiresAt: dontRememberMe\n\t\t\t\t\t? getDate(60 * 60 * 24, \"sec\") // 1 day\n\t\t\t\t\t: getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...(overrideAll ? rest : {}),\n\t\t\t};\n\t\t\tconst res = await createWithHooks(\n\t\t\t\tdata,\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * store the session token for the user\n\t\t\t\t\t\t\t\t * so we can retrieve it later for listing sessions\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] = [];\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\t\t\t\tlist = list.filter(\n\t\t\t\t\t\t\t\t\t\t(session) =>\n\t\t\t\t\t\t\t\t\t\t\tsession.expiresAt > now && session.token !== data.token,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst sorted = [\n\t\t\t\t\t\t\t\t\t...list,\n\t\t\t\t\t\t\t\t\t{ token: data.token, expiresAt: data.expiresAt.getTime() },\n\t\t\t\t\t\t\t\t].sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\t\t\tconst furthestSessionExp =\n\t\t\t\t\t\t\t\t\tsorted.at(-1)?.expiresAt ?? data.expiresAt.getTime();\n\t\t\t\t\t\t\t\tconst furthestSessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (furthestSessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\tfurthestSessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst user = await adapter.findOne<User>({\n\t\t\t\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((data.expiresAt.getTime() - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tdata.token,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn sessionData;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn res as Session;\n\t\t},\n\t\tfindSession: async (\n\t\t\ttoken: string,\n\t\t): Promise<{\n\t\t\tsession: Session & Record<string, any>;\n\t\t\tuser: User & Record<string, any>;\n\t\t} | null> => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.options, {\n\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: token,\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\tconst parsedSession = parseSessionOutput(ctx.options, session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.options, user);\n\t\t\treturn {\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser,\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens: string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[] = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst s = (\n\t\t\t\t\t\t\t\ttypeof sessionStringified === \"string\"\n\t\t\t\t\t\t\t\t\t? JSON.parse(sessionStringified)\n\t\t\t\t\t\t\t\t\t: sessionStringified\n\t\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (!s?.session) continue;\n\t\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsessions.push(session);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// Skip invalid/corrupt session data\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\t\toperator: \"in\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user!,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (\n\t\t\tsessionToken: string,\n\t\t\tsession: Partial<Session> & Record<string, any>,\n\t\t) => {\n\t\t\tconst updatedSession = await updateWithHooks<Session>(\n\t\t\t\tsession,\n\t\t\t\t[{ field: \"token\", value: sessionToken }],\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tasync fn(data) {\n\t\t\t\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\t\t\tif (!currentSession) {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst parsedSession = safeJSONParse<{\n\t\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\t}>(currentSession);\n\t\t\t\t\t\t\t\tif (!parsedSession) return null;\n\n\t\t\t\t\t\t\t\tconst mergedSession = {\n\t\t\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.expiresAt ?? parsedSession.session.expiresAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(parsedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.updatedAt ?? parsedSession.session.updatedAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst updatedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.options,\n\t\t\t\t\t\t\t\t\tmergedSession,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\t\t\tconst expiresMs = new Date(updatedSession.expiresAt).getTime();\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((expiresMs - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tsessionToken,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\t\t\t\t\tuser: parsedSession.user,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst listKey = `active-sessions-${updatedSession.userId}`;\n\t\t\t\t\t\t\t\t\tconst listRaw = await secondaryStorage.get(listKey);\n\t\t\t\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] = listRaw\n\t\t\t\t\t\t\t\t\t\t? safeJSONParse(listRaw) || []\n\t\t\t\t\t\t\t\t\t\t: [];\n\n\t\t\t\t\t\t\t\t\tconst filtered = list\n\t\t\t\t\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t\t\t\t\t(s) => s.token !== sessionToken && s.expiresAt > now,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.concat([{ token: sessionToken, expiresAt: expiresMs }]);\n\n\t\t\t\t\t\t\t\t\tconst sorted = filtered.sort(\n\t\t\t\t\t\t\t\t\t\t(a, b) => a.expiresAt - b.expiresAt,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\t\t\t\tif (furthestSessionExp && furthestSessionExp > now) {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t\tlistKey,\n\t\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.delete(listKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn updatedSession;\n\t\t},\n\t\tdeleteSession: async (token: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\t// remove the session from the active sessions list\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } =\n\t\t\t\t\t\tsafeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\n\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\tconst filtered = list.filter(\n\t\t\t\t\t\t\t(session) => session.expiresAt > now && session.token !== token,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst sorted = filtered.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tfiltered.length > 0 &&\n\t\t\t\t\t\t\tfurthestSessionExp &&\n\t\t\t\t\t\t\tfurthestSessionExp > Date.now()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\tJSON.stringify(filtered),\n\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait secondaryStorage.delete(token);\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"token\", value: token }],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccounts: async (userId: string) => {\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccount: async (accountId: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: accountId }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens: string | string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t\tconst sessions = activeSession\n\t\t\t\t\t\t? safeJSONParse<{ token: string }[]>(activeSession)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\t\tawait secondaryStorage.delete(session.token);\n\t\t\t\t\t}\n\t\t\t\t\tawait secondaryStorage.delete(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const sessionToken of userIdOrSessionTokens) {\n\t\t\t\t\t\tconst session = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\tif (session) {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(sessionToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindOAuthUser: async (\n\t\t\temail: string,\n\t\t\taccountId: string,\n\t\t\tproviderId: string,\n\t\t) => {\n\t\t\t// we need to find account first to avoid missing user if the email changed with the provider for the same account\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<\n\t\t\t\tAccount & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (account) {\n\t\t\t\tif (account.user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: account.user,\n\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tif (user) {\n\t\t\t\t\tconst accounts = await (\n\t\t\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t\t\t).findMany<Account>({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tlinkedAccount: null,\n\t\t\t\t\t\taccounts: accounts || [],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (\n\t\t\temail: string,\n\t\t\toptions?: { includeAccounts: boolean } | undefined,\n\t\t) => {\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tUser & { account: Account[] | undefined }\n\t\t\t>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\t...(options?.includeAccounts ? { account: true } : {}),\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? [],\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId: string) => {\n\t\t\tif (!userId) return null;\n\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn user;\n\t\t},\n\t\tlinkAccount: async (\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\tconst _account = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn _account;\n\t\t},\n\t\tupdateUser: async (\n\t\t\tuserId: string,\n\t\t\tdata: Partial<User> & Record<string, any>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (\n\t\t\temail: string,\n\t\t\tdata: Partial<User & Record<string, any>>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId: string, password: string) => {\n\t\t\tawait updateManyWithHooks(\n\t\t\t\t{\n\t\t\t\t\tpassword,\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindAccounts: async (userId: string) => {\n\t\t\tconst accounts = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn accounts;\n\t\t},\n\t\tfindAccount: async (accountId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByProviderId: async (accountId: string, providerId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByUserId: async (userId: string) => {\n\t\t\tconst account = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn account;\n\t\t},\n\t\tupdateAccount: async (id: string, data: Partial<Account>) => {\n\t\t\tconst account = await updateWithHooks<Account>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tcreateVerificationValue: async (\n\t\t\tdata: Omit<Verification, \"createdAt\" | \"id\" | \"updatedAt\"> &\n\t\t\t\tPartial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification as Verification;\n\t\t},\n\t\tfindVerificationValue: async (identifier: string) => {\n\t\t\tconst verification = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Verification>({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\t\tvalue: identifier,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\",\n\t\t\t\t},\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\t\t\tvalue: new Date(),\n\t\t\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"verification\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lastVerification = verification[0];\n\t\t\treturn lastVerification as Verification | null;\n\t\t},\n\t\tdeleteVerificationValue: async (id: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"identifier\", value: identifier }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tupdateVerificationValue: async (\n\t\t\tid: string,\n\t\t\tdata: Partial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await updateWithHooks<Verification>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification;\n\t\t},\n\t};\n};\n"],"names":["list: { token: string; expiresAt: number }[]","sessions: Session[]","ctx","data: Omit<Session, \"id\">","sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[]","sessions","session","options"],"mappings":"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"}},
    {"offset": {"line": 1971, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/to-zod.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/to-zod.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport type { ZodType } from \"zod\";\nimport * as z from \"zod\";\n\nexport function toZodSchema<\n\tFields extends Record<string, DBFieldAttribute | never>,\n\tIsClientSide extends boolean,\n>({\n\tfields,\n\tisClientSide,\n}: {\n\tfields: Fields;\n\t/**\n\t * If true, then any fields that have `input: false` will be removed from the schema to prevent user input.\n\t */\n\tisClientSide: IsClientSide;\n}) {\n\tconst zodFields = Object.keys(fields).reduce((acc, key) => {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\treturn acc;\n\t\t}\n\t\tif (isClientSide && field.input === false) {\n\t\t\treturn acc;\n\t\t}\n\n\t\tlet schema: ZodType;\n\t\tif (field.type === \"json\") {\n\t\t\tschema = (z as any).json ? (z as any).json() : z.any();\n\t\t} else if (field.type === \"string[]\" || field.type === \"number[]\") {\n\t\t\tschema = z.array(field.type === \"string[]\" ? z.string() : z.number());\n\t\t} else if (Array.isArray(field.type)) {\n\t\t\tschema = z.any();\n\t\t} else {\n\t\t\tschema = z[field.type]();\n\t\t}\n\n\t\tif (field?.required === false) {\n\t\t\tschema = schema.optional();\n\t\t}\n\t\tif (!isClientSide && field?.returned === false) {\n\t\t\treturn acc;\n\t\t}\n\t\treturn {\n\t\t\t...acc,\n\t\t\t[key]: schema,\n\t\t};\n\t}, {});\n\tconst schema = z.object(zodFields);\n\treturn schema as z.ZodObject<\n\t\tRemoveNeverProps<{\n\t\t\t[key in keyof Fields]: FieldAttributeToSchema<Fields[key], IsClientSide>;\n\t\t}>,\n\t\tz.core.$strip\n\t>;\n}\n\nexport type FieldAttributeToSchema<\n\tField extends DBFieldAttribute | Record<string, never>,\n\t// if it's client side, then field attributes of `input` that are false should be removed\n\tisClientSide extends boolean = false,\n> = Field extends { type: any }\n\t? GetInput<isClientSide, Field, GetRequired<Field, GetType<Field>>>\n\t: Record<string, never>;\n\ntype GetType<F extends DBFieldAttribute> = F extends {\n\ttype: \"string\";\n}\n\t? z.ZodString\n\t: F extends { type: \"number\" }\n\t\t? z.ZodNumber\n\t\t: F extends { type: \"boolean\" }\n\t\t\t? z.ZodBoolean\n\t\t\t: F extends { type: \"date\" }\n\t\t\t\t? z.ZodDate\n\t\t\t\t: z.ZodAny;\n\ntype GetRequired<\n\tF extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = F extends {\n\trequired: true;\n}\n\t? Schema\n\t: z.ZodOptional<Schema>;\n\ntype GetInput<\n\tisClientSide extends boolean,\n\tField extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = Field extends {\n\tinput: false;\n}\n\t? isClientSide extends true\n\t\t? never\n\t\t: Schema\n\t: Schema;\n\ntype RemoveNeverProps<T> = {\n\t[K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\n"],"names":["schema: ZodType"],"mappings":";;;;;;;AAIA,SAAgB,YAGd,EACD,MAAA,EACA,YAAA,EAAA,EAOE;IACF,MAAM,YAAY,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAQ,KAAK,QAAQ;QAC1D,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,CAAC,MACJ,CAAA,OAAO;QAER,IAAI,gBAAgB,MAAM,KAAA,KAAU,MACnC,CAAA,OAAO;QAGR,IAAIA;QACJ,IAAI,MAAM,IAAA,KAAS,OAClB,CAAA,SAAU,+HAAU,IAAA,GAAQ,+HAAU,IAAA,EAAM,GAAG,+HAAE,GAAA,EAAK;iBAC5C,MAAM,IAAA,KAAS,cAAc,MAAM,IAAA,KAAS,WACtD,CAAA,SAAS,+HAAE,KAAA,CAAM,MAAM,IAAA,KAAS,aAAa,+HAAE,MAAA,EAAQ,GAAG,+HAAE,MAAA,EAAQ,CAAC;iBAC3D,MAAM,OAAA,CAAQ,MAAM,IAAA,CAAK,CACnC,CAAA,SAAS,+HAAE,GAAA,EAAK;aAEhB,SAAS,8HAAA,CAAE,MAAM,IAAA,CAAA,EAAO;QAGzB,IAAI,OAAO,aAAa,MACvB,CAAA,SAAS,OAAO,QAAA,EAAU;QAE3B,IAAI,CAAC,gBAAgB,OAAO,aAAa,MACxC,CAAA,OAAO;QAER,OAAO;YACN,GAAG,GAAA;aACF,IAAA,EAAM;SACP;OACC,CAAA,CAAE,CAAC;IAEN,OADe,+HAAE,MAAA,CAAO,UAAU"}},
    {"offset": {"line": 2003, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/get-schema.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/get-schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport { getAuthTables } from \".\";\n\nexport function getSchema(config: BetterAuthOptions) {\n\tconst tables = getAuthTables(config);\n\tconst schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t> = {};\n\tfor (const key in tables) {\n\t\tconst table = tables[key]!;\n\t\tconst fields = table.fields;\n\t\tconst actualFields: Record<string, DBFieldAttribute> = {};\n\t\tObject.entries(fields).forEach(([key, field]) => {\n\t\t\tactualFields[field.fieldName || key] = field;\n\t\t\tif (field.references) {\n\t\t\t\tconst refTable = tables[field.references.model];\n\t\t\t\tif (refTable) {\n\t\t\t\t\tactualFields[field.fieldName || key]!.references = {\n\t\t\t\t\t\t...field.references,\n\t\t\t\t\t\tmodel: refTable.modelName,\n\t\t\t\t\t\tfield: field.references.field,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (schema[table.modelName]) {\n\t\t\tschema[table.modelName]!.fields = {\n\t\t\t\t...schema[table.modelName]!.fields,\n\t\t\t\t...actualFields,\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\t\tschema[table.modelName] = {\n\t\t\tfields: actualFields,\n\t\t\torder: table.order || Infinity,\n\t\t};\n\t}\n\treturn schema;\n}\n"],"names":["schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t>","actualFields: Record<string, DBFieldAttribute>","key"],"mappings":";;;;;;;AAIA,SAAgB,UAAU,MAAA,EAA2B;IACpD,MAAM,SAAA,CAAA,GAAA,sLAAA,CAAA,aAAA,EAAuB,OAAO;IACpC,MAAMA,SAMF,CAAA,CAAE;IACN,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,SAAS,MAAM,MAAA;QACrB,MAAMC,eAAiD,CAAA,CAAE;QACzD,OAAO,OAAA,CAAQ,OAAO,CAAC,OAAA,CAAA,CAAS,CAACC,OAAK,MAAA,KAAW;YAChD,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,GAAO;YACvC,IAAI,MAAM,UAAA,EAAY;gBACrB,MAAM,WAAW,MAAA,CAAO,MAAM,UAAA,CAAW,KAAA,CAAA;gBACzC,IAAI,SACH,CAAA,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,CAAM,UAAA,GAAa;oBAClD,GAAG,MAAM,UAAA;oBACT,OAAO,SAAS,SAAA;oBAChB,OAAO,MAAM,UAAA,CAAW,KAAA;iBACxB;;UAGF;QACF,IAAI,MAAA,CAAO,MAAM,SAAA,CAAA,EAAY;YAC5B,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA,GAAS;gBACjC,GAAG,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA;gBAC5B,GAAG,YAAA;aACH;YACD;;QAED,MAAA,CAAO,MAAM,SAAA,CAAA,GAAa;YACzB,QAAQ;YACR,OAAO,MAAM,KAAA,IAAS;SACtB;;IAEF,OAAO"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/get-migration.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/get-migration.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute, DBFieldType } from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport {\n\tinitGetFieldName,\n\tinitGetModelName,\n} from \"@better-auth/core/db/adapter\";\nimport { createLogger } from \"@better-auth/core/env\";\nimport type {\n\tAlterTableBuilder,\n\tAlterTableColumnAlteringBuilder,\n\tColumnDataType,\n\tCreateIndexBuilder,\n\tCreateTableBuilder,\n\tKysely,\n\tRawBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport { createKyselyAdapter } from \"../adapters/kysely-adapter/dialect\";\nimport type { KyselyDatabaseType } from \"../adapters/kysely-adapter/types\";\nimport { getSchema } from \"./get-schema\";\n\nconst postgresMap = {\n\tstring: [\"character varying\", \"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"int4\",\n\t\t\"integer\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"numeric\",\n\t\t\"real\",\n\t\t\"double precision\",\n\t],\n\tboolean: [\"bool\", \"boolean\"],\n\tdate: [\"timestamptz\", \"timestamp\", \"date\"],\n\tjson: [\"json\", \"jsonb\"],\n};\nconst mysqlMap = {\n\tstring: [\"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"integer\",\n\t\t\"int\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"decimal\",\n\t\t\"float\",\n\t\t\"double\",\n\t],\n\tboolean: [\"boolean\", \"tinyint\"],\n\tdate: [\"timestamp\", \"datetime\", \"date\"],\n\tjson: [\"json\"],\n};\n\nconst sqliteMap = {\n\tstring: [\"TEXT\"],\n\tnumber: [\"INTEGER\", \"REAL\"],\n\tboolean: [\"INTEGER\", \"BOOLEAN\"], // 0 or 1\n\tdate: [\"DATE\", \"INTEGER\"],\n\tjson: [\"TEXT\"],\n};\n\nconst mssqlMap = {\n\tstring: [\"varchar\", \"nvarchar\", \"uniqueidentifier\"],\n\tnumber: [\"int\", \"bigint\", \"smallint\", \"decimal\", \"float\", \"double\"],\n\tboolean: [\"bit\", \"smallint\"],\n\tdate: [\"datetime2\", \"date\", \"datetime\"],\n\tjson: [\"varchar\", \"nvarchar\"],\n};\n\nconst map = {\n\tpostgres: postgresMap,\n\tmysql: mysqlMap,\n\tsqlite: sqliteMap,\n\tmssql: mssqlMap,\n};\n\nexport function matchType(\n\tcolumnDataType: string,\n\tfieldType: DBFieldType,\n\tdbType: KyselyDatabaseType,\n) {\n\tfunction normalize(type: string) {\n\t\treturn type.toLowerCase().split(\"(\")[0]!.trim();\n\t}\n\tif (fieldType === \"string[]\" || fieldType === \"number[]\") {\n\t\treturn columnDataType.toLowerCase().includes(\"json\");\n\t}\n\tconst types = map[dbType]!;\n\tconst expected = Array.isArray(fieldType)\n\t\t? types[\"string\"].map((t) => t.toLowerCase())\n\t\t: types[fieldType]!.map((t) => t.toLowerCase());\n\treturn expected.includes(normalize(columnDataType));\n}\n\n/**\n * Get the current PostgreSQL schema (search_path) for the database connection\n * Returns the first schema in the search_path, defaulting to 'public' if not found\n */\nasync function getPostgresSchema(db: Kysely<unknown>): Promise<string> {\n\ttry {\n\t\tconst result = await sql<{ search_path: string }>`SHOW search_path`.execute(\n\t\t\tdb,\n\t\t);\n\t\tif (result.rows[0]?.search_path) {\n\t\t\t// search_path can be a comma-separated list like \"$user, public\" or '\"$user\", public'\n\t\t\t// We want the first non-variable schema\n\t\t\tconst schemas = result.rows[0].search_path\n\t\t\t\t.split(\",\")\n\t\t\t\t.map((s) => s.trim())\n\t\t\t\t// Remove quotes and filter out variables like $user\n\t\t\t\t.map((s) => s.replace(/^[\"']|[\"']$/g, \"\"))\n\t\t\t\t.filter((s) => !s.startsWith(\"$\"));\n\t\t\treturn schemas[0] || \"public\";\n\t\t}\n\t} catch {\n\t\t// If query fails, fall back to public schema\n\t}\n\treturn \"public\";\n}\n\nexport async function getMigrations(config: BetterAuthOptions) {\n\tconst betterAuthSchema = getSchema(config);\n\tconst logger = createLogger(config.logger);\n\n\tlet { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);\n\n\tif (!dbType) {\n\t\tlogger.warn(\n\t\t\t\"Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.\",\n\t\t);\n\t\tdbType = \"sqlite\";\n\t}\n\n\tif (!db) {\n\t\tlogger.error(\n\t\t\t\"Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n\n\t// For PostgreSQL, detect and log the current schema being used\n\tlet currentSchema = \"public\";\n\tif (dbType === \"postgres\") {\n\t\tcurrentSchema = await getPostgresSchema(db);\n\t\tlogger.debug(\n\t\t\t`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`,\n\t\t);\n\n\t\t// Verify the schema exists\n\t\ttry {\n\t\t\tconst schemaCheck = await sql<{ schema_name: string }>`\n\t\t\t\tSELECT schema_name \n\t\t\t\tFROM information_schema.schemata \n\t\t\t\tWHERE schema_name = ${currentSchema}\n\t\t\t`.execute(db);\n\n\t\t\tif (!schemaCheck.rows[0]) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.debug(\n\t\t\t\t`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst allTableMetadata = await db.introspection.getTables();\n\n\t// For PostgreSQL, filter tables to only those in the target schema\n\tlet tableMetadata = allTableMetadata;\n\tif (dbType === \"postgres\") {\n\t\t// Get tables with their schema information\n\t\ttry {\n\t\t\tconst tablesInSchema = await sql<{\n\t\t\t\ttable_name: string;\n\t\t\t}>`\n\t\t\t\tSELECT table_name \n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = ${currentSchema}\n\t\t\t\tAND table_type = 'BASE TABLE'\n\t\t\t`.execute(db);\n\n\t\t\tconst tableNamesInSchema = new Set(\n\t\t\t\ttablesInSchema.rows.map((row) => row.table_name),\n\t\t\t);\n\n\t\t\t// Filter to only tables that exist in the target schema\n\t\t\ttableMetadata = allTableMetadata.filter(\n\t\t\t\t(table) =>\n\t\t\t\t\ttable.schema === currentSchema && tableNamesInSchema.has(table.name),\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(\", \") || \"(none)\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.warn(\n\t\t\t\t`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t\t// Fall back to using all tables if schema filtering fails\n\t\t}\n\t}\n\tconst toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\tconst toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\n\tfor (const [key, value] of Object.entries(betterAuthSchema)) {\n\t\tconst table = tableMetadata.find((t) => t.name === key);\n\t\tif (!table) {\n\t\t\tconst tIndex = toBeCreated.findIndex((t) => t.table === key);\n\t\t\tconst tableData = {\n\t\t\t\ttable: key,\n\t\t\t\tfields: value.fields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t};\n\n\t\t\tconst insertIndex = toBeCreated.findIndex(\n\t\t\t\t(t) => (t.order || Infinity) > tableData.order,\n\t\t\t);\n\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tif (tIndex === -1) {\n\t\t\t\t\ttoBeCreated.push(tableData);\n\t\t\t\t} else {\n\t\t\t\t\ttoBeCreated[tIndex]!.fields = {\n\t\t\t\t\t\t...toBeCreated[tIndex]!.fields,\n\t\t\t\t\t\t...value.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoBeCreated.splice(insertIndex, 0, tableData);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tconst toBeAddedFields: Record<string, DBFieldAttribute> = {};\n\t\tfor (const [fieldName, field] of Object.entries(value.fields)) {\n\t\t\tconst column = table.columns.find((c) => c.name === fieldName);\n\t\t\tif (!column) {\n\t\t\t\ttoBeAddedFields[fieldName] = field;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (matchType(column.dataType, field.type, dbType)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(toBeAddedFields).length > 0) {\n\t\t\ttoBeAdded.push({\n\t\t\t\ttable: key,\n\t\t\t\tfields: toBeAddedFields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t});\n\t\t}\n\t}\n\n\tconst migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[] = [];\n\n\tconst useUUIDs = config.advanced?.database?.generateId === \"uuid\";\n\tconst useNumberId =\n\t\tconfig.advanced?.database?.useNumberId ||\n\t\tconfig.advanced?.database?.generateId === \"serial\";\n\n\tfunction getType(field: DBFieldAttribute, fieldName: string) {\n\t\tconst type = field.type;\n\t\tconst provider = dbType || \"sqlite\";\n\t\ttype StringOnlyUnion<T> = T extends string ? T : never;\n\t\tconst typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t> = {\n\t\t\tstring: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"text\",\n\t\t\t\tmysql: field.unique\n\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t: field.references\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: field.sortable\n\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t: field.index\n\t\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t\t: \"text\",\n\t\t\t\tmssql:\n\t\t\t\t\tfield.unique || field.sortable\n\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t: field.references\n\t\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t\t: // mssql deprecated `text`, and the alternative is `varchar(max)`.\n\t\t\t\t\t\t\t\t// Kysely type interface doesn't support `text`, so we set this to `varchar(8000)` as\n\t\t\t\t\t\t\t\t// that's the max length for `varchar`\n\t\t\t\t\t\t\t\t\"varchar(8000)\",\n\t\t\t},\n\t\t\tboolean: {\n\t\t\t\tsqlite: \"integer\",\n\t\t\t\tpostgres: \"boolean\",\n\t\t\t\tmysql: \"boolean\",\n\t\t\t\tmssql: \"smallint\",\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tsqlite: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tpostgres: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmysql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmssql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t},\n\t\t\tdate: {\n\t\t\t\tsqlite: \"date\",\n\t\t\t\tpostgres: \"timestamptz\",\n\t\t\t\tmysql: \"timestamp(3)\",\n\t\t\t\tmssql: sql`datetime2(3)`,\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\tid: {\n\t\t\t\tpostgres: useNumberId\n\t\t\t\t\t? sql`integer GENERATED BY DEFAULT AS IDENTITY`\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"uuid\"\n\t\t\t\t\t\t: \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\tforeignKeyId: {\n\t\t\t\tpostgres: useNumberId ? \"integer\" : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\" /* Should be using `UNIQUEIDENTIFIER` but Kysely doesn't support it */\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\t\"string[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\t\"number[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t} as const;\n\t\tif (fieldName === \"id\" || field.references?.field === \"id\") {\n\t\t\tif (fieldName === \"id\") {\n\t\t\t\treturn typeMap.id[provider];\n\t\t\t}\n\t\t\treturn typeMap.foreignKeyId[provider];\n\t\t}\n\t\tif (Array.isArray(type)) {\n\t\t\treturn \"text\";\n\t\t}\n\t\tif (!(type in typeMap)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported field type '${String(type)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: \"string\") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`,\n\t\t\t);\n\t\t}\n\t\treturn typeMap[type][provider];\n\t}\n\tconst getModelName = initGetModelName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\tconst getFieldName = initGetFieldName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\n\t// Helper function to safely resolve model and field names, falling back to\n\t// user-supplied strings for external tables not in the BetterAuth schema\n\tfunction getReferencePath(model: string, field: string): string {\n\t\ttry {\n\t\t\tconst modelName = getModelName(model);\n\t\t\tconst fieldName = getFieldName({ model, field });\n\t\t\treturn `${modelName}.${fieldName}`;\n\t\t} catch {\n\t\t\t// If resolution fails (external table), fall back to user-supplied references\n\t\t\treturn `${model}.${field}`;\n\t\t}\n\t}\n\n\tif (toBeAdded.length) {\n\t\tfor (const table of toBeAdded) {\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tconst builder = db.schema.alterTable(table.table);\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst index = db.schema\n\t\t\t\t\t\t.alterTable(table.table)\n\t\t\t\t\t\t.addIndex(`${table.table}_${fieldName}_idx`);\n\t\t\t\t\tmigrations.push(index);\n\t\t\t\t}\n\n\t\t\t\tconst built = builder.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\t\t\t\tmigrations.push(built);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst toBeIndexed: CreateIndexBuilder[] = [];\n\n\tif (config.advanced?.database?.useNumberId) {\n\t\tlogger.warn(\n\t\t\t\"`useNumberId` is deprecated. Please use `generateId` with `serial` instead.\",\n\t\t);\n\t}\n\n\tif (toBeCreated.length) {\n\t\tfor (const table of toBeCreated) {\n\t\t\tconst idType = getType({ type: useNumberId ? \"number\" : \"string\" }, \"id\");\n\t\t\tlet dbT = db.schema\n\t\t\t\t.createTable(table.table)\n\t\t\t\t.addColumn(\"id\", idType, (col) => {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\t// Identity column is already specified in the type via sql template tag\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"sqlite\") {\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"mssql\") {\n\t\t\t\t\t\t\treturn col.identity().primaryKey().notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.autoIncrement().primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\tif (useUUIDs) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\treturn col\n\t\t\t\t\t\t\t\t.primaryKey()\n\t\t\t\t\t\t\t\t.defaultTo(sql`pg_catalog.gen_random_uuid()`)\n\t\t\t\t\t\t\t\t.notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t});\n\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tdbT = dbT.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst builder = db.schema\n\t\t\t\t\t\t.createIndex(\n\t\t\t\t\t\t\t`${table.table}_${fieldName}_${field.unique ? \"uidx\" : \"idx\"}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.on(table.table)\n\t\t\t\t\t\t.columns([fieldName]);\n\t\t\t\t\ttoBeIndexed.push(field.unique ? builder.unique() : builder);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmigrations.push(dbT);\n\t\t}\n\t}\n\n\t// instead of adding the index straight to `migrations`,\n\t// we do this at the end so that indexes are created after the table is created\n\tif (toBeIndexed.length) {\n\t\tfor (const index of toBeIndexed) {\n\t\t\tmigrations.push(index);\n\t\t}\n\t}\n\n\tasync function runMigrations() {\n\t\tfor (const migration of migrations) {\n\t\t\tawait migration.execute();\n\t\t}\n\t}\n\tasync function compileMigrations() {\n\t\tconst compiled = migrations.map((m) => m.compile().sql);\n\t\treturn compiled.join(\";\\n\\n\") + \";\";\n\t}\n\treturn { toBeCreated, toBeAdded, runMigrations, compileMigrations };\n}\n"],"names":["logger","toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAddedFields: Record<string, DBFieldAttribute>","migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[]","typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t>","toBeIndexed: CreateIndexBuilder[]"],"mappings":"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"}},
    {"offset": {"line": 2437, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/db/index.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/db/index.ts"],"sourcesContent":["export * from \"@better-auth/core/db\";\nexport * from \"./adapter-base\";\nexport * from \"./adapter-kysely\";\nexport * from \"./field\";\nexport * from \"./field-converter\";\nexport * from \"./get-migration\";\nexport * from \"./get-schema\";\nexport * from \"./internal-adapter\";\nexport * from \"./schema\";\nexport * from \"./to-zod\";\nexport * from \"./with-hooks\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2497, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/cookies/session-store.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/cookies/session-store.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport type { Account } from \"@better-auth/core/db\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport type { CookieOptions } from \"better-call\";\nimport * as z from \"zod\";\nimport { symmetricDecodeJWT, symmetricEncodeJWT } from \"../crypto\";\n\n// Cookie size constants based on browser limits\nconst ALLOWED_COOKIE_SIZE = 4096;\n// Estimated size of an empty cookie with all attributes\n// (name, path, domain, secure, httpOnly, sameSite, expires/maxAge)\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 200;\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;\n\ninterface Cookie {\n\tname: string;\n\tvalue: string;\n\tattributes: CookieOptions;\n}\n\ntype Chunks = Record<string, string>;\n\n/**\n * Parse cookies from the request headers\n */\nfunction parseCookiesFromContext(\n\tctx: GenericEndpointContext,\n): Record<string, string> {\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn {};\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\treturn cookies;\n}\n\n/**\n * Extract the chunk index from a cookie name\n */\nfunction getChunkIndex(cookieName: string): number {\n\tconst parts = cookieName.split(\".\");\n\tconst lastPart = parts[parts.length - 1];\n\tconst index = parseInt(lastPart || \"0\", 10);\n\treturn isNaN(index) ? 0 : index;\n}\n\n/**\n * Read all existing chunks from cookies\n */\nfunction readExistingChunks(\n\tcookieName: string,\n\tctx: GenericEndpointContext,\n): Chunks {\n\tconst chunks: Chunks = {};\n\tconst cookies = parseCookiesFromContext(ctx);\n\n\tfor (const [name, value] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName)) {\n\t\t\tchunks[name] = value;\n\t\t}\n\t}\n\n\treturn chunks;\n}\n\n/**\n * Get the full session data by joining all chunks\n */\nfunction joinChunks(chunks: Chunks): string {\n\tconst sortedKeys = Object.keys(chunks).sort((a, b) => {\n\t\tconst aIndex = getChunkIndex(a);\n\t\tconst bIndex = getChunkIndex(b);\n\t\treturn aIndex - bIndex;\n\t});\n\n\treturn sortedKeys.map((key) => chunks[key]).join(\"\");\n}\n\n/**\n * Split a cookie value into chunks if needed\n */\nfunction chunkCookie(\n\tstoreName: string,\n\tcookie: Cookie,\n\tchunks: Chunks,\n\tlogger: InternalLogger,\n): Cookie[] {\n\tconst chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);\n\n\tif (chunkCount === 1) {\n\t\tchunks[cookie.name] = cookie.value;\n\t\treturn [cookie];\n\t}\n\n\tconst cookies: Cookie[] = [];\n\tfor (let i = 0; i < chunkCount; i++) {\n\t\tconst name = `${cookie.name}.${i}`;\n\t\tconst start = i * CHUNK_SIZE;\n\t\tconst value = cookie.value.substring(start, start + CHUNK_SIZE);\n\t\tcookies.push({ ...cookie, name, value });\n\t\tchunks[name] = value;\n\t}\n\n\tlogger.debug(`CHUNKING_${storeName.toUpperCase()}_COOKIE`, {\n\t\tmessage: `${storeName} cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n\t\temptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n\t\tvalueSize: cookie.value.length,\n\t\tchunkCount,\n\t\tchunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n\t});\n\n\treturn cookies;\n}\n\n/**\n * Get all cookies that should be cleaned (removed)\n */\nfunction getCleanCookies(\n\tchunks: Chunks,\n\tcookieOptions: CookieOptions,\n): Record<string, Cookie> {\n\tconst cleanedChunks: Record<string, Cookie> = {};\n\tfor (const name in chunks) {\n\t\tcleanedChunks[name] = {\n\t\t\tname,\n\t\t\tvalue: \"\",\n\t\t\tattributes: { ...cookieOptions, maxAge: 0 },\n\t\t};\n\t}\n\treturn cleanedChunks;\n}\n\n/**\n * Create a session store for handling cookie chunking.\n * When session data exceeds 4KB, it automatically splits it into multiple cookies.\n *\n * Based on next-auth's SessionStore implementation.\n * @see https://github.com/nextauthjs/next-auth/blob/27b2519b84b8eb9cf053775dea29d577d2aa0098/packages/next-auth/src/core/lib/cookie.ts\n */\nconst storeFactory =\n\t(storeName: string) =>\n\t(\n\t\tcookieName: string,\n\t\tcookieOptions: CookieOptions,\n\t\tctx: GenericEndpointContext,\n\t) => {\n\t\tconst chunks = readExistingChunks(cookieName, ctx);\n\t\tconst logger = ctx.context.logger;\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Get the full session data by joining all chunks\n\t\t\t */\n\t\t\tgetValue(): string {\n\t\t\t\treturn joinChunks(chunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Check if there are existing chunks\n\t\t\t */\n\t\t\thasChunks(): boolean {\n\t\t\t\treturn Object.keys(chunks).length > 0;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Chunk a cookie value and return all cookies to set (including cleanup cookies)\n\t\t\t */\n\t\t\tchunk(value: string, options?: Partial<CookieOptions>): Cookie[] {\n\t\t\t\t// Start by cleaning all existing chunks\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\tconst cookies: Record<string, Cookie> = cleanedChunks;\n\n\t\t\t\t// Create new chunks\n\t\t\t\tconst chunked = chunkCookie(\n\t\t\t\t\tstoreName,\n\t\t\t\t\t{\n\t\t\t\t\t\tname: cookieName,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tattributes: { ...cookieOptions, ...options },\n\t\t\t\t\t},\n\t\t\t\t\tchunks,\n\t\t\t\t\tlogger,\n\t\t\t\t);\n\n\t\t\t\t// Update with new chunks\n\t\t\t\tfor (const chunk of chunked) {\n\t\t\t\t\tcookies[chunk.name] = chunk;\n\t\t\t\t}\n\n\t\t\t\treturn Object.values(cookies);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Get cookies to clean up all chunks\n\t\t\t */\n\t\t\tclean(): Cookie[] {\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\treturn Object.values(cleanedChunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Set all cookies in the context\n\t\t\t */\n\t\t\tsetCookies(cookies: Cookie[]): void {\n\t\t\t\tfor (const cookie of cookies) {\n\t\t\t\t\tctx.setCookie(cookie.name, cookie.value, cookie.attributes);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t};\n\nexport const createSessionStore = storeFactory(\"Session\");\nexport const createAccountStore = storeFactory(\"Account\");\n\nexport function getChunkedCookie(\n\tctx: GenericEndpointContext,\n\tcookieName: string,\n): string | null {\n\tconst value = ctx.getCookie(cookieName);\n\tif (value) {\n\t\treturn value;\n\t}\n\n\tconst chunks: Array<{ index: number; value: string }> = [];\n\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn null;\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\tfor (const [name, val] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName + \".\")) {\n\t\t\tconst parts = name.split(\".\");\n\t\t\tconst indexStr = parts.at(-1);\n\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\tif (!isNaN(index)) {\n\t\t\t\tchunks.push({ index, value: val });\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chunks.length > 0) {\n\t\tchunks.sort((a, b) => a.index - b.index);\n\t\treturn chunks.map((c) => c.value).join(\"\");\n\t}\n\n\treturn null;\n}\n\nexport async function setAccountCookie(\n\tc: GenericEndpointContext,\n\taccountData: Record<string, any>,\n) {\n\tconst accountDataCookie = c.context.authCookies.accountData;\n\tconst options = {\n\t\tmaxAge: 60 * 5,\n\t\t...accountDataCookie.attributes,\n\t};\n\tconst data = await symmetricEncodeJWT(\n\t\taccountData,\n\t\tc.context.secret,\n\t\t\"better-auth-account\",\n\t\toptions.maxAge,\n\t);\n\n\tif (data.length > ALLOWED_COOKIE_SIZE) {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\n\t\tconst cookies = accountStore.chunk(data, options);\n\t\taccountStore.setCookies(cookies);\n\t} else {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\t\tif (accountStore.hasChunks()) {\n\t\t\tconst cleanCookies = accountStore.clean();\n\t\t\taccountStore.setCookies(cleanCookies);\n\t\t}\n\t\tc.setCookie(accountDataCookie.name, data, options);\n\t}\n}\n\nexport async function getAccountCookie(c: GenericEndpointContext) {\n\tconst accountCookie = getChunkedCookie(\n\t\tc,\n\t\tc.context.authCookies.accountData.name,\n\t);\n\tif (accountCookie) {\n\t\tconst accountData = safeJSONParse<Account>(\n\t\t\tawait symmetricDecodeJWT(\n\t\t\t\taccountCookie,\n\t\t\t\tc.context.secret,\n\t\t\t\t\"better-auth-account\",\n\t\t\t),\n\t\t);\n\t\tif (accountData) {\n\t\t\treturn accountData;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport const getSessionQuerySchema = z.optional(\n\tz.object({\n\t\t/**\n\t\t * If cookie cache is enabled, it will disable the cache\n\t\t * and fetch the session from the database\n\t\t */\n\t\tdisableCookieCache: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription: \"Disable cookie cache and fetch session from database\",\n\t\t\t})\n\t\t\t.optional(),\n\t\tdisableRefresh: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"Disable session refresh. Useful for checking session status, without updating the session\",\n\t\t\t})\n\t\t\t.optional(),\n\t}),\n);\n"],"names":["cookies: Record<string, string>","chunks: Chunks","cookies: Cookie[]","cleanedChunks: Record<string, Cookie>","cookies: Record<string, Cookie>","chunks: Array<{ index: number; value: string }>"],"mappings":"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"}},
    {"offset": {"line": 2717, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/cookies/cookie-utils.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/cookies/cookie-utils.ts"],"sourcesContent":["interface CookieAttributes {\n\tvalue: string;\n\t\"max-age\"?: number | undefined;\n\texpires?: Date | undefined;\n\tdomain?: string | undefined;\n\tpath?: string | undefined;\n\tsecure?: boolean | undefined;\n\thttponly?: boolean | undefined;\n\tsamesite?: (\"strict\" | \"lax\" | \"none\") | undefined;\n\t[key: string]: any;\n}\n\nexport const SECURE_COOKIE_PREFIX = \"__Secure-\";\nexport const HOST_COOKIE_PREFIX = \"__Host-\";\n\n/**\n * Remove __Secure- or __Host- prefix from cookie name.\n */\nexport function stripSecureCookiePrefix(cookieName: string): string {\n\tif (cookieName.startsWith(SECURE_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(SECURE_COOKIE_PREFIX.length);\n\t}\n\tif (cookieName.startsWith(HOST_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(HOST_COOKIE_PREFIX.length);\n\t}\n\treturn cookieName;\n}\n\n/**\n * Split `Set-Cookie` header, handling commas in `Expires` dates.\n */\nexport function splitSetCookieHeader(setCookie: string): string[] {\n\tif (!setCookie) return [];\n\n\tconst result: string[] = [];\n\tlet current = \"\";\n\tlet i = 0;\n\n\twhile (i < setCookie.length) {\n\t\tconst c = setCookie[i];\n\n\t\tif (c === \",\") {\n\t\t\tconst lower = current.toLowerCase();\n\t\t\tif (lower.includes(\"expires=\") && !lower.includes(\"gmt\")) {\n\t\t\t\tcurrent += c;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tconst trimmed = current.trim();\n\t\t\t\tif (trimmed) {\n\t\t\t\t\tresult.push(trimmed);\n\t\t\t\t}\n\t\t\t\tcurrent = \"\";\n\t\t\t\ti++;\n\t\t\t\tif (i < setCookie.length && setCookie[i] === \" \") {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent += c;\n\t\ti++;\n\t}\n\n\tconst trimmed = current.trim();\n\tif (trimmed) {\n\t\tresult.push(trimmed);\n\t}\n\n\treturn result;\n}\n\nexport function parseSetCookieHeader(\n\tsetCookie: string,\n): Map<string, CookieAttributes> {\n\tconst cookies = new Map<string, CookieAttributes>();\n\tconst cookieArray = splitSetCookieHeader(setCookie);\n\n\tcookieArray.forEach((cookieString) => {\n\t\tconst parts = cookieString.split(\";\").map((part) => part.trim());\n\t\tconst [nameValue, ...attributes] = parts;\n\t\tconst [name, ...valueParts] = (nameValue || \"\").split(\"=\");\n\n\t\tconst value = valueParts.join(\"=\");\n\n\t\tif (!name || value === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrObj: CookieAttributes = { value };\n\n\t\tattributes.forEach((attribute) => {\n\t\t\tconst [attrName, ...attrValueParts] = attribute!.split(\"=\");\n\t\t\tconst attrValue = attrValueParts.join(\"=\");\n\n\t\t\tconst normalizedAttrName = attrName!.trim().toLowerCase();\n\n\t\t\tswitch (normalizedAttrName) {\n\t\t\t\tcase \"max-age\":\n\t\t\t\t\tattrObj[\"max-age\"] = attrValue\n\t\t\t\t\t\t? parseInt(attrValue.trim(), 10)\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"expires\":\n\t\t\t\t\tattrObj.expires = attrValue ? new Date(attrValue.trim()) : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"domain\":\n\t\t\t\t\tattrObj.domain = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"path\":\n\t\t\t\t\tattrObj.path = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"secure\":\n\t\t\t\t\tattrObj.secure = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"httponly\":\n\t\t\t\t\tattrObj.httponly = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"samesite\":\n\t\t\t\t\tattrObj.samesite = attrValue\n\t\t\t\t\t\t? (attrValue.trim().toLowerCase() as \"strict\" | \"lax\" | \"none\")\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Handle any other attributes\n\t\t\t\t\tattrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\tcookies.set(name, attrObj);\n\t});\n\n\treturn cookies;\n}\n\nexport function setCookieToHeader(headers: Headers) {\n\treturn (context: { response: Response }) => {\n\t\tconst setCookieHeader = context.response.headers.get(\"set-cookie\");\n\t\tif (!setCookieHeader) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cookieMap = new Map<string, string>();\n\n\t\tconst existingCookiesHeader = headers.get(\"cookie\") || \"\";\n\t\texistingCookiesHeader.split(\";\").forEach((cookie) => {\n\t\t\tconst [name, ...rest] = cookie!.trim().split(\"=\");\n\t\t\tif (name && rest.length > 0) {\n\t\t\t\tcookieMap.set(name, rest.join(\"=\"));\n\t\t\t}\n\t\t});\n\n\t\tconst cookies = parseSetCookieHeader(setCookieHeader);\n\t\tcookies.forEach((value, name) => {\n\t\t\tcookieMap.set(name, value.value);\n\t\t});\n\n\t\tconst updatedCookies = Array.from(cookieMap.entries())\n\t\t\t.map(([name, value]) => `${name}=${value}`)\n\t\t\t.join(\"; \");\n\t\theaders.set(\"cookie\", updatedCookies);\n\t};\n}\n"],"names":["result: string[]","trimmed","attrObj: CookieAttributes"],"mappings":"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"}},
    {"offset": {"line": 2838, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/cookies/index.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/cookies/index.ts"],"sourcesContent":["import type {\n\tBetterAuthCookie,\n\tBetterAuthCookies,\n\tBetterAuthOptions,\n\tGenericEndpointContext,\n} from \"@better-auth/core\";\nimport { env, isProduction } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { filterOutputFields, safeJSONParse } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport type { CookieOptions } from \"better-call\";\nimport {\n\tsignJWT,\n\tsymmetricDecodeJWT,\n\tsymmetricEncodeJWT,\n\tverifyJWT,\n} from \"../crypto/jwt\";\nimport { parseUserOutput } from \"../db/schema\";\nimport type { Session, User } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { sec } from \"../utils/time\";\nimport { SECURE_COOKIE_PREFIX } from \"./cookie-utils\";\nimport {\n\tcreateAccountStore,\n\tcreateSessionStore,\n\tgetAccountCookie,\n\tsetAccountCookie,\n} from \"./session-store\";\n\nexport function createCookieGetter(options: BetterAuthOptions) {\n\tconst secure =\n\t\toptions.advanced?.useSecureCookies !== undefined\n\t\t\t? options.advanced?.useSecureCookies\n\t\t\t: options.baseURL\n\t\t\t\t? options.baseURL.startsWith(\"https://\")\n\t\t\t\t\t? true\n\t\t\t\t\t: false\n\t\t\t\t: isProduction;\n\tconst secureCookiePrefix = secure ? SECURE_COOKIE_PREFIX : \"\";\n\tconst crossSubdomainEnabled =\n\t\t!!options.advanced?.crossSubDomainCookies?.enabled;\n\tconst domain = crossSubdomainEnabled\n\t\t? options.advanced?.crossSubDomainCookies?.domain ||\n\t\t\t(options.baseURL ? new URL(options.baseURL).hostname : undefined)\n\t\t: undefined;\n\tif (crossSubdomainEnabled && !domain) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"baseURL is required when crossSubdomainCookies are enabled\",\n\t\t);\n\t}\n\tfunction createCookie(\n\t\tcookieName: string,\n\t\toverrideAttributes: Partial<CookieOptions> = {},\n\t) {\n\t\tconst prefix = options.advanced?.cookiePrefix || \"better-auth\";\n\t\tconst name =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.name ||\n\t\t\t`${prefix}.${cookieName}`;\n\n\t\tconst attributes =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.attributes;\n\n\t\treturn {\n\t\t\tname: `${secureCookiePrefix}${name}`,\n\t\t\tattributes: {\n\t\t\t\tsecure: !!secureCookiePrefix,\n\t\t\t\tsameSite: \"lax\",\n\t\t\t\tpath: \"/\",\n\t\t\t\thttpOnly: true,\n\t\t\t\t...(crossSubdomainEnabled ? { domain } : {}),\n\t\t\t\t...options.advanced?.defaultCookieAttributes,\n\t\t\t\t...overrideAttributes,\n\t\t\t\t...attributes,\n\t\t\t},\n\t\t} satisfies BetterAuthCookie;\n\t}\n\treturn createCookie;\n}\n\nexport function getCookies(options: BetterAuthOptions) {\n\tconst createCookie = createCookieGetter(options);\n\tconst sessionMaxAge = options.session?.expiresIn || sec(\"7d\");\n\tconst sessionToken = createCookie(\"session_token\", {\n\t\tmaxAge: sessionMaxAge,\n\t});\n\tconst sessionData = createCookie(\"session_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst accountData = createCookie(\"account_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst dontRememberToken = createCookie(\"dont_remember\");\n\treturn {\n\t\tsessionToken: {\n\t\t\tname: sessionToken.name,\n\t\t\tattributes: sessionToken.attributes,\n\t\t},\n\t\t/**\n\t\t * This cookie is used to store the session data in the cookie\n\t\t * This is useful for when you want to cache the session in the cookie\n\t\t */\n\t\tsessionData: {\n\t\t\tname: sessionData.name,\n\t\t\tattributes: sessionData.attributes,\n\t\t},\n\t\tdontRememberToken: {\n\t\t\tname: dontRememberToken.name,\n\t\t\tattributes: dontRememberToken.attributes,\n\t\t},\n\t\taccountData: {\n\t\t\tname: accountData.name,\n\t\t\tattributes: accountData.attributes,\n\t\t},\n\t};\n}\n\nexport async function setCookieCache(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe: boolean,\n) {\n\tif (!ctx.context.options.session?.cookieCache?.enabled) {\n\t\treturn;\n\t}\n\n\tconst filteredSession = filterOutputFields(\n\t\tsession.session,\n\t\tctx.context.options.session?.additionalFields,\n\t);\n\n\tconst filteredUser = parseUserOutput(ctx.context.options, session.user);\n\n\tconst versionConfig = ctx.context.options.session?.cookieCache?.version;\n\tlet version = \"1\";\n\tif (versionConfig) {\n\t\tif (typeof versionConfig === \"string\") {\n\t\t\tversion = versionConfig;\n\t\t} else if (typeof versionConfig === \"function\") {\n\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\tversion = isPromise(result) ? await result : result;\n\t\t}\n\t}\n\n\tconst sessionData = {\n\t\tsession: filteredSession,\n\t\tuser: filteredUser,\n\t\tupdatedAt: Date.now(),\n\t\tversion,\n\t};\n\n\tconst options = {\n\t\t...ctx.context.authCookies.sessionData.attributes,\n\t\tmaxAge: dontRememberMe\n\t\t\t? undefined\n\t\t\t: ctx.context.authCookies.sessionData.attributes.maxAge,\n\t};\n\n\tconst expiresAtDate = getDate(options.maxAge || 60, \"sec\").getTime();\n\tconst strategy =\n\t\tctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\n\tlet data: string;\n\n\tif (strategy === \"jwe\") {\n\t\t// Use JWE strategy (JSON Web Encryption) with A256CBC-HS512 + HKDF\n\t\tdata = await symmetricEncodeJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\t\"better-auth-session\",\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else if (strategy === \"jwt\") {\n\t\t// Use JWT strategy with HMAC-SHA256 signature (HS256), no encryption\n\t\tdata = await signJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else {\n\t\t// Use compact strategy (base64url + HMAC, no JWT spec overhead)\n\t\t// Also handles legacy \"base64-hmac\" for backward compatibility\n\t\tdata = base64Url.encode(\n\t\t\tJSON.stringify({\n\t\t\t\tsession: sessionData,\n\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\tsignature: await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t...sessionData,\n\t\t\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t\t{\n\t\t\t\tpadding: false,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Check if we need to chunk the cookie (only if it exceeds 4093 bytes)\n\tif (data.length > 4093) {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tconst cookies = sessionStore.chunk(data, options);\n\t\tsessionStore.setCookies(cookies);\n\t} else {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tif (sessionStore.hasChunks()) {\n\t\t\tconst cleanCookies = sessionStore.clean();\n\t\t\tsessionStore.setCookies(cleanCookies);\n\t\t}\n\t\tctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);\n\t}\n\n\t// Refresh account cookie to keep it in sync\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tif (accountData) {\n\t\t\tawait setAccountCookie(ctx, accountData);\n\t\t}\n\t}\n}\n\nexport async function setSessionCookie(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe?: boolean | undefined,\n\toverrides?: Partial<CookieOptions> | undefined,\n) {\n\tconst dontRememberMeCookie = await ctx.getSignedCookie(\n\t\tctx.context.authCookies.dontRememberToken.name,\n\t\tctx.context.secret,\n\t);\n\t// if dontRememberMe is not set, use the cookie value\n\tdontRememberMe =\n\t\tdontRememberMe !== undefined ? dontRememberMe : !!dontRememberMeCookie;\n\n\tconst options = ctx.context.authCookies.sessionToken.attributes;\n\tconst maxAge = dontRememberMe\n\t\t? undefined\n\t\t: ctx.context.sessionConfig.expiresIn;\n\tawait ctx.setSignedCookie(\n\t\tctx.context.authCookies.sessionToken.name,\n\t\tsession.session.token,\n\t\tctx.context.secret,\n\t\t{\n\t\t\t...options,\n\t\t\tmaxAge,\n\t\t\t...overrides,\n\t\t},\n\t);\n\n\tif (dontRememberMe) {\n\t\tawait ctx.setSignedCookie(\n\t\t\tctx.context.authCookies.dontRememberToken.name,\n\t\t\t\"true\",\n\t\t\tctx.context.secret,\n\t\t\tctx.context.authCookies.dontRememberToken.attributes,\n\t\t);\n\t}\n\tawait setCookieCache(ctx, session, dontRememberMe);\n\tctx.context.setNewSession(session);\n}\n\n/**\n * Expires a cookie by setting `maxAge: 0` while preserving its attributes\n */\nexport function expireCookie(\n\tctx: GenericEndpointContext,\n\tcookie: BetterAuthCookie,\n) {\n\tctx.setCookie(cookie.name, \"\", {\n\t\t...cookie.attributes,\n\t\tmaxAge: 0,\n\t});\n}\n\nexport function deleteSessionCookie(\n\tctx: GenericEndpointContext,\n\tskipDontRememberMe?: boolean | undefined,\n) {\n\texpireCookie(ctx, ctx.context.authCookies.sessionToken);\n\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\texpireCookie(ctx, ctx.context.authCookies.accountData);\n\n\t\t//clean up the account data chunks\n\t\tconst accountStore = createAccountStore(\n\t\t\tctx.context.authCookies.accountData.name,\n\t\t\tctx.context.authCookies.accountData.attributes,\n\t\t\tctx,\n\t\t);\n\t\tconst cleanCookies = accountStore.clean();\n\t\taccountStore.setCookies(cleanCookies);\n\t}\n\n\tif (ctx.context.oauthConfig.storeStateStrategy === \"cookie\") {\n\t\tconst stateCookie = ctx.context.createAuthCookie(\"oauth_state\");\n\t\texpireCookie(ctx, stateCookie);\n\t}\n\n\t// Use createSessionStore to clean up all session data chunks\n\tconst sessionStore = createSessionStore(\n\t\tctx.context.authCookies.sessionData.name,\n\t\tctx.context.authCookies.sessionData.attributes,\n\t\tctx,\n\t);\n\tconst cleanCookies = sessionStore.clean();\n\tsessionStore.setCookies(cleanCookies);\n\n\tif (!skipDontRememberMe) {\n\t\texpireCookie(ctx, ctx.context.authCookies.dontRememberToken);\n\t}\n}\n\nexport function parseCookies(cookieHeader: string) {\n\tconst cookies = cookieHeader.split(\"; \");\n\tconst cookieMap = new Map<string, string>();\n\n\tcookies.forEach((cookie) => {\n\t\tconst [name, value] = cookie.split(/=(.*)/s);\n\t\tcookieMap.set(name!, value!);\n\t});\n\treturn cookieMap;\n}\n\nexport type EligibleCookies = (string & {}) | (keyof BetterAuthCookies & {});\n\nexport const getSessionCookie = (\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tpath?: string;\n\t\t  }\n\t\t| undefined,\n) => {\n\tif (config?.cookiePrefix) {\n\t\tif (config.cookieName) {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}-`;\n\t\t} else {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}.`;\n\t\t}\n\t}\n\tconst headers = \"headers\" in request ? request.headers : request;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_token\", cookiePrefix = \"better-auth.\" } =\n\t\tconfig || {};\n\tconst name = `${cookiePrefix}${cookieName}`;\n\tconst secureCookieName = `${SECURE_COOKIE_PREFIX}${name}`;\n\tconst parsedCookie = parseCookies(cookies);\n\tconst sessionToken =\n\t\tparsedCookie.get(name) || parsedCookie.get(secureCookieName);\n\tif (sessionToken) {\n\t\treturn sessionToken;\n\t}\n\n\treturn null;\n};\n\nexport const getCookieCache = async <\n\tS extends {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User & Record<string, any>;\n\t\tupdatedAt: number;\n\t\tversion?: string;\n\t},\n>(\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tisSecure?: boolean;\n\t\t\t\tsecret?: string;\n\t\t\t\tstrategy?: \"compact\" | \"jwt\" | \"jwe\"; // base64-hmac for backward compatibility\n\t\t\t\tversion?:\n\t\t\t\t\t| string\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => string)\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => Promise<string>);\n\t\t  }\n\t\t| undefined,\n) => {\n\tconst headers = request instanceof Headers ? request : request.headers;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_data\", cookiePrefix = \"better-auth\" } =\n\t\tconfig || {};\n\tconst name =\n\t\tconfig?.isSecure !== undefined\n\t\t\t? config.isSecure\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`\n\t\t\t: isProduction\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`;\n\tconst parsedCookie = parseCookies(cookies);\n\n\t// Check for chunked cookies\n\tlet sessionData = parsedCookie.get(name);\n\tif (!sessionData) {\n\t\t// Try to reconstruct from chunks\n\t\tconst chunks: Array<{ index: number; value: string }> = [];\n\t\tfor (const [cookieName, value] of parsedCookie.entries()) {\n\t\t\tif (cookieName.startsWith(name + \".\")) {\n\t\t\t\tconst parts = cookieName.split(\".\");\n\t\t\t\tconst indexStr = parts[parts.length - 1];\n\t\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\t\tif (!isNaN(index)) {\n\t\t\t\t\tchunks.push({ index, value });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chunks.length > 0) {\n\t\t\t// Sort by index and join\n\t\t\tchunks.sort((a, b) => a.index - b.index);\n\t\t\tsessionData = chunks.map((c) => c.value).join(\"\");\n\t\t}\n\t}\n\n\tif (sessionData) {\n\t\tconst secret = config?.secret || env.BETTER_AUTH_SECRET;\n\t\tif (!secret) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"getCookieCache requires a secret to be provided. Either pass it as an option or set the BETTER_AUTH_SECRET environment variable\",\n\t\t\t);\n\t\t}\n\n\t\tconst strategy = config?.strategy || \"compact\";\n\n\t\tif (strategy === \"jwe\") {\n\t\t\t// Use JWE strategy (encrypted)\n\t\t\tconst payload = await symmetricDecodeJWT<S>(\n\t\t\t\tsessionData,\n\t\t\t\tsecret,\n\t\t\t\t\"better-auth-session\",\n\t\t\t);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else if (strategy === \"jwt\") {\n\t\t\t// Use JWT strategy with HMAC signature (HS256), no encryption\n\t\t\tconst payload = await verifyJWT<S>(sessionData, secret);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Use compact strategy (or legacy base64-hmac)\n\t\t\tconst sessionDataPayload = safeJSONParse<{\n\t\t\t\tsession: S;\n\t\t\t\texpiresAt: number;\n\t\t\t\tsignature: string;\n\t\t\t}>(binary.decode(base64Url.decode(sessionData)));\n\t\t\tif (!sessionDataPayload) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst isValid = await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(\n\t\t\t\tsecret,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\t...sessionDataPayload.session,\n\t\t\t\t\texpiresAt: sessionDataPayload.expiresAt,\n\t\t\t\t}),\n\t\t\t\tsessionDataPayload.signature,\n\t\t\t);\n\t\t\tif (!isValid) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Validate version if provided\n\t\t\tif (config?.version && sessionDataPayload.session) {\n\t\t\t\tconst cookieVersion = sessionDataPayload.session.version || \"1\";\n\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\tconst result = config.version(\n\t\t\t\t\t\tsessionDataPayload.session.session,\n\t\t\t\t\t\tsessionDataPayload.session.user,\n\t\t\t\t\t);\n\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t}\n\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sessionDataPayload.session;\n\t\t}\n\t}\n\treturn null;\n};\n\nexport * from \"./cookie-utils\";\nexport { createSessionStore, getChunkedCookie } from \"./session-store\";\n"],"names":["data: string","cleanCookies","chunks: Array<{ index: number; value: string }>","cookieName"],"mappings":"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"}},
    {"offset": {"line": 3147, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/state.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/state.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport * as z from \"zod\";\nimport { expireCookie } from \"./cookies\";\nimport {\n\tgenerateRandomString,\n\tsymmetricDecrypt,\n\tsymmetricEncrypt,\n} from \"./crypto\";\n\nconst stateDataSchema = z.looseObject({\n\tcallbackURL: z.string(),\n\tcodeVerifier: z.string(),\n\terrorURL: z.string().optional(),\n\tnewUserURL: z.string().optional(),\n\texpiresAt: z.number(),\n\tlink: z\n\t\t.object({\n\t\t\temail: z.string(),\n\t\t\tuserId: z.coerce.string(),\n\t\t})\n\t\t.optional(),\n\trequestSignUp: z.boolean().optional(),\n});\n\nexport type StateData = z.infer<typeof stateDataSchema>;\n\nexport type StateErrorCode =\n\t| \"state_generation_error\"\n\t| \"state_invalid\"\n\t| \"state_mismatch\"\n\t| \"state_security_mismatch\";\n\nexport class StateError extends BetterAuthError {\n\tcode: string;\n\tdetails?: Record<string, any>;\n\n\tconstructor(\n\t\tmessage: string,\n\t\toptions: ErrorOptions & {\n\t\t\tcode: StateErrorCode;\n\t\t\tdetails?: Record<string, any>;\n\t\t},\n\t) {\n\t\tsuper(message, options);\n\t\tthis.code = options.code;\n\t\tthis.details = options.details;\n\t}\n}\n\nexport async function generateGenericState(\n\tc: GenericEndpointContext,\n\tstateData: StateData,\n\tsettings?: { cookieName: string },\n) {\n\tconst state = generateRandomString(32);\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Store state data in an encrypted cookie\n\n\t\tconst encryptedData = await symmetricEncrypt({\n\t\t\tkey: c.context.secret,\n\t\t\tdata: JSON.stringify(stateData),\n\t\t});\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t\t{\n\t\t\t\tmaxAge: 10 * 60, // 10 minutes\n\t\t\t},\n\t\t);\n\n\t\tc.setCookie(stateCookie.name, encryptedData, stateCookie.attributes);\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tcodeVerifier: stateData.codeVerifier,\n\t\t};\n\t}\n\n\t// Default: database strategy\n\n\tconst stateCookie = c.context.createAuthCookie(\n\t\tsettings?.cookieName ?? \"state\",\n\t\t{\n\t\t\tmaxAge: 5 * 60, // 5 minutes\n\t\t},\n\t);\n\n\tawait c.setSignedCookie(\n\t\tstateCookie.name,\n\t\tstate,\n\t\tc.context.secret,\n\t\tstateCookie.attributes,\n\t);\n\n\tconst expiresAt = new Date();\n\texpiresAt.setMinutes(expiresAt.getMinutes() + 10);\n\n\tconst verification = await c.context.internalAdapter.createVerificationValue({\n\t\tvalue: JSON.stringify(stateData),\n\t\tidentifier: state,\n\t\texpiresAt,\n\t});\n\n\tif (!verification) {\n\t\tthrow new StateError(\n\t\t\t\"Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database\",\n\t\t\t{\n\t\t\t\tcode: \"state_generation_error\",\n\t\t\t},\n\t\t);\n\t}\n\n\treturn {\n\t\tstate: verification.identifier,\n\t\tcodeVerifier: stateData.codeVerifier,\n\t};\n}\n\nexport async function parseGenericState(\n\tc: GenericEndpointContext,\n\tstate: string,\n\tsettings?: { cookieName: string },\n) {\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\tlet parsedData: StateData;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Retrieve state data from encrypted cookie\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t);\n\t\tconst encryptedData = c.getCookie(stateCookie.name);\n\n\t\tif (!encryptedData) {\n\t\t\tthrow new StateError(\"State mismatch: auth state cookie not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tconst decryptedData = await symmetricDecrypt({\n\t\t\t\tkey: c.context.secret,\n\t\t\t\tdata: encryptedData,\n\t\t\t});\n\n\t\t\tparsedData = stateDataSchema.parse(JSON.parse(decryptedData));\n\t\t} catch (error) {\n\t\t\tthrow new StateError(\n\t\t\t\t\"State invalid: Failed to decrypt or parse auth state\",\n\t\t\t\t{\n\t\t\t\t\tcode: \"state_invalid\",\n\t\t\t\t\tdetails: { state },\n\t\t\t\t\tcause: error,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\t// Clear the cookie after successful parsing\n\t\texpireCookie(c, stateCookie);\n\t} else {\n\t\t// Default: database strategy\n\t\tconst data = await c.context.internalAdapter.findVerificationValue(state);\n\t\tif (!data) {\n\t\t\tthrow new StateError(\"State mismatch: verification not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\tparsedData = stateDataSchema.parse(JSON.parse(data.value));\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"state\",\n\t\t);\n\n\t\tconst stateCookieValue = await c.getSignedCookie(\n\t\t\tstateCookie.name,\n\t\t\tc.context.secret,\n\t\t);\n\n\t\t/**\n\t\t * This is generally cause security issue and should only be used in\n\t\t * dev or staging environments. It's currently used by the oauth-proxy\n\t\t * plugin\n\t\t */\n\t\tconst skipStateCookieCheck = c.context.oauthConfig.skipStateCookieCheck;\n\t\tif (\n\t\t\t!skipStateCookieCheck &&\n\t\t\t(!stateCookieValue || stateCookieValue !== state)\n\t\t) {\n\t\t\tthrow new StateError(\"State mismatch: State not persisted correctly\", {\n\t\t\t\tcode: \"state_security_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\texpireCookie(c, stateCookie);\n\n\t\t// Delete verification value after retrieval\n\t\tawait c.context.internalAdapter.deleteVerificationValue(data.id);\n\t}\n\n\t// Check expiration\n\tif (parsedData.expiresAt < Date.now()) {\n\t\tthrow new StateError(\"Invalid state: request expired\", {\n\t\t\tcode: \"state_mismatch\",\n\t\t\tdetails: {\n\t\t\t\texpiresAt: parsedData.expiresAt,\n\t\t\t},\n\t\t});\n\t}\n\n\treturn parsedData;\n}\n"],"names":["stateCookie","parsedData: StateData"],"mappings":"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"}},
    {"offset": {"line": 3285, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/oauth2/state.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/oauth2/state.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\nimport { setOAuthState } from \"../api/middlewares/oauth\";\nimport { generateRandomString } from \"../crypto\";\nimport type { StateData } from \"../state\";\nimport { generateGenericState, parseGenericState, StateError } from \"../state\";\n\nexport async function generateState(\n\tc: GenericEndpointContext,\n\tlink:\n\t\t| {\n\t\t\t\temail: string;\n\t\t\t\tuserId: string;\n\t\t  }\n\t\t| undefined,\n\tadditionalData: Record<string, any> | false | undefined,\n) {\n\tconst callbackURL = c.body?.callbackURL || c.context.options.baseURL;\n\tif (!callbackURL) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"callbackURL is required\",\n\t\t});\n\t}\n\n\tconst codeVerifier = generateRandomString(128);\n\n\tconst stateData: StateData = {\n\t\t...(additionalData ? additionalData : {}),\n\t\tcallbackURL,\n\t\tcodeVerifier,\n\t\terrorURL: c.body?.errorCallbackURL,\n\t\tnewUserURL: c.body?.newUserCallbackURL,\n\t\tlink,\n\t\texpiresAt: Date.now() + 10 * 60 * 1000,\n\t\trequestSignUp: c.body?.requestSignUp,\n\t};\n\n\tawait setOAuthState(stateData);\n\n\ttry {\n\t\treturn generateGenericState(c, stateData);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to create verification\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\tmessage: \"Unable to create verification\",\n\t\t\tcause: error,\n\t\t});\n\t}\n}\n\nexport async function parseState(c: GenericEndpointContext) {\n\tconst state = c.query.state || c.body.state;\n\tconst errorURL =\n\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\n\tlet parsedData: StateData;\n\n\ttry {\n\t\tparsedData = await parseGenericState(c, state);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to parse state\", error);\n\n\t\tif (\n\t\t\terror instanceof StateError &&\n\t\t\terror.code === \"state_security_mismatch\"\n\t\t) {\n\t\t\tthrow c.redirect(`${errorURL}?error=state_mismatch`);\n\t\t}\n\n\t\tthrow c.redirect(`${errorURL}?error=please_restart_the_process`);\n\t}\n\n\tif (!parsedData.errorURL) {\n\t\tparsedData.errorURL = errorURL;\n\t}\n\n\tif (parsedData) {\n\t\tawait setOAuthState(parsedData);\n\t}\n\n\treturn parsedData;\n}\n"],"names":["stateData: StateData","parsedData: StateData"],"mappings":";;;;;;;;;;;;;;;;;;AAOA,eAAsB,cACrB,CAAA,EACA,IAAA,EAMA,cAAA,EACC;IACD,MAAM,cAAc,EAAE,IAAA,EAAM,eAAe,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA;IAC7D,IAAI,CAAC,YACJ,CAAA,MAAM,IAAI,8JAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAGH,MAAM,mBAAe,qLAAA,EAAqB,IAAI;IAE9C,MAAMA,YAAuB;QAC5B,GAAI,iBAAiB,iBAAiB,CAAA,CAAE;QACxC;QACA;QACA,UAAU,EAAE,IAAA,EAAM;QAClB,YAAY,EAAE,IAAA,EAAM;QACpB;QACA,WAAW,KAAK,GAAA,EAAK,GAAG,MAAU;QAClC,eAAe,EAAE,IAAA,EAAM;KACvB;IAED,UAAM,yLAAA,EAAc,UAAU;IAE9B,IAAI;QACH,WAAO,0KAAA,EAAqB,GAAG,UAAU;aACjC,OAAO;QACf,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,iCAAiC,MAAM;QAC9D,MAAM,IAAI,8JAAA,CAAS,yBAAyB;YAC3C,SAAS;YACT,OAAO;SACP,CAAC;;;AAIJ,eAAsB,WAAW,CAAA,EAA2B;IAC3D,MAAM,QAAQ,EAAE,KAAA,CAAM,KAAA,IAAS,EAAE,IAAA,CAAK,KAAA;IACtC,MAAM,WACL,EAAE,OAAA,CAAQ,OAAA,CAAQ,UAAA,EAAY,YAAY,GAAG,EAAE,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAA;IAEhE,IAAIC;IAEJ,IAAI;QACH,aAAa,UAAM,uKAAA,EAAkB,GAAG,MAAM;aACtC,OAAO;QACf,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,yBAAyB,MAAM;QAEtD,IACC,iBAAiB,gKAAA,IACjB,MAAM,IAAA,KAAS,0BAEf,CAAA,MAAM,EAAE,QAAA,CAAS,GAAG,SAAS,qBAAA,CAAA,CAAuB;QAGrD,MAAM,EAAE,QAAA,CAAS,GAAG,SAAS,iCAAA,CAAA,CAAmC;;IAGjE,IAAI,CAAC,WAAW,QAAA,CACf,CAAA,WAAW,QAAA,GAAW;IAGvB,IAAI,WACH,CAAA,UAAM,yLAAA,EAAc,WAAW;IAGhC,OAAO"}},
    {"offset": {"line": 3351, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/oauth2/utils.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/oauth2/utils.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { symmetricDecrypt, symmetricEncrypt } from \"../crypto\";\n\nexport function decryptOAuthToken(token: string, ctx: AuthContext) {\n\tif (!token) return token;\n\tif (ctx.options.account?.encryptOAuthTokens) {\n\t\treturn symmetricDecrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n\nexport function setTokenUtil(\n\ttoken: string | null | undefined,\n\tctx: AuthContext,\n) {\n\tif (ctx.options.account?.encryptOAuthTokens && token) {\n\t\treturn symmetricEncrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n"],"names":[],"mappings":";;;;;;;;;AAGA,SAAgB,kBAAkB,KAAA,EAAe,GAAA,EAAkB;IAClE,IAAI,CAAC,MAAO,CAAA,OAAO;IACnB,IAAI,IAAI,OAAA,CAAQ,OAAA,EAAS,mBACxB,CAAA,WAAO,gMAAA,EAAiB;QACvB,KAAK,IAAI,MAAA;QACT,MAAM;KACN,CAAC;IAEH,OAAO;;AAGR,SAAgB,aACf,KAAA,EACA,GAAA,EACC;IACD,IAAI,IAAI,OAAA,CAAQ,OAAA,EAAS,sBAAsB,MAC9C,CAAA,WAAO,gMAAA,EAAiB;QACvB,KAAK,IAAI,MAAA;QACT,MAAM;KACN,CAAC;IAEH,OAAO"}},
    {"offset": {"line": 3381, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/oauth2/link-account.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/oauth2/link-account.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { isDevelopment, logger } from \"@better-auth/core/env\";\nimport { APIError, createEmailVerificationToken } from \"../api\";\nimport { setAccountCookie } from \"../cookies/session-store\";\nimport type { Account, User } from \"../types\";\nimport { setTokenUtil } from \"./utils\";\n\nexport async function handleOAuthUserInfo(\n\tc: GenericEndpointContext,\n\topts: {\n\t\tuserInfo: Omit<User, \"createdAt\" | \"updatedAt\">;\n\t\taccount: Omit<Account, \"id\" | \"userId\" | \"createdAt\" | \"updatedAt\">;\n\t\tcallbackURL?: string | undefined;\n\t\tdisableSignUp?: boolean | undefined;\n\t\toverrideUserInfo?: boolean | undefined;\n\t\tisTrustedProvider?: boolean | undefined;\n\t},\n) {\n\tconst { userInfo, account, callbackURL, disableSignUp, overrideUserInfo } =\n\t\topts;\n\tconst dbUser = await c.context.internalAdapter\n\t\t.findOAuthUser(\n\t\t\tuserInfo.email.toLowerCase(),\n\t\t\taccount.accountId,\n\t\t\taccount.providerId,\n\t\t)\n\t\t.catch((e) => {\n\t\t\tlogger.error(\n\t\t\t\t\"Better auth was unable to query your database.\\nError: \",\n\t\t\t\te,\n\t\t\t);\n\t\t\tconst errorURL =\n\t\t\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\t\t\tthrow c.redirect(`${errorURL}?error=internal_server_error`);\n\t\t});\n\tlet user = dbUser?.user;\n\tconst isRegister = !user;\n\n\tif (dbUser) {\n\t\tconst linkedAccount =\n\t\t\tdbUser.linkedAccount ??\n\t\t\tdbUser.accounts.find(\n\t\t\t\t(acc) =>\n\t\t\t\t\tacc.providerId === account.providerId &&\n\t\t\t\t\tacc.accountId === account.accountId,\n\t\t\t);\n\t\tif (!linkedAccount) {\n\t\t\tconst accountLinking = c.context.options.account?.accountLinking;\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\t\t\tconst isTrustedProvider =\n\t\t\t\topts.isTrustedProvider ||\n\t\t\t\ttrustedProviders?.includes(account.providerId);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !userInfo.emailVerified) ||\n\t\t\t\taccountLinking?.enabled === false ||\n\t\t\t\taccountLinking?.disableImplicitLinking === true\n\t\t\t) {\n\t\t\t\tif (isDevelopment()) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\terror: \"account not linked\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.linkAccount({\n\t\t\t\t\tproviderId: account.providerId,\n\t\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t\t\tuserId: dbUser.user.id,\n\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\tscope: account.scope,\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Unable to link account\", e);\n\t\t\t\treturn {\n\t\t\t\t\terror: \"unable to link account\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst freshTokens =\n\t\t\t\tc.context.options.account?.updateAccountOnSignIn !== false\n\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries({\n\t\t\t\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\t\t\t\trefreshToken: await setTokenUtil(\n\t\t\t\t\t\t\t\t\taccount.refreshToken,\n\t\t\t\t\t\t\t\t\tc.context,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\t\t\t\tscope: account.scope,\n\t\t\t\t\t\t\t}).filter(([_, value]) => value !== undefined),\n\t\t\t\t\t\t)\n\t\t\t\t\t: {};\n\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, {\n\t\t\t\t\t...linkedAccount,\n\t\t\t\t\t...freshTokens,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (Object.keys(freshTokens).length > 0) {\n\t\t\t\tawait c.context.internalAdapter.updateAccount(\n\t\t\t\t\tlinkedAccount.id,\n\t\t\t\t\tfreshTokens,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (overrideUserInfo) {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\t// update user info from the provider if overrideUserInfo is true\n\t\t\tuser = await c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t...restUserInfo,\n\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\temailVerified:\n\t\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t\t\t\t? dbUser.user.emailVerified || userInfo.emailVerified\n\t\t\t\t\t\t: userInfo.emailVerified,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tif (disableSignUp) {\n\t\t\treturn {\n\t\t\t\terror: \"signup disabled\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\tconst accountData = {\n\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\tidToken: account.idToken,\n\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\tscope: account.scope,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t};\n\t\t\tconst { user: createdUser, account: createdAccount } =\n\t\t\t\tawait c.context.internalAdapter.createOAuthUser(\n\t\t\t\t\t{\n\t\t\t\t\t\t...restUserInfo,\n\t\t\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t\taccountData,\n\t\t\t\t);\n\t\t\tuser = createdUser;\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, createdAccount);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!userInfo.emailVerified &&\n\t\t\t\tuser &&\n\t\t\t\tc.context.options.emailVerification?.sendOnSignUp &&\n\t\t\t\tc.context.options.emailVerification?.sendVerificationEmail\n\t\t\t) {\n\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\tc.context.secret,\n\t\t\t\t\tuser.email,\n\t\t\t\t\tundefined,\n\t\t\t\t\tc.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\tconst url = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\tawait c.context.runInBackgroundOrAwait(\n\t\t\t\t\tc.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tc.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (e: any) {\n\t\t\tlogger.error(e);\n\t\t\tif (e instanceof APIError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: e.message,\n\t\t\t\t\tdata: null,\n\t\t\t\t\tisRegister: false,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror: \"unable to create user\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t}\n\tif (!user) {\n\t\treturn {\n\t\t\terror: \"unable to create user\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\tconst session = await c.context.internalAdapter.createSession(user.id);\n\tif (!session) {\n\t\treturn {\n\t\t\terror: \"unable to create session\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\treturn {\n\t\tdata: {\n\t\t\tsession,\n\t\t\tuser,\n\t\t},\n\t\terror: null,\n\t\tisRegister,\n\t};\n}\n"],"names":["e: any"],"mappings":"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"}},
    {"offset": {"line": 3541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/auth/trusted-origins.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/auth/trusted-origins.ts"],"sourcesContent":["import { getHost, getOrigin, getProtocol } from \"../utils/url\";\nimport { wildcardMatch } from \"../utils/wildcard\";\n\n/**\n * Matches the given url against an origin or origin pattern\n * See \"options.trustedOrigins\" for details of supported patterns\n *\n * @param url The url to test\n * @param pattern The origin pattern\n * @param [settings] Specify supported pattern matching settings\n * @returns {boolean} true if the URL matches the origin pattern, false otherwise.\n */\nexport const matchesOriginPattern = (\n\turl: string,\n\tpattern: string,\n\tsettings?: { allowRelativePaths: boolean },\n): boolean => {\n\tif (url.startsWith(\"/\")) {\n\t\tif (settings?.allowRelativePaths) {\n\t\t\treturn (\n\t\t\t\turl.startsWith(\"/\") &&\n\t\t\t\t/^\\/(?!\\/|\\\\|%2f|%5c)[\\w\\-.\\+/@]*(?:\\?[\\w\\-.\\+/=&%@]*)?$/.test(url)\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Check if pattern contains wildcard characters (*, **, or ?)\n\tconst hasWildcard = pattern.includes(\"*\") || pattern.includes(\"?\");\n\tif (hasWildcard) {\n\t\t// For protocol-specific wildcards, match the full origin\n\t\tif (pattern.includes(\"://\")) {\n\t\t\treturn wildcardMatch(pattern)(getOrigin(url) || url);\n\t\t}\n\t\tconst host = getHost(url);\n\t\tif (!host) {\n\t\t\treturn false;\n\t\t}\n\t\t// For host-only wildcards, match just the host\n\t\treturn wildcardMatch(pattern)(host);\n\t}\n\tconst protocol = getProtocol(url);\n\treturn protocol === \"http:\" || protocol === \"https:\" || !protocol\n\t\t? pattern === getOrigin(url)\n\t\t: url.startsWith(pattern);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;GAYA,MAAa,uBAAA,CACZ,KACA,SACA,aACa;IACb,IAAI,IAAI,UAAA,CAAW,IAAI,EAAE;QACxB,IAAI,UAAU,mBACb,CAAA,OACC,IAAI,UAAA,CAAW,IAAI,IACnB,0DAA0D,IAAA,CAAK,IAAI;QAIrE,OAAO;;IAKR,IADoB,QAAQ,QAAA,CAAS,IAAI,IAAI,QAAQ,QAAA,CAAS,IAAI,EACjD;QAEhB,IAAI,QAAQ,QAAA,CAAS,MAAM,CAC1B,CAAA,WAAO,+KAAA,EAAc,QAAQ,KAAC,sKAAA,EAAU,IAAI,IAAI,IAAI;QAErD,MAAM,WAAO,oKAAA,EAAQ,IAAI;QACzB,IAAI,CAAC,KACJ,CAAA,OAAO;QAGR,WAAO,+KAAA,EAAc,QAAQ,CAAC,KAAK;;IAEpC,MAAM,eAAW,wKAAA,EAAY,IAAI;IACjC,OAAO,aAAa,WAAW,aAAa,YAAY,CAAC,WACtD,gBAAY,sKAAA,EAAU,IAAI,GAC1B,IAAI,UAAA,CAAW,QAAQ"}},
    {"offset": {"line": 3578, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/auth/base.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/auth/base.ts"],"sourcesContent":["import type { AuthContext, BetterAuthOptions } from \"@better-auth/core\";\nimport { runWithAdapter } from \"@better-auth/core/context\";\nimport { BASE_ERROR_CODES, BetterAuthError } from \"@better-auth/core/error\";\nimport { getEndpoints, router } from \"../api\";\nimport { getTrustedOrigins } from \"../context/helpers\";\nimport type { Auth } from \"../types\";\nimport { getBaseURL, getOrigin } from \"../utils/url\";\n\nexport const createBetterAuth = <Options extends BetterAuthOptions>(\n\toptions: Options,\n\tinitFn: (options: Options) => Promise<AuthContext>,\n): Auth<Options> => {\n\tconst authContext = initFn(options);\n\tconst { api } = getEndpoints(authContext, options);\n\tconst errorCodes = options.plugins?.reduce((acc, plugin) => {\n\t\tif (plugin.$ERROR_CODES) {\n\t\t\treturn {\n\t\t\t\t...acc,\n\t\t\t\t...plugin.$ERROR_CODES,\n\t\t\t};\n\t\t}\n\t\treturn acc;\n\t}, {});\n\treturn {\n\t\thandler: async (request: Request) => {\n\t\t\tconst ctx = await authContext;\n\t\t\tconst basePath = ctx.options.basePath || \"/api/auth\";\n\t\t\tif (!ctx.options.baseURL) {\n\t\t\t\tconst baseURL = getBaseURL(\n\t\t\t\t\tundefined,\n\t\t\t\t\tbasePath,\n\t\t\t\t\trequest,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.options.advanced?.trustedProxyHeaders,\n\t\t\t\t);\n\t\t\t\tif (baseURL) {\n\t\t\t\t\tctx.baseURL = baseURL;\n\t\t\t\t\tctx.options.baseURL = getOrigin(ctx.baseURL) || undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Could not get base URL from request. Please provide a valid base URL.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.trustedOrigins = await getTrustedOrigins(ctx.options, request);\n\t\t\tconst { handler } = router(ctx, options);\n\t\t\treturn runWithAdapter(ctx.adapter, () => handler(request));\n\t\t},\n\t\tapi,\n\t\toptions: options,\n\t\t$context: authContext,\n\t\t$ERROR_CODES: {\n\t\t\t...errorCodes,\n\t\t\t...BASE_ERROR_CODES,\n\t\t},\n\t} as any;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAQA,MAAa,mBAAA,CACZ,SACA,WACmB;IACnB,MAAM,cAAc,OAAO,QAAQ;IACnC,MAAM,EAAE,GAAA,EAAA,OAAQ,yLAAA,EAAa,aAAa,QAAQ;IAUlD,OAAO;QACN,SAAS,OAAO,YAAqB;YACpC,MAAM,MAAM,MAAM;YAClB,MAAM,WAAW,IAAI,OAAA,CAAQ,QAAA,IAAY;YACzC,IAAI,CAAC,IAAI,OAAA,CAAQ,OAAA,EAAS;gBACzB,MAAM,cAAU,uKAAA,EACf,KAAA,GACA,UACA,SACA,KAAA,GACA,IAAI,OAAA,CAAQ,QAAA,EAAU,oBACtB;gBACD,IAAI,SAAS;oBACZ,IAAI,OAAA,GAAU;oBACd,IAAI,OAAA,CAAQ,OAAA,OAAU,sKAAA,EAAU,IAAI,OAAA,CAAQ,IAAI,KAAA;sBAEhD,CAAA,MAAM,IAAI,wMAAA,CACT,wEACA;;YAGH,IAAI,cAAA,GAAiB,UAAM,oLAAA,EAAkB,IAAI,OAAA,EAAS,QAAQ;YAClE,MAAM,EAAE,OAAA,EAAA,OAAY,mLAAA,EAAO,KAAK,QAAQ;YACxC,WAAO,+LAAA,EAAe,IAAI,OAAA,EAAA,IAAe,QAAQ,QAAQ,CAAC;;QAE3D;QACS;QACT,UAAU;QACV,cAAc;YACb,GAtCiB,QAAQ,OAAA,EAAS,OAAA,CAAQ,KAAK,WAAW;gBAC3D,IAAI,OAAO,YAAA,CACV,CAAA,OAAO;oBACN,GAAG,GAAA;oBACH,GAAG,OAAO,YAAA;iBACV;gBAEF,OAAO;eACL,CAAA,CAAE,CAAC;YA+BJ,GAAG,yLAAA;SACH;KACD"}},
    {"offset": {"line": 3634, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/auth/full.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/auth/full.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { init } from \"../context/init\";\nimport type { Auth } from \"../types\";\nimport { createBetterAuth } from \"./base\";\n\n/**\n * Better Auth initializer for full mode (with Kysely)\n *\n * @example\n * ```ts\n * import { betterAuth } from \"better-auth\";\n *\n * const auth = betterAuth({\n * \tdatabase: new PostgresDialect({ connection: process.env.DATABASE_URL }),\n * });\n * ```\n *\n * For minimal mode (without Kysely), import from `better-auth/minimal` instead\n * @example\n * ```ts\n * import { betterAuth } from \"better-auth/minimal\";\n *\n * const auth = betterAuth({\n *\t  database: drizzleAdapter(db, { provider: \"pg\" }),\n * });\n */\nexport const betterAuth = <Options extends BetterAuthOptions>(\n\toptions: Options & {},\n): Auth<Options> => {\n\treturn createBetterAuth(options, init);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BA,MAAa,aAAA,CACZ,YACmB;IACnB,WAAO,6KAAA,EAAiB,SAAS,oKAAA,CAAK"}},
    {"offset": {"line": 3672, "column": 0}, "map": {"version":3,"sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/dist/_virtual/rolldown_runtime.mjs"],"sourcesContent":["//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (all, symbols) => {\n\tlet target = {};\n\tfor (var name in all) {\n\t\t__defProp(target, name, {\n\t\t\tget: all[name],\n\t\t\tenumerable: true\n\t\t});\n\t}\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\treturn target;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") {\n\t\tfor (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\t\tkey = keys[i];\n\t\t\tif (!__hasOwnProp.call(to, key) && key !== except) {\n\t\t\t\t__defProp(to, key, {\n\t\t\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn to;\n};\nvar __reExport = (target, mod, secondTarget, symbols) => {\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t\tsecondTarget && __defProp(secondTarget, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\t__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\");\n};\n\n//#endregion\nexport { __export, __reExport };"],"names":[],"mappings":";;;;;;AAAA,0BAA0B;AAC1B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,mBAAmB,OAAO,wBAAwB;AACtD,IAAI,oBAAoB,OAAO,mBAAmB;AAClD,IAAI,eAAe,OAAO,SAAS,CAAC,cAAc;AAClD,IAAI,WAAW,CAAC,KAAK;IACpB,IAAI,SAAS,CAAC;IACd,IAAK,IAAI,QAAQ,IAAK;QACrB,UAAU,QAAQ,MAAM;YACvB,KAAK,GAAG,CAAC,KAAK;YACd,YAAY;QACb;IACD;IACA,IAAI,SAAS;QACZ,UAAU,QAAQ,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;IACzD;IACA,OAAO;AACR;AACA,IAAI,cAAc,CAAC,IAAI,MAAM,QAAQ;IACpC,IAAI,QAAQ,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY;QACnE,IAAK,IAAI,OAAO,kBAAkB,OAAO,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,IAAI,GAAG,IAAK;YACjF,MAAM,IAAI,CAAC,EAAE;YACb,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,QAAQ,QAAQ,QAAQ;gBAClD,UAAU,IAAI,KAAK;oBAClB,KAAK,CAAC,CAAC,IAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM;oBACjC,YAAY,CAAC,CAAC,OAAO,iBAAiB,MAAM,IAAI,KAAK,KAAK,UAAU;gBACrE;YACD;QACD;IACD;IACA,OAAO;AACR;AACA,IAAI,aAAa,CAAC,QAAQ,KAAK,cAAc;IAC5C,IAAI,SAAS;QACZ,UAAU,QAAQ,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;QACxD,gBAAgB,UAAU,cAAc,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;IAC/E;IACA,YAAY,QAAQ,KAAK,YAAY,gBAAgB,YAAY,cAAc,KAAK;AACrF","ignoreList":[0]}},
    {"offset": {"line": 3728, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/adapters/kysely-adapter/dialect.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/adapters/kysely-adapter/dialect.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { Dialect } from \"kysely\";\nimport {\n\tKysely,\n\tMssqlDialect,\n\tMysqlDialect,\n\tPostgresDialect,\n\tSqliteDialect,\n} from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\nexport function getKyselyDatabaseType(\n\tdb: BetterAuthOptions[\"database\"],\n): KyselyDatabaseType | null {\n\tif (!db) {\n\t\treturn null;\n\t}\n\tif (\"dialect\" in db) {\n\t\treturn getKyselyDatabaseType(db.dialect as Dialect);\n\t}\n\tif (\"createDriver\" in db) {\n\t\tif (db instanceof SqliteDialect) {\n\t\t\treturn \"sqlite\";\n\t\t}\n\t\tif (db instanceof MysqlDialect) {\n\t\t\treturn \"mysql\";\n\t\t}\n\t\tif (db instanceof PostgresDialect) {\n\t\t\treturn \"postgres\";\n\t\t}\n\t\tif (db instanceof MssqlDialect) {\n\t\t\treturn \"mssql\";\n\t\t}\n\t}\n\tif (\"aggregate\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\n\tif (\"getConnection\" in db) {\n\t\treturn \"mysql\";\n\t}\n\tif (\"connect\" in db) {\n\t\treturn \"postgres\";\n\t}\n\tif (\"fileControl\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\tif (\"open\" in db && \"close\" in db && \"prepare\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\treturn null;\n}\n\nexport const createKyselyAdapter = async (config: BetterAuthOptions) => {\n\tconst db = config.database;\n\n\tif (!db) {\n\t\treturn {\n\t\t\tkysely: null,\n\t\t\tdatabaseType: null,\n\t\t\ttransaction: undefined,\n\t\t};\n\t}\n\n\tif (\"db\" in db) {\n\t\treturn {\n\t\t\tkysely: db.db,\n\t\t\tdatabaseType: db.type,\n\t\t\ttransaction: db.transaction,\n\t\t};\n\t}\n\n\tif (\"dialect\" in db) {\n\t\treturn {\n\t\t\tkysely: new Kysely<any>({ dialect: db.dialect }),\n\t\t\tdatabaseType: db.type,\n\t\t\ttransaction: db.transaction,\n\t\t};\n\t}\n\n\tlet dialect: Dialect | undefined = undefined;\n\n\tconst databaseType = getKyselyDatabaseType(db);\n\n\tif (\"createDriver\" in db) {\n\t\tdialect = db;\n\t}\n\n\tif (\"aggregate\" in db && !(\"createSession\" in db)) {\n\t\tdialect = new SqliteDialect({\n\t\t\tdatabase: db,\n\t\t});\n\t}\n\n\tif (\"getConnection\" in db) {\n\t\t// @ts-expect-error - mysql2/promise\n\t\tdialect = new MysqlDialect(db);\n\t}\n\n\tif (\"connect\" in db) {\n\t\tdialect = new PostgresDialect({\n\t\t\tpool: db,\n\t\t});\n\t}\n\n\tif (\"fileControl\" in db) {\n\t\tconst { BunSqliteDialect } = await import(\"./bun-sqlite-dialect\");\n\t\tdialect = new BunSqliteDialect({\n\t\t\tdatabase: db,\n\t\t});\n\t}\n\n\tif (\"createSession\" in db) {\n\t\tlet DatabaseSync: typeof import(\"node:sqlite\").DatabaseSync | undefined =\n\t\t\tundefined;\n\t\ttry {\n\t\t\tconst nodeSqlite: string = \"node:sqlite\";\n\t\t\t// Ignore both Vite and Webpack for dynamic import as they both try to pre-bundle 'node:sqlite' which might fail\n\t\t\t// It's okay because we are in a try-catch block\n\t\t\t({ DatabaseSync } = await import(\n\t\t\t\t/* @vite-ignore */\n\t\t\t\t/* webpackIgnore: true */\n\t\t\t\tnodeSqlite\n\t\t\t));\n\t\t} catch (error: unknown) {\n\t\t\tif (\n\t\t\t\terror !== null &&\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\t\"code\" in error &&\n\t\t\t\terror.code !== \"ERR_UNKNOWN_BUILTIN_MODULE\"\n\t\t\t) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\tif (DatabaseSync && db instanceof DatabaseSync) {\n\t\t\tconst { NodeSqliteDialect } = await import(\"./node-sqlite-dialect\");\n\t\t\tdialect = new NodeSqliteDialect({\n\t\t\t\tdatabase: db,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {\n\t\tkysely: dialect ? new Kysely<any>({ dialect }) : null,\n\t\tdatabaseType,\n\t\ttransaction: undefined,\n\t};\n};\n"],"names":["dialect: Dialect | undefined","DatabaseSync: typeof import(\"node:sqlite\").DatabaseSync | undefined","nodeSqlite: string","error: unknown"],"mappings":";;;;;;;;;;;;;AAWA,SAAgB,sBACf,EAAA,EAC4B;IAC5B,IAAI,CAAC,GACJ,CAAA,OAAO;IAER,IAAI,aAAa,GAChB,CAAA,OAAO,sBAAsB,GAAG,OAAA,CAAmB;IAEpD,IAAI,kBAAkB,IAAI;QACzB,IAAI,cAAc,kMAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,+LAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,wMAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,+LAAA,CACjB,CAAA,OAAO;;IAGT,IAAI,eAAe,GAClB,CAAA,OAAO;IAGR,IAAI,mBAAmB,GACtB,CAAA,OAAO;IAER,IAAI,aAAa,GAChB,CAAA,OAAO;IAER,IAAI,iBAAiB,GACpB,CAAA,OAAO;IAER,IAAI,UAAU,MAAM,WAAW,MAAM,aAAa,GACjD,CAAA,OAAO;IAER,OAAO;;AAGR,MAAa,sBAAsB,OAAO,WAA8B;IACvE,MAAM,KAAK,OAAO,QAAA;IAElB,IAAI,CAAC,GACJ,CAAA,OAAO;QACN,QAAQ;QACR,cAAc;QACd,aAAa,KAAA;KACb;IAGF,IAAI,QAAQ,GACX,CAAA,OAAO;QACN,QAAQ,GAAG,EAAA;QACX,cAAc,GAAG,IAAA;QACjB,aAAa,GAAG,WAAA;KAChB;IAGF,IAAI,aAAa,GAChB,CAAA,OAAO;QACN,QAAQ,IAAI,2JAAA,CAAY;YAAE,SAAS,GAAG,OAAA;QAAA,CAAS,CAAC;QAChD,cAAc,GAAG,IAAA;QACjB,aAAa,GAAG,WAAA;KAChB;IAGF,IAAIA,UAA+B,KAAA;IAEnC,MAAM,eAAe,sBAAsB,GAAG;IAE9C,IAAI,kBAAkB,GACrB,CAAA,UAAU;IAGX,IAAI,eAAe,MAAM,CAAA,CAAE,mBAAmB,EAAA,EAC7C,CAAA,UAAU,IAAI,kMAAA,CAAc;QAC3B,UAAU;IAAA,CACV,CAAC;IAGH,IAAI,mBAAmB,GAEtB,CAAA,UAAU,IAAI,+LAAA,CAAa,GAAG;IAG/B,IAAI,aAAa,GAChB,CAAA,UAAU,IAAI,wMAAA,CAAgB;QAC7B,MAAM;IAAA,CACN,CAAC;IAGH,IAAI,iBAAiB,IAAI;QACxB,MAAM,EAAE,gBAAA,EAAA,GAAqB,MAAM,OAAO;QAC1C,UAAU,IAAI,iBAAiB;YAC9B,UAAU;QAAA,CACV,CAAC;;IAGH,IAAI,mBAAmB,IAAI;QAC1B,IAAIC,eACH,KAAA;QACD,IAAI;YACH,MAAMC,aAAqB;YAG3B,CAAC,EAAE,YAAA,EAAA,GAAiB,MAAM,MAAA,8CAGzB;iBAEOC,OAAgB;YACxB,IACC,UAAU,QACV,OAAO,UAAU,YACjB,UAAU,SACV,MAAM,IAAA,KAAS,6BAEf,CAAA,MAAM;;QAGR,IAAI,gBAAgB,cAAc,cAAc;YAC/C,MAAM,EAAE,iBAAA,EAAA,GAAsB,MAAM,OAAO;YAC3C,UAAU,IAAI,kBAAkB;gBAC/B,UAAU;YAAA,CACV,CAAC;;;IAIJ,OAAO;QACN,QAAQ,UAAU,IAAI,2JAAA,CAAY;YAAE;QAAA,CAAS,CAAC,GAAG;QACjD;QACA,aAAa,KAAA;KACb"}},
    {"offset": {"line": 3821, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/adapters/prisma-adapter/prisma-adapter.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/adapters/prisma-adapter/prisma-adapter.ts"],"sourcesContent":["import type { Awaitable, BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nexport interface PrismaConfig {\n\t/**\n\t * Database provider.\n\t */\n\tprovider:\n\t\t| \"sqlite\"\n\t\t| \"cockroachdb\"\n\t\t| \"mysql\"\n\t\t| \"postgresql\"\n\t\t| \"sqlserver\"\n\t\t| \"mongodb\";\n\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\n\t/**\n\t * Use plural table names\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\ninterface PrismaClient {}\n\ntype PrismaClientInternal = {\n\t$transaction: (\n\t\tcallback: (db: PrismaClient) => Awaitable<any>,\n\t) => Promise<any>;\n} & {\n\t[model: string]: {\n\t\tcreate: (data: any) => Promise<any>;\n\t\tfindFirst: (data: any) => Promise<any>;\n\t\tfindMany: (data: any) => Promise<any>;\n\t\tupdate: (data: any) => Promise<any>;\n\t\tupdateMany: (data: any) => Promise<any>;\n\t\tdelete: (data: any) => Promise<any>;\n\t\t[key: string]: any;\n\t};\n};\n\nexport const prismaAdapter = (prisma: PrismaClient, config: PrismaConfig) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter =\n\t\t(prisma: PrismaClient): AdapterFactoryCustomizeAdapterCreator =>\n\t\t({\n\t\t\tgetFieldName,\n\t\t\tgetModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetDefaultModelName,\n\t\t\tschema,\n\t\t}) => {\n\t\t\tconst db = prisma as PrismaClientInternal;\n\n\t\t\tconst convertSelect = (\n\t\t\t\tselect: string[] | undefined,\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig | undefined,\n\t\t\t) => {\n\t\t\t\tif (!select && !join) return undefined;\n\n\t\t\t\tconst result: Record<string, Record<string, any> | boolean> = {};\n\n\t\t\t\tif (select) {\n\t\t\t\t\tfor (const field of select) {\n\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (join) {\n\t\t\t\t\t// when joining that has a limit, we need to use Prisma's `select` syntax to append the limit to the field\n\t\t\t\t\t// because of such, it also means we need to select all base-model fields as well\n\t\t\t\t\t// should check if `select` is not provided, because then we should select all base-model fields\n\t\t\t\t\tif (!select) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(model)]?.fields || {};\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const field of Object.keys(fields)) {\n\t\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, getModelName(joinModel), schema);\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\tresult[key] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[key] = { take: joinAttr.limit };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Build the join key name based on whether the foreign field is unique or not.\n\t\t\t * If unique, use singular. Otherwise, pluralize (add 's').\n\t\t\t */\n\t\t\tconst getJoinKeyName = (\n\t\t\t\tbaseModel: string,\n\t\t\t\tjoinedModel: string,\n\t\t\t\tschema: any,\n\t\t\t): string => {\n\t\t\t\ttry {\n\t\t\t\t\tconst defaultBaseModelName = getDefaultModelName(baseModel);\n\t\t\t\t\tconst defaultJoinedModelName = getDefaultModelName(joinedModel);\n\t\t\t\t\tconst key = getModelName(joinedModel).toLowerCase();\n\n\t\t\t\t\t// First, check if the joined model has FKs to the base model (forward join)\n\t\t\t\t\tlet foreignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultJoinedModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultBaseModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\t// Forward join: joined model has FK to base model\n\t\t\t\t\t\t// This is typically a one-to-many relationship (plural)\n\t\t\t\t\t\t// Unless the FK is unique, then it's one-to-one (singular)\n\t\t\t\t\t\tconst [_foreignKey, foreignKeyAttributes] = foreignKeys[0] as any;\n\t\t\t\t\t\t// Only check if field is explicitly marked as unique\n\t\t\t\t\t\tconst isUnique = foreignKeyAttributes?.unique === true;\n\t\t\t\t\t\treturn isUnique || config.usePlural === true ? key : `${key}s`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check backwards: does the base model have FKs to the joined model?\n\t\t\t\t\tforeignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultBaseModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultJoinedModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Fallback to pluralizing if we can't determine uniqueness\n\t\t\t\t}\n\t\t\t\treturn `${getModelName(joinedModel).toLowerCase()}s`;\n\t\t\t};\n\t\t\tfunction operatorToPrismaOperator(operator: string) {\n\t\t\t\tswitch (operator) {\n\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\treturn \"startsWith\";\n\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\treturn \"endsWith\";\n\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\treturn \"not\";\n\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\treturn \"notIn\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn operator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst convertWhereClause = ({\n\t\t\t\taction,\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[] | undefined;\n\t\t\t\taction:\n\t\t\t\t\t| \"create\"\n\t\t\t\t\t| \"update\"\n\t\t\t\t\t| \"delete\"\n\t\t\t\t\t| \"findOne\"\n\t\t\t\t\t| \"findMany\"\n\t\t\t\t\t| \"count\"\n\t\t\t\t\t| \"updateMany\"\n\t\t\t\t\t| \"deleteMany\";\n\t\t\t}) => {\n\t\t\t\tif (!where || !where.length) return {};\n\t\t\t\tconst buildSingleCondition = (w: Where) => {\n\t\t\t\t\tconst fieldName = getFieldName({ model, field: w.field });\n\t\t\t\t\t// Special handling for Prisma null semantics, for non-nullable fields this is a tautology. Skip condition.\n\t\t\t\t\tif (w.operator === \"ne\" && w.value === null) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t(w.operator === \"in\" || w.operator === \"not_in\") &&\n\t\t\t\t\t\tArray.isArray(w.value)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst filtered = w.value.filter((v) => v != null);\n\t\t\t\t\t\tif (filtered.length === 0) {\n\t\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tAND: [\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { equals: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { not: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst prismaOp = operatorToPrismaOperator(w.operator);\n\t\t\t\t\t\treturn { [fieldName]: { [prismaOp]: filtered } };\n\t\t\t\t\t}\n\t\t\t\t\tif (w.operator === \"eq\" || !w.operator) {\n\t\t\t\t\t\treturn { [fieldName]: w.value };\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[fieldName]: {\n\t\t\t\t\t\t\t[operatorToPrismaOperator(w.operator)]: w.value,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Special handling for update actions: extract AND conditions with eq operator to root level\n\t\t\t\t// Prisma requires unique fields to be at root level, not nested in AND arrays\n\t\t\t\t// Only simple equality conditions can be at root level; complex operators must stay in AND array\n\t\t\t\tif (action === \"update\") {\n\t\t\t\t\tconst and = where.filter(\n\t\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t\t);\n\t\t\t\t\tconst or = where.filter((w) => w.connector === \"OR\");\n\n\t\t\t\t\t// Separate AND conditions into simple eq (can extract) and complex (must stay in AND)\n\t\t\t\t\tconst andSimple = and.filter(\n\t\t\t\t\t\t(w) => w.operator === \"eq\" || !w.operator,\n\t\t\t\t\t);\n\t\t\t\t\tconst andComplex = and.filter(\n\t\t\t\t\t\t(w) => w.operator !== \"eq\" && w.operator !== undefined,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst andSimpleClause = andSimple.map((w) => buildSingleCondition(w));\n\t\t\t\t\tconst andComplexClause = andComplex.map((w) =>\n\t\t\t\t\t\tbuildSingleCondition(w),\n\t\t\t\t\t);\n\t\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\t\t// Extract simple equality AND conditions to root level\n\t\t\t\t\tconst result: Record<string, any> = {};\n\t\t\t\t\tfor (const clause of andSimpleClause) {\n\t\t\t\t\t\tObject.assign(result, clause);\n\t\t\t\t\t}\n\t\t\t\t\t// Keep complex AND conditions in AND array\n\t\t\t\t\tif (andComplexClause.length > 0) {\n\t\t\t\t\t\tresult.AND = andComplexClause;\n\t\t\t\t\t}\n\t\t\t\t\tif (orClause.length > 0) {\n\t\t\t\t\t\tresult.OR = orClause;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Special handling for delete actions: extract id to root level\n\t\t\t\tif (action === \"delete\") {\n\t\t\t\t\tconst idCondition = where.find((w) => w.field === \"id\");\n\t\t\t\t\tif (idCondition) {\n\t\t\t\t\t\tconst idFieldName = getFieldName({ model, field: \"id\" });\n\t\t\t\t\t\tconst idClause = buildSingleCondition(idCondition);\n\t\t\t\t\t\tconst remainingWhere = where.filter((w) => w.field !== \"id\");\n\n\t\t\t\t\t\tif (remainingWhere.length === 0) {\n\t\t\t\t\t\t\treturn idClause;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst and = remainingWhere.filter(\n\t\t\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst or = remainingWhere.filter((w) => w.connector === \"OR\");\n\t\t\t\t\t\tconst andClause = and.map((w) => buildSingleCondition(w));\n\t\t\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\t\t\t// Extract id to root level, put other conditions in AND array\n\t\t\t\t\t\tconst result: Record<string, any> = {};\n\t\t\t\t\t\tif (idFieldName in idClause) {\n\t\t\t\t\t\t\tresult[idFieldName] = (idClause as Record<string, any>)[\n\t\t\t\t\t\t\t\tidFieldName\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Handle edge case where idClause might have special structure\n\t\t\t\t\t\t\tObject.assign(result, idClause);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (andClause.length > 0) {\n\t\t\t\t\t\t\tresult.AND = andClause;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (orClause.length > 0) {\n\t\t\t\t\t\t\tresult.OR = orClause;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (where.length === 1) {\n\t\t\t\t\tconst w = where[0]!;\n\t\t\t\t\tif (!w) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn buildSingleCondition(w);\n\t\t\t\t}\n\t\t\t\tconst and = where.filter((w) => w.connector === \"AND\" || !w.connector);\n\t\t\t\tconst or = where.filter((w) => w.connector === \"OR\");\n\t\t\t\tconst andClause = and.map((w) => buildSingleCondition(w));\n\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\treturn {\n\t\t\t\t\t...(andClause.length ? { AND: andClause } : {}),\n\t\t\t\t\t...(orClause.length ? { OR: orClause } : {}),\n\t\t\t\t};\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tasync create({ model, data: values, select }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst result = await db[model]!.create({\n\t\t\t\t\t\tdata: values,\n\t\t\t\t\t\tselect: convertSelect(select, model),\n\t\t\t\t\t});\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"findOne\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tconst map = new Map<string, string>();\n\t\t\t\t\tfor (const joinModel of Object.keys(join ?? {})) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(select, model, join);\n\n\t\t\t\t\tconst result = await db[model]!.findFirst({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting `include` items to use better-auth expected field names\n\t\t\t\t\tif (join && result) {\n\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\tif (includeKey in result) {\n\t\t\t\t\t\t\t\tresult[originalKey] = result[includeKey];\n\t\t\t\t\t\t\t\tdelete result[includeKey];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"findMany\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tconst map = new Map<string, string>();\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, _value] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(undefined, model, join);\n\n\t\t\t\t\tconst result = await db[model]!.findMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\ttake: limit || 100,\n\t\t\t\t\t\tskip: offset || 0,\n\t\t\t\t\t\t...(sortBy?.field\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\t[getFieldName({ model, field: sortBy.field })]:\n\t\t\t\t\t\t\t\t\t\t\tsortBy.direction === \"desc\" ? \"desc\" : \"asc\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {}),\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting join items to use better-auth expected field names\n\t\t\t\t\tif (join && Array.isArray(result)) {\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\t\tif (includeKey in item) {\n\t\t\t\t\t\t\t\t\titem[originalKey] = item[includeKey];\n\t\t\t\t\t\t\t\t\tdelete item[includeKey];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"count\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn await db[model]!.count({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"update\",\n\t\t\t\t\t});\n\n\t\t\t\t\treturn await db[model]!.update({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"updateMany\",\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await db[model]!.updateMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"delete\",\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait db[model]!.delete({\n\t\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e: any) {\n\t\t\t\t\t\t// If the record doesn't exist, we don't want to throw an error\n\t\t\t\t\t\tif (e?.meta?.cause === \"Record to delete does not exist.\") return;\n\t\t\t\t\t\t// otherwise if it's an unknown error, we want to just log it for debugging.\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"deleteMany\",\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await db[model]!.deleteMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"prisma\",\n\t\t\tadapterName: \"Prisma Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"postgresql\" ? true : false,\n\t\t\tsupportsArrays:\n\t\t\t\tconfig.provider === \"postgresql\" || config.provider === \"mongodb\"\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\t\ttransaction:\n\t\t\t\t(config.transaction ?? false)\n\t\t\t\t\t? (cb) =>\n\t\t\t\t\t\t\t(prisma as PrismaClientInternal).$transaction((tx) => {\n\t\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\t\tadapter: createCustomAdapter(tx),\n\t\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(prisma),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"names":["lazyOptions: BetterAuthOptions | null","prisma","result: Record<string, Record<string, any> | boolean>","schema","and","or","orClause","result: Record<string, any>","andClause","e: any","adapterOptions: AdapterFactoryOptions | null"],"mappings":"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"}},
    {"offset": {"line": 4156, "column": 0}, "map": {"version":3,"sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/dist/adapters/prisma-adapter/index.mjs"],"sourcesContent":["import { prismaAdapter } from \"./prisma-adapter.mjs\";\n\nexport { prismaAdapter };"],"names":[],"mappings":";AAAA","ignoreList":[0]}},
    {"offset": {"line": 4164, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/context/helpers.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/context/helpers.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { env } from \"@better-auth/core/env\";\nimport { defu } from \"defu\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { getBaseURL } from \"../utils/url\";\n\nexport async function runPluginInit(ctx: AuthContext) {\n\tlet options = ctx.options;\n\tconst plugins = options.plugins || [];\n\tlet context: AuthContext = ctx;\n\tconst dbHooks: BetterAuthOptions[\"databaseHooks\"][] = [];\n\tfor (const plugin of plugins) {\n\t\tif (plugin.init) {\n\t\t\tconst initPromise = plugin.init(context);\n\t\t\tlet result: ReturnType<Required<BetterAuthPlugin>[\"init\"]>;\n\t\t\tif (isPromise(initPromise)) {\n\t\t\t\tresult = await initPromise;\n\t\t\t} else {\n\t\t\t\tresult = initPromise;\n\t\t\t}\n\t\t\tif (typeof result === \"object\") {\n\t\t\t\tif (result.options) {\n\t\t\t\t\tconst { databaseHooks, ...restOpts } = result.options;\n\t\t\t\t\tif (databaseHooks) {\n\t\t\t\t\t\tdbHooks.push(databaseHooks);\n\t\t\t\t\t}\n\t\t\t\t\toptions = defu(options, restOpts);\n\t\t\t\t}\n\t\t\t\tif (result.context) {\n\t\t\t\t\tcontext = {\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\t...(result.context as Partial<AuthContext>),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Add the global database hooks last\n\tdbHooks.push(options.databaseHooks);\n\tcontext.internalAdapter = createInternalAdapter(context.adapter, {\n\t\toptions,\n\t\tlogger: context.logger,\n\t\thooks: dbHooks.filter((u) => u !== undefined),\n\t\tgenerateId: context.generateId,\n\t});\n\tcontext.options = options;\n\treturn { context };\n}\n\nexport function getInternalPlugins(options: BetterAuthOptions) {\n\tconst plugins: BetterAuthPlugin[] = [];\n\tif (options.advanced?.crossSubDomainCookies?.enabled) {\n\t\t// TODO: add internal plugin\n\t}\n\treturn plugins;\n}\n\nexport async function getTrustedOrigins(\n\toptions: BetterAuthOptions,\n\trequest?: Request,\n): Promise<string[]> {\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath, request);\n\tconst trustedOrigins: (string | undefined | null)[] = baseURL\n\t\t? [new URL(baseURL).origin]\n\t\t: [];\n\tif (options.trustedOrigins) {\n\t\tif (Array.isArray(options.trustedOrigins)) {\n\t\t\ttrustedOrigins.push(...options.trustedOrigins);\n\t\t}\n\t\tif (typeof options.trustedOrigins === \"function\") {\n\t\t\tconst validOrigins = await options.trustedOrigins(request);\n\t\t\ttrustedOrigins.push(...validOrigins);\n\t\t}\n\t}\n\tconst envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;\n\tif (envTrustedOrigins) {\n\t\ttrustedOrigins.push(...envTrustedOrigins.split(\",\"));\n\t}\n\treturn trustedOrigins.filter((v): v is string => Boolean(v));\n}\n"],"names":["context: AuthContext","dbHooks: BetterAuthOptions[\"databaseHooks\"][]","result: ReturnType<Required<BetterAuthPlugin>[\"init\"]>","defu","plugins: BetterAuthPlugin[]","trustedOrigins: (string | undefined | null)[]"],"mappings":";;;;;;;;;;;;;;;;;;;;AAWA,eAAsB,cAAc,GAAA,EAAkB;IACrD,IAAI,UAAU,IAAI,OAAA;IAClB,MAAM,UAAU,QAAQ,OAAA,IAAW,EAAE;IACrC,IAAIA,UAAuB;IAC3B,MAAMC,UAAgD,EAAE;IACxD,KAAK,MAAM,UAAU,QACpB,IAAI,OAAO,IAAA,EAAM;QAChB,MAAM,cAAc,OAAO,IAAA,CAAK,QAAQ;QACxC,IAAIC;QACJ,QAAI,gLAAA,EAAU,YAAY,CACzB,CAAA,SAAS,MAAM;aAEf,SAAS;QAEV,IAAI,OAAO,WAAW,UAAU;YAC/B,IAAI,OAAO,OAAA,EAAS;gBACnB,MAAM,EAAE,aAAA,EAAe,GAAG,UAAA,GAAa,OAAO,OAAA;gBAC9C,IAAI,cACH,CAAA,QAAQ,IAAA,CAAK,cAAc;gBAE5B,cAAUC,+IAAAA,EAAK,SAAS,SAAS;;YAElC,IAAI,OAAO,OAAA,CACV,CAAA,UAAU;gBACT,GAAG,OAAA;gBACH,GAAI,OAAO,OAAA;aACX;;;IAML,QAAQ,IAAA,CAAK,QAAQ,aAAA,CAAc;IACnC,QAAQ,eAAA,OAAkB,+LAAA,EAAsB,QAAQ,OAAA,EAAS;QAChE;QACA,QAAQ,QAAQ,MAAA;QAChB,OAAO,QAAQ,MAAA,CAAA,CAAQ,IAAM,MAAM,KAAA,EAAU;QAC7C,YAAY,QAAQ,UAAA;KACpB,CAAC;IACF,QAAQ,OAAA,GAAU;IAClB,OAAO;QAAE;IAAA,CAAS;;AAGnB,SAAgB,mBAAmB,OAAA,EAA4B;IAC9D,MAAMC,UAA8B,EAAE;IACtC,IAAI,QAAQ,QAAA,EAAU,uBAAuB,SAAS,CAAA;IAGtD,OAAO;;AAGR,eAAsB,kBACrB,OAAA,EACA,OAAA,EACoB;IACpB,MAAM,cAAU,uKAAA,EAAW,QAAQ,OAAA,EAAS,QAAQ,QAAA,EAAU,QAAQ;IACtE,MAAMC,iBAAgD,UACnD;QAAC,IAAI,IAAI,QAAQ,CAAC,MAAA;KAAO,GACzB,EAAE;IACL,IAAI,QAAQ,cAAA,EAAgB;QAC3B,IAAI,MAAM,OAAA,CAAQ,QAAQ,cAAA,CAAe,CACxC,CAAA,eAAe,IAAA,CAAK,GAAG,QAAQ,cAAA,CAAe;QAE/C,IAAI,OAAO,QAAQ,cAAA,KAAmB,YAAY;YACjD,MAAM,eAAe,MAAM,QAAQ,cAAA,CAAe,QAAQ;YAC1D,eAAe,IAAA,CAAK,GAAG,aAAa;;;IAGtC,MAAM,oBAAoB,gLAAA,CAAI,2BAAA;IAC9B,IAAI,kBACH,CAAA,eAAe,IAAA,CAAK,GAAG,kBAAkB,KAAA,CAAM,IAAI,CAAC;IAErD,OAAO,eAAe,MAAA,CAAA,CAAQ,IAAmB,QAAQ,EAAE,CAAC"}},
    {"offset": {"line": 4245, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/context/create-context.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/context/create-context.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { getBetterAuthVersion } from \"@better-auth/core/context\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { createLogger, env, isProduction, isTest } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport type { OAuthProvider } from \"@better-auth/core/oauth2\";\nimport type { SocialProviders } from \"@better-auth/core/social-providers\";\nimport { socialProviders } from \"@better-auth/core/social-providers\";\nimport { deprecate } from \"@better-auth/core/utils\";\nimport { createTelemetry } from \"@better-auth/telemetry\";\nimport defu from \"defu\";\nimport type { Entries } from \"type-fest\";\nimport { checkEndpointConflicts } from \"../api\";\nimport { matchesOriginPattern } from \"../auth/trusted-origins\";\nimport { createCookieGetter, getCookies } from \"../cookies\";\nimport { hashPassword, verifyPassword } from \"../crypto/password\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { generateId } from \"../utils\";\nimport { DEFAULT_SECRET } from \"../utils/constants\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { checkPassword } from \"../utils/password\";\nimport { getBaseURL } from \"../utils/url\";\nimport {\n\tgetInternalPlugins,\n\tgetTrustedOrigins,\n\trunPluginInit,\n} from \"./helpers\";\n\n/**\n * Estimates the entropy of a string in bits.\n * This is a simple approximation that helps detect low-entropy secrets.\n */\nfunction estimateEntropy(str: string): number {\n\tconst unique = new Set(str).size;\n\tif (unique === 0) return 0;\n\treturn Math.log2(Math.pow(unique, str.length));\n}\n\n/**\n * Validates that the secret meets minimum security requirements.\n * Throws BetterAuthError if the secret is invalid.\n * Skips validation for DEFAULT_SECRET in test environments only.\n * Only throws for DEFAULT_SECRET in production environment.\n */\nfunction validateSecret(\n\tsecret: string,\n\tlogger: ReturnType<typeof createLogger>,\n): void {\n\tconst isDefaultSecret = secret === DEFAULT_SECRET;\n\n\tif (isTest()) {\n\t\treturn;\n\t}\n\n\tif (isDefaultSecret && isProduction) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.\",\n\t\t);\n\t}\n\n\tif (!secret) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"BETTER_AUTH_SECRET is missing. Set it in your environment or pass `secret` to betterAuth({ secret }).\",\n\t\t);\n\t}\n\n\tif (secret.length < 32) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Warning: your BETTER_AUTH_SECRET should be at least 32 characters long for adequate security. Generate one with \\`npx @better-auth/cli secret\\` or \\`openssl rand -base64 32\\`.`,\n\t\t);\n\t}\n\n\t// Optional high-entropy check: warn if entropy appears low\n\tconst entropy = estimateEntropy(secret);\n\tif (entropy < 120) {\n\t\tlogger.warn(\n\t\t\t\"[better-auth] Warning: your BETTER_AUTH_SECRET appears low-entropy. Use a randomly generated secret for production.\",\n\t\t);\n\t}\n}\n\nexport async function createAuthContext(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\toptions: BetterAuthOptions,\n\tgetDatabaseType: (database: BetterAuthOptions[\"database\"]) => string,\n): Promise<AuthContext> {\n\t//set default options for stateless mode\n\tif (!options.database) {\n\t\toptions = defu(options, {\n\t\t\tsession: {\n\t\t\t\tcookieCache: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tstrategy: \"jwe\" as const,\n\t\t\t\t\trefreshCache: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tstoreStateStrategy: \"cookie\" as const,\n\t\t\t\tstoreAccountCookie: true,\n\t\t\t},\n\t\t});\n\t}\n\tconst plugins = options.plugins || [];\n\tconst internalPlugins = getInternalPlugins(options);\n\tconst logger = createLogger(options.logger);\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath);\n\n\tif (!baseURL) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Base URL could not be determined. Please set a valid base URL using the baseURL config option or the BETTER_AUTH_BASE_URL environment variable. Without this, callbacks and redirects may not work correctly.`,\n\t\t);\n\t}\n\n\tif (\n\t\tadapter.id === \"memory\" &&\n\t\toptions.advanced?.database?.generateId === false\n\t) {\n\t\tlogger.error(\n\t\t\t`[better-auth] Misconfiguration detected.\nYou are using the memory DB with generateId: false.\nThis will cause no id to be generated for any model.\nMost of the features of Better Auth will not work correctly.`,\n\t\t);\n\t}\n\n\tconst secret =\n\t\toptions.secret ||\n\t\tenv.BETTER_AUTH_SECRET ||\n\t\tenv.AUTH_SECRET ||\n\t\tDEFAULT_SECRET;\n\n\tvalidateSecret(secret, logger);\n\n\toptions = {\n\t\t...options,\n\t\tsecret,\n\t\tbaseURL: baseURL ? new URL(baseURL).origin : \"\",\n\t\tbasePath: options.basePath || \"/api/auth\",\n\t\tplugins: plugins.concat(internalPlugins),\n\t};\n\n\tcheckEndpointConflicts(options, logger);\n\tconst cookies = getCookies(options);\n\tconst tables = getAuthTables(options);\n\tconst providers: OAuthProvider[] = (\n\t\tObject.entries(\n\t\t\toptions.socialProviders || {},\n\t\t) as unknown as Entries<SocialProviders>\n\t)\n\t\t.map(([key, config]) => {\n\t\t\tif (config == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (config.enabled === false) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!config.clientId) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Social provider ${key} is missing clientId or clientSecret`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst provider = socialProviders[key](config as never);\n\t\t\t(provider as OAuthProvider).disableImplicitSignUp =\n\t\t\t\tconfig.disableImplicitSignUp;\n\t\t\treturn provider;\n\t\t})\n\t\t.filter((x) => x !== null);\n\n\tconst generateIdFunc: AuthContext[\"generateId\"] = ({ model, size }) => {\n\t\tif (typeof (options.advanced as any)?.generateId === \"function\") {\n\t\t\treturn (options.advanced as any).generateId({ model, size });\n\t\t}\n\t\tconst dbGenerateId = options?.advanced?.database?.generateId;\n\t\tif (typeof dbGenerateId === \"function\") {\n\t\t\treturn dbGenerateId({ model, size });\n\t\t}\n\t\tif (dbGenerateId === \"uuid\") {\n\t\t\treturn crypto.randomUUID();\n\t\t}\n\t\tif (dbGenerateId === \"serial\" || dbGenerateId === false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn generateId(size);\n\t};\n\n\tconst { publish } = await createTelemetry(options, {\n\t\tadapter: adapter.id,\n\t\tdatabase:\n\t\t\ttypeof options.database === \"function\"\n\t\t\t\t? \"adapter\"\n\t\t\t\t: getDatabaseType(options.database),\n\t});\n\n\tconst trustedOrigins = await getTrustedOrigins(options);\n\n\tconst ctx: AuthContext = {\n\t\tappName: options.appName || \"Better Auth\",\n\t\tbaseURL: baseURL || \"\",\n\t\tversion: getBetterAuthVersion(),\n\t\tsocialProviders: providers,\n\t\toptions,\n\t\toauthConfig: {\n\t\t\tstoreStateStrategy:\n\t\t\t\toptions.account?.storeStateStrategy ||\n\t\t\t\t(options.database ? \"database\" : \"cookie\"),\n\t\t\tskipStateCookieCheck: !!options.account?.skipStateCookieCheck,\n\t\t},\n\t\ttables,\n\t\ttrustedOrigins,\n\t\tisTrustedOrigin(\n\t\t\turl: string,\n\t\t\tsettings?: {\n\t\t\t\tallowRelativePaths: boolean;\n\t\t\t},\n\t\t) {\n\t\t\treturn this.trustedOrigins.some((origin) =>\n\t\t\t\tmatchesOriginPattern(url, origin, settings),\n\t\t\t);\n\t\t},\n\t\tsessionConfig: {\n\t\t\tupdateAge:\n\t\t\t\toptions.session?.updateAge !== undefined\n\t\t\t\t\t? options.session.updateAge\n\t\t\t\t\t: 24 * 60 * 60,\n\t\t\texpiresIn: options.session?.expiresIn || 60 * 60 * 24 * 7,\n\t\t\tfreshAge:\n\t\t\t\toptions.session?.freshAge === undefined\n\t\t\t\t\t? 60 * 60 * 24\n\t\t\t\t\t: options.session.freshAge,\n\t\t\tcookieRefreshCache: (() => {\n\t\t\t\tconst refreshCache = options.session?.cookieCache?.refreshCache;\n\t\t\t\tconst maxAge = options.session?.cookieCache?.maxAge || 60 * 5;\n\n\t\t\t\t// `refreshCache` is intended for fully stateless / DB-less setups.\n\t\t\t\t// If a server-side store is configured, prefer fetching/refreshing from that source\n\t\t\t\t// and disable stateless refresh behavior to avoid confusing/unsafe configurations.\n\t\t\t\tconst isStateful = !!options.database || !!options.secondaryStorage;\n\t\t\t\tif (isStateful && refreshCache) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[better-auth] `session.cookieCache.refreshCache` is enabled while `database` or `secondaryStorage` is configured. `refreshCache` is meant for stateless (DB-less) setups. Disabling `refreshCache`  remove it from your config to silence this warning.\",\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === false || refreshCache === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === true) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tupdateAge: Math.floor(maxAge * 0.2),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tupdateAge:\n\t\t\t\t\t\trefreshCache.updateAge !== undefined\n\t\t\t\t\t\t\t? refreshCache.updateAge\n\t\t\t\t\t\t\t: Math.floor(maxAge * 0.2),\n\t\t\t\t};\n\t\t\t})(),\n\t\t},\n\t\tsecret,\n\t\trateLimit: {\n\t\t\t...options.rateLimit,\n\t\t\tenabled: options.rateLimit?.enabled ?? isProduction,\n\t\t\twindow: options.rateLimit?.window || 10,\n\t\t\tmax: options.rateLimit?.max || 100,\n\t\t\tstorage:\n\t\t\t\toptions.rateLimit?.storage ||\n\t\t\t\t(options.secondaryStorage ? \"secondary-storage\" : \"memory\"),\n\t\t},\n\t\tauthCookies: cookies,\n\t\tlogger,\n\t\tgenerateId: generateIdFunc,\n\t\tsession: null,\n\t\tsecondaryStorage: options.secondaryStorage,\n\t\tpassword: {\n\t\t\thash: options.emailAndPassword?.password?.hash || hashPassword,\n\t\t\tverify: options.emailAndPassword?.password?.verify || verifyPassword,\n\t\t\tconfig: {\n\t\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength || 8,\n\t\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128,\n\t\t\t},\n\t\t\tcheckPassword,\n\t\t},\n\t\tsetNewSession(session) {\n\t\t\tthis.newSession = session;\n\t\t},\n\t\tnewSession: null,\n\t\tadapter: adapter,\n\t\tinternalAdapter: createInternalAdapter(adapter, {\n\t\t\toptions,\n\t\t\tlogger,\n\t\t\thooks: options.databaseHooks ? [options.databaseHooks] : [],\n\t\t\tgenerateId: generateIdFunc,\n\t\t}),\n\t\tcreateAuthCookie: createCookieGetter(options),\n\t\tasync runMigrations() {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"runMigrations will be set by the specific init implementation\",\n\t\t\t);\n\t\t},\n\t\tpublishTelemetry: publish,\n\t\tskipCSRFCheck: !!options.advanced?.disableCSRFCheck,\n\t\tskipOriginCheck:\n\t\t\toptions.advanced?.disableOriginCheck !== undefined\n\t\t\t\t? options.advanced.disableOriginCheck\n\t\t\t\t: isTest()\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\trunInBackground:\n\t\t\toptions.advanced?.backgroundTasks?.handler ??\n\t\t\t((p) => {\n\t\t\t\tp.catch(() => {});\n\t\t\t}),\n\t\tasync runInBackgroundOrAwait(\n\t\t\tpromise: Promise<unknown> | Promise<void> | void | unknown,\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (options.advanced?.backgroundTasks?.handler) {\n\t\t\t\t\tif (promise instanceof Promise) {\n\t\t\t\t\t\toptions.advanced.backgroundTasks.handler(\n\t\t\t\t\t\t\tpromise.catch((e) => {\n\t\t\t\t\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait promise;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t}\n\t\t},\n\t\tgetPlugin: <Plugin extends BetterAuthPlugin>(id: Plugin[\"id\"]) =>\n\t\t\t(options.plugins!.find((p): p is Plugin => p.id === id) as\n\t\t\t\t| Plugin\n\t\t\t\t| undefined) ?? null,\n\t};\n\n\tconst initOrPromise = runPluginInit(ctx);\n\tlet context: AuthContext;\n\tif (isPromise(initOrPromise)) {\n\t\t({ context } = await initOrPromise);\n\t} else {\n\t\t({ context } = initOrPromise);\n\t}\n\n\tif (\n\t\ttypeof context.options.emailVerification?.onEmailVerification === \"function\"\n\t) {\n\t\tcontext.options.emailVerification.onEmailVerification = deprecate(\n\t\t\tcontext.options.emailVerification.onEmailVerification,\n\t\t\t\"Use `afterEmailVerification` instead. This will be removed in 1.5\",\n\t\t\tcontext.logger,\n\t\t);\n\t}\n\n\treturn context;\n}\n"],"names":["logger","providers: OAuthProvider[]","generateIdFunc: AuthContext[\"generateId\"]","generateId","context: AuthContext"],"mappings":"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"}},
    {"offset": {"line": 4484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/context/init.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/context/init.ts"],"sourcesContent":["import { BetterAuthError } from \"@better-auth/core/error\";\nimport { getKyselyDatabaseType } from \"../adapters/kysely-adapter/dialect\";\nimport { getAdapter } from \"../db/adapter-kysely\";\nimport { getMigrations } from \"../db/get-migration\";\nimport type { BetterAuthOptions } from \"../types\";\nimport { createAuthContext } from \"./create-context\";\n\nexport const init = async (options: BetterAuthOptions) => {\n\tconst adapter = await getAdapter(options);\n\n\t// Get database type using Kysely's dialect detection\n\tconst getDatabaseType = (database: BetterAuthOptions[\"database\"]) =>\n\t\tgetKyselyDatabaseType(database) || \"unknown\";\n\n\t// Use base context creation\n\tconst ctx = await createAuthContext(adapter, options, getDatabaseType);\n\n\t// Add runMigrations with Kysely support\n\tctx.runMigrations = async function () {\n\t\t// only run migrations if database is provided and it's not an adapter\n\t\tif (!options.database || \"updateMany\" in options.database) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Database is not provided or it's an adapter. Migrations are only supported with a database instance.\",\n\t\t\t);\n\t\t}\n\t\tconst { runMigrations } = await getMigrations(options);\n\t\tawait runMigrations();\n\t};\n\n\treturn ctx;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAOA,MAAa,OAAO,OAAO,YAA+B;IACzD,MAAM,UAAU,UAAM,kLAAA,EAAW,QAAQ;IAGzC,MAAM,kBAAA,CAAmB,eACxB,8MAAA,EAAsB,SAAS,IAAI;IAGpC,MAAM,MAAM,UAAM,8LAAA,EAAkB,SAAS,SAAS,gBAAgB;IAGtE,IAAI,aAAA,GAAgB,iBAAkB;QAErC,IAAI,CAAC,QAAQ,QAAA,IAAY,gBAAgB,QAAQ,QAAA,CAChD,CAAA,MAAM,IAAI,wMAAA,CACT,uGACA;QAEF,MAAM,EAAE,aAAA,EAAA,GAAkB,UAAM,oLAAA,EAAc,QAAQ;QACtD,MAAM,eAAe;;IAGtB,OAAO"}},
    {"offset": {"line": 4516, "column": 0}, "map": {"version":3,"sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/dist/index.mjs"],"sourcesContent":["import { generateGenericState, parseGenericState } from \"./state.mjs\";\nimport { generateState, parseState } from \"./oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./utils/hide-metadata.mjs\";\nimport { generateId } from \"./utils/index.mjs\";\nimport { APIError } from \"./api/index.mjs\";\nimport { betterAuth } from \"./auth/full.mjs\";\nimport { getCurrentAdapter } from \"@better-auth/core/context\";\nimport { createTelemetry, getTelemetryAuthConfig } from \"@better-auth/telemetry\";\n\nexport * from \"@better-auth/core\"\n\nexport * from \"@better-auth/core/db\"\n\nexport * from \"@better-auth/core/env\"\n\nexport * from \"@better-auth/core/error\"\n\nexport * from \"@better-auth/core/oauth2\"\n\nexport * from \"@better-auth/core/utils\"\n\nexport { APIError, HIDE_METADATA, betterAuth, createTelemetry, generateGenericState, generateId, generateState, getCurrentAdapter, getTelemetryAuthConfig, parseGenericState, parseState };"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA","ignoreList":[0]}},
    {"offset": {"line": 4553, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/better-auth/dist/client/parser.mjs","sources":["file:///Users/ivanmuccini/Desktop/chatapp/chat/node_modules/better-auth/src/client/parser.ts"],"sourcesContent":["const PROTO_POLLUTION_PATTERNS = {\n\tproto:\n\t\t/\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/,\n\tconstructor:\n\t\t/\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/,\n\tprotoShort: /\"__proto__\"\\s*:/,\n\tconstructorShort: /\"constructor\"\\s*:/,\n} as const;\n\nconst JSON_SIGNATURE =\n\t/^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\n\nconst SPECIAL_VALUES = {\n\ttrue: true,\n\tfalse: false,\n\tnull: null,\n\tundefined: undefined,\n\tnan: Number.NaN,\n\tinfinity: Number.POSITIVE_INFINITY,\n\t\"-infinity\": Number.NEGATIVE_INFINITY,\n} as const;\n\nconst ISO_DATE_REGEX =\n\t/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,7}))?(?:Z|([+-])(\\d{2}):(\\d{2}))$/;\n\ntype ParseOptions = {\n\t/** Throw errors instead of returning the original value */\n\tstrict?: boolean | undefined;\n\t/** Log warnings when suspicious patterns are detected */\n\twarnings?: boolean | undefined;\n\t/** Custom reviver function */\n\treviver?: ((key: string, value: any) => any) | undefined;\n\t/** Automatically convert ISO date strings to Date objects */\n\tparseDates?: boolean | undefined;\n};\n\nfunction isValidDate(date: Date): boolean {\n\treturn date instanceof Date && !isNaN(date.getTime());\n}\n\nfunction parseISODate(value: string): Date | null {\n\tconst match = ISO_DATE_REGEX.exec(value);\n\tif (!match) return null;\n\n\tconst [\n\t\t,\n\t\tyear,\n\t\tmonth,\n\t\tday,\n\t\thour,\n\t\tminute,\n\t\tsecond,\n\t\tms,\n\t\toffsetSign,\n\t\toffsetHour,\n\t\toffsetMinute,\n\t] = match;\n\n\tconst date = new Date(\n\t\tDate.UTC(\n\t\t\tparseInt(year!, 10),\n\t\t\tparseInt(month!, 10) - 1,\n\t\t\tparseInt(day!, 10),\n\t\t\tparseInt(hour!, 10),\n\t\t\tparseInt(minute!, 10),\n\t\t\tparseInt(second!, 10),\n\t\t\tms ? parseInt(ms.padEnd(3, \"0\"), 10) : 0,\n\t\t),\n\t);\n\n\tif (offsetSign) {\n\t\tconst offset =\n\t\t\t(parseInt(offsetHour!, 10) * 60 + parseInt(offsetMinute!, 10)) *\n\t\t\t(offsetSign === \"+\" ? -1 : 1);\n\t\tdate.setUTCMinutes(date.getUTCMinutes() + offset);\n\t}\n\n\treturn isValidDate(date) ? date : null;\n}\n\nfunction betterJSONParse<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = {},\n): T {\n\tconst {\n\t\tstrict = false,\n\t\twarnings = false,\n\t\treviver,\n\t\tparseDates = true,\n\t} = options;\n\n\tif (typeof value !== \"string\") {\n\t\treturn value as T;\n\t}\n\n\tconst trimmed = value.trim();\n\n\tif (\n\t\ttrimmed.length > 0 &&\n\t\ttrimmed[0] === '\"' &&\n\t\ttrimmed.endsWith('\"') &&\n\t\t!trimmed.slice(1, -1).includes('\"')\n\t) {\n\t\treturn trimmed.slice(1, -1) as T;\n\t}\n\n\tconst lowerValue = trimmed.toLowerCase();\n\tif (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) {\n\t\treturn SPECIAL_VALUES[lowerValue as keyof typeof SPECIAL_VALUES] as T;\n\t}\n\n\tif (!JSON_SIGNATURE.test(trimmed)) {\n\t\tif (strict) {\n\t\t\tthrow new SyntaxError(\"[better-json] Invalid JSON\");\n\t\t}\n\t\treturn value as T;\n\t}\n\n\tconst hasProtoPattern = Object.entries(PROTO_POLLUTION_PATTERNS).some(\n\t\t([key, pattern]) => {\n\t\t\tconst matches = pattern.test(trimmed);\n\t\t\tif (matches && warnings) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[better-json] Detected potential prototype pollution attempt using ${key} pattern`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn matches;\n\t\t},\n\t);\n\n\tif (hasProtoPattern && strict) {\n\t\tthrow new Error(\n\t\t\t\"[better-json] Potential prototype pollution attempt detected\",\n\t\t);\n\t}\n\n\ttry {\n\t\tconst secureReviver = (key: string, value: any) => {\n\t\t\tif (\n\t\t\t\tkey === \"__proto__\" ||\n\t\t\t\t(key === \"constructor\" &&\n\t\t\t\t\tvalue &&\n\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\"prototype\" in value)\n\t\t\t) {\n\t\t\t\tif (warnings) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[better-json] Dropping \"${key}\" key to prevent prototype pollution`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (parseDates && typeof value === \"string\") {\n\t\t\t\tconst date = parseISODate(value);\n\t\t\t\tif (date) {\n\t\t\t\t\treturn date;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reviver ? reviver(key, value) : value;\n\t\t};\n\n\t\treturn JSON.parse(trimmed, secureReviver);\n\t} catch (error) {\n\t\tif (strict) {\n\t\t\tthrow error;\n\t\t}\n\t\treturn value as T;\n\t}\n}\n\nexport function parseJSON<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = { strict: true },\n): T {\n\treturn betterJSONParse<T>(value, options);\n}\n"],"names":["value"],"mappings":"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"}}]
}